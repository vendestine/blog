<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>算法-搜索 | Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="BFS和DFS以及其基本应用模型">
<meta property="og:type" content="article">
<meta property="og:title" content="算法-搜索">
<meta property="og:url" content="https://vendestine.github.io/blog/2022/04/20/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/acwing/bfs-dfs/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="BFS和DFS以及其基本应用模型">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-04-20T14:32:54.000Z">
<meta property="article:modified_time" content="2023-08-13T09:07:16.195Z">
<meta property="article:author" content="Wenzhe Li">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="搜索">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/blog/atom.xml" title="Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/blog/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/blog/css/style.css">

  
    
<link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/blog/">Home</a>
        
          <a class="main-nav-link" href="/blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/blog/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://vendestine.github.io/blog"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-算法笔记/acwing/bfs-dfs" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/2022/04/20/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/acwing/bfs-dfs/" class="article-date">
  <time class="dt-published" datetime="2022-04-20T14:32:54.000Z" itemprop="datePublished">2022-04-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/">算法笔记</a>►<a class="article-category-link" href="/blog/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/AcWing/">AcWing</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      算法-搜索
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="DFS-与-BFS-的区别"><a href="#DFS-与-BFS-的区别" class="headerlink" title="DFS 与 BFS 的区别"></a>DFS 与 BFS 的区别</h2><table>
<thead>
<tr>
<th>搜索方法</th>
<th>数据结构</th>
<th>空间复杂度</th>
<th>性质</th>
</tr>
</thead>
<tbody><tr>
<td>DFS</td>
<td>stack</td>
<td>$O(h)$</td>
<td>不具有最短性</td>
</tr>
<tr>
<td>BFS</td>
<td>queue</td>
<td>$O(2^h)$</td>
<td>最短路径</td>
</tr>
</tbody></table>
<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><ol>
<li>DFS 俗称爆搜，其中最重要的就是<strong>搜索顺序</strong></li>
<li>DFS 搜索到叶节点后，就会回溯到发生分支的地方，注意<strong>回溯后要恢复现场</strong></li>
<li>DFS 有的时候会剪枝优化，剪枝大致有两种，一种是最优化剪枝，一种是可行性剪枝（八皇后问题）<br></li>
</ol>
<h2 id="回溯角度DFS"><a href="#回溯角度DFS" class="headerlink" title="回溯角度DFS"></a>回溯角度DFS</h2><p>DFS一般有两种角度，一种是回溯角度DFS，也就是搜索所有的分支，这种就是回溯类的题目，但其实本质还是DFS<br>然后分析流程如下</p>
<ol>
<li>首先确定搜索顺序，例如按位，按行，按列等等</li>
<li>然后写DFS函数，确定参数和返回值，返回值的确定取决于我们每一层想要存什么；参数取决于每一层需要什么信息<br>其中参数的写法不固定，可以有很多种写法，这里我们固定写法。对于输入我们直接作为引用放入DFS参数（类似全局变量的效果）<br>然后搜索位置和对于当前分支的变量 我们当作局部变量放入DFS参数，这样就可以达到自动回溯的效果<br>然后是否恢复现场取决于回溯到当前层时，你想要的情况是什么</li>
</ol>
<br>

<h3 id="842-排列数字"><a href="#842-排列数字" class="headerlink" title="842. 排列数字"></a><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/844/">842. 排列数字</a></h3><hr>
<h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><p>DFS主要就是明确搜索的顺序，这题搜索的顺序很简单，直接按位搜索即可。</p>
<p>DFS参数，回溯，恢复现场的本质：</p>
<ol>
<li>DFS其实就是递归搜索树，层层进入，层层回溯</li>
<li>如果变量在DFS的参数里，那么变量会跟着一起回溯，是系统栈帮我们自动回溯的</li>
<li>如果变量不在DFS的参数里，那么当然变量就不会自动回溯了，所以如果你需要回溯的话，可以自己手动回溯</li>
<li>恢复现场实际就是 变量 回溯到当前层的时候 变量 要恢复到当前层未修改时的状态<br>所以是否恢复现场就取决于 你是否想让当前层恢复到未修改时的状态<br><strong>经验之谈：外部搜索（多个分支）需要恢复现场  内部搜索（单个分支）不需要恢复现场</strong></li>
<li>变量恢复现场 要满足两点 1. 变量需要回溯到当前层 2. 当前层最终变量没有修改  <strong>手动回溯一定满足这两点，自动回溯可能不满足第二点</strong></li>
</ol>
<p>以全排列为例分析，首先明确全排列问题，搜多个分支，为了防止污染其他分支，肯定是要<strong>恢复现</strong>场的</p>
<ol>
<li>版本1，state没有作为DFS的参数，肯定是要手动回溯的，满足恢复现场</li>
<li>版本2，state还是没有作为DFS的参数，只是进行了状态压缩，和版本1一样，需要手动回溯，满足恢复现场</li>
<li>版本3，state作为DFS的参数，自动回溯了，并且当前层state没有改变，满足恢复现场</li>
<li>版本4，state作为DFS的参数，自动回溯了，但是当前层的state改变了，所以自动回溯无法恢复现场，所以还是手动回溯恢复现场</li>
</ol>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 最直接版本</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> path[N];   <span class="comment">//保存方案</span></span><br><span class="line"><span class="type">bool</span> st[N];    <span class="comment">//状态数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span>  <span class="comment">//u代表DFS的当前层的信息 位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == n)    <span class="comment">//递归边界</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) cout &lt;&lt; path[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;   <span class="comment">//输出当前方案</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)    <span class="comment">//当前位可以填哪些数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])             <span class="comment">//没有被用过的数</span></span><br><span class="line">        &#123;</span><br><span class="line">            path[u] = i;</span><br><span class="line">            st[i] = <span class="literal">true</span>;      <span class="comment">//i被用过</span></span><br><span class="line">            <span class="built_in">dfs</span>(u+<span class="number">1</span>);          <span class="comment">//DFS进入下一层      </span></span><br><span class="line">            st[i] = <span class="literal">false</span>;     <span class="comment">//手动回溯 恢复现场</span></span><br><span class="line">            <span class="comment">//这里path不需要手动回溯，因为其他分支可以完全覆盖它</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 状态压缩</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> path[N];</span><br><span class="line"><span class="type">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span> <span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) cout &lt;&lt; path[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(state &gt;&gt; i &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">            path[u] = i;</span><br><span class="line">            state += (<span class="number">1</span> &lt;&lt; i);  <span class="comment">//当前层的状态改变了</span></span><br><span class="line">            <span class="built_in">dfs</span>(u + <span class="number">1</span>);</span><br><span class="line">            state -=(<span class="number">1</span> &lt;&lt; i);  <span class="comment">//手动回溯 恢复现场</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. 状态压缩 + state 局部变量</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> path[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span> <span class="params">(<span class="type">int</span> u, <span class="type">int</span> state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) cout &lt;&lt; path[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;   <span class="comment">//当前位可以填哪些数</span></span><br><span class="line">        <span class="comment">//状态压缩优化空间</span></span><br><span class="line">        <span class="keyword">if</span> (!(state &gt;&gt; i &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">            path[u] = i;</span><br><span class="line">            <span class="built_in">dfs</span>(u + <span class="number">1</span>, state + (<span class="number">1</span> &lt;&lt; i));</span><br><span class="line">            <span class="comment">//我们在每层里面没有修改过state，自动回溯就可以满足恢复现场</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4. 状态压缩 + state局部变量</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> path[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span> <span class="params">(<span class="type">int</span> u, <span class="type">int</span> state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) cout &lt;&lt; path[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (!(state &gt;&gt; i &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">            path[u] = i;</span><br><span class="line">            state += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            <span class="built_in">dfs</span>(u + <span class="number">1</span>, state);</span><br><span class="line">            state -= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            <span class="comment">//因为在每层里面我们还是修改过state，自动回溯后还是不满足，所以自己手动回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/47087/">[1]. yxc</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/30988/">[2]. AcWing 842. 排列数字–深度优先遍历代码+注释 </a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/75527/">[3]. AcWing 842. 排列数字—本文主要阐述代码中递归的思想！</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/30724/">[4]. Bug-Free 位运算代码</a></p>
<br>

<h3 id="843-n-皇后问题"><a href="#843-n-皇后问题" class="headerlink" title="843. n-皇后问题"></a><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/problem/content/906/">843. n-皇后问题</a></h3><hr>
<h4 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h4><p>DFS问题，主要是明确搜索顺序，N皇后问题这里有两种常见的搜索顺序</p>
<ol>
<li>搜索行，然后可行性剪枝（列 + 两个对角线） &#x2F;&#x2F;效率更高</li>
<li>搜索格子，然后可行性剪枝（行 + 列 + 两个对角线）</li>
</ol>
<h4 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h4><p><strong>思路1</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按位置搜索，所以搜索树的层存的是位置信息，每个位置可以放皇后或者不放皇后 两分支</span></span><br><span class="line"><span class="comment">//显然为了区别dfs函数是否放皇后，我们加了s参数，代表皇后的数量</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">bool</span> row[N], col[N], dg[N * <span class="number">2</span>], udg[N * <span class="number">2</span>];  <span class="comment">//多个状态数组进行可行性剪枝</span></span><br><span class="line"><span class="type">char</span> g[N][N];  <span class="comment">//存储图 = 存储方案 这里的方案是一张图</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s &gt; n) <span class="keyword">return</span>;    <span class="comment">//可行性剪枝</span></span><br><span class="line">    <span class="keyword">if</span> (y == n) y = <span class="number">0</span>, x ++ ;  <span class="comment">//当列坐标越界，跳转到下一行的首位</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x == n)   <span class="comment">//递归边界， 所有行都搜索完</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == n)  <span class="comment">//皇后数量满足要求</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">puts</span>(g[i]);  <span class="comment">//输出答案</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">//注意这个return一定要在外面，如果在里面某些分支永远到不了边界，最后会tle</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g[x][y] = <span class="string">&#x27;.&#x27;</span>;  <span class="comment">//初始化当前格子</span></span><br><span class="line">    <span class="built_in">dfs</span>(x, y + <span class="number">1</span>, s);  <span class="comment">//不放皇后</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//放皇后 利用状态数组进行可行性剪枝</span></span><br><span class="line">    <span class="comment">//没有把状态放入dfs参数中，所以需要手动回溯</span></span><br><span class="line">    <span class="keyword">if</span> (!row[x] &amp;&amp; !col[y] &amp;&amp; !dg[x + y] &amp;&amp; !udg[x - y + n])</span><br><span class="line">    &#123;</span><br><span class="line">        row[x] = col[y] = dg[x + y] = udg[x - y + n] = <span class="literal">true</span>;</span><br><span class="line">        g[x][y] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(x, y + <span class="number">1</span>, s + <span class="number">1</span>);</span><br><span class="line">        g[x][y] = <span class="string">&#x27;.&#x27;</span>;   <span class="comment">//注意这里的图需要手动回溯，因为它不会被其他的分支完全覆盖，所以需要回溯到原始状态</span></span><br><span class="line">        row[x] = col[y] = dg[x + y] = udg[x - y + n] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>思路2</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按行搜索，所以搜索树的层存的是行信息，每一行必然会放一个皇后</span></span><br><span class="line"><span class="comment">//看是在当前行的哪一列放皇后 n分支</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;   <span class="comment">//防止对角线下标越界</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> col[N], dg[N], udg[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == n)  <span class="comment">//递归边界，所有行都搜索完</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">puts</span>(g[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )  <span class="comment">//每一行必然会放一个皇后，所以直接枚举列（n分支）然后利用状态数组进行可行性剪枝</span></span><br><span class="line">        <span class="keyword">if</span> (!col[i] &amp;&amp; !dg[u + i] &amp;&amp; !udg[n - u + i])</span><br><span class="line">        &#123;</span><br><span class="line">            g[u][i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            col[i] = dg[u + i] = udg[n - u + i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(u + <span class="number">1</span>);</span><br><span class="line">            col[i] = dg[u + i] = udg[n - u + i] = <span class="literal">false</span>;</span><br><span class="line">            g[u][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="comment">//提前初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            g[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Reference-1"><a href="#Reference-1" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/47097/">[1]. yxc</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/106979/">[2]. n-皇后问题 （图解 + 朴素+剪枝） 看这一篇就够了</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/30866/">[3]. bug free 对角线</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/2731480/">[4]. 状态压缩版本</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/2820/">[5]. 评论区解答</a></p>
<br>


<h2 id="DFS之连通性模型"><a href="#DFS之连通性模型" class="headerlink" title="DFS之连通性模型"></a>DFS之连通性模型</h2><h3 id="1112-迷宫"><a href="#1112-迷宫" class="headerlink" title="1112. 迷宫"></a><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1114/">1112. 迷宫</a></h3><hr>
<h4 id="基本思路-2"><a href="#基本思路-2" class="headerlink" title="基本思路"></a>基本思路</h4><p>很经典的DFS连通性问题，由于这里只需要判断是否存在合法方案，而不是找出所有方案，所以DFS和BFS其实都是可以做的<br>这里我们用DFS因为DFS的代码更简短，但还是要根据数据范围判断是否有爆栈的风险</p>
<p>这里着重说一下恢复现场的问题，内部搜索不需要恢复现场，外部搜索需要恢复现场，连通性问题都是内部搜索问题。<br>个人理解内部搜索相当于是搜到一条合法分支，但是外部搜索就是需要搜到合法的所有的合法分支。<br>Reference里会有更多不同的理解</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> g[N][N];       <span class="comment">//存储方案</span></span><br><span class="line"><span class="type">int</span> xa, ya, xb, yb; <span class="comment">//两点坐标  </span></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;   <span class="comment">//方向向量</span></span><br><span class="line"><span class="type">bool</span> st[N][N];  <span class="comment">//标记状态</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (g[x][y] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">//如果该点为障碍物，退出</span></span><br><span class="line">    <span class="keyword">if</span> (x == xb &amp;&amp; y == yb) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//当起点坐标等于终点坐标，返回true</span></span><br><span class="line"></span><br><span class="line">    st[x][y] = <span class="literal">true</span>;                     <span class="comment">//标记当前点已经走过</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ )        <span class="comment">//从x,y点开始遍历四个方向</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = x + dx[i], b = y + dy[i];   </span><br><span class="line">        <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= n) <span class="keyword">continue</span>;   <span class="comment">//新坐标是否在地图内</span></span><br><span class="line">        <span class="keyword">if</span> (st[a][b]) <span class="keyword">continue</span>;                             <span class="comment">//新坐标已经走过</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(a, b)) <span class="keyword">return</span> <span class="literal">true</span>;                         </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, g[i]);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;xa, &amp;ya, &amp;xb, &amp;yb);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);   <span class="comment">//一共有k个地图，所以每次都要初始化标记数组</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(xa, ya)) <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>

<h4 id="Reference-2"><a href="#Reference-2" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/96399/">[1]. 迷宫DFS + BFS（附带注释</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/134071/">[2]. if(dfs(a, b))的解释</a></p>
<br>

<h3 id="1113-红与黑"><a href="#1113-红与黑" class="headerlink" title="1113. 红与黑"></a><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1115/">1113. 红与黑</a></h3><hr>
<h4 id="基本思路-3"><a href="#基本思路-3" class="headerlink" title="基本思路"></a>基本思路</h4><p>DFS连通性问题，唯一的区别就是DFS的返回值需要注意一下。</p>
<h4 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> st[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span> <span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    st[x][y] = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ ) &#123;</span><br><span class="line">        <span class="type">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span> (st[a][b]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt; n - <span class="number">1</span> || b &lt; <span class="number">0</span> || b &gt; m - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (g[a][b] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">        cnt += <span class="built_in">dfs</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; m &gt;&gt; n, n || m) &#123;     <span class="comment">//输入及停止条件，注意m,n的顺序 其中m是列，n是行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++ ) cin &gt;&gt; g[i];</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++ )</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;@&#x27;</span>) x = i, y = j;   <span class="comment">//找到DFS的起点</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">        cout &lt;&lt; <span class="built_in">dfs</span>(x, y) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Reference-3"><a href="#Reference-3" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/32866/">[1]. 红与黑</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/134130/">[2]. yxc代码</a></p>
<br>

<h2 id="DFS之搜索顺序"><a href="#DFS之搜索顺序" class="headerlink" title="DFS之搜索顺序"></a>DFS之搜索顺序</h2><h3 id="1116-马走日"><a href="#1116-马走日" class="headerlink" title="1116. 马走日"></a><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1118/">1116. 马走日</a></h3><hr>
<h4 id="基本思路-4"><a href="#基本思路-4" class="headerlink" title="基本思路"></a>基本思路</h4><blockquote>
<p>这里通过递归来更深刻的认识一下回溯和函数栈：<br>首先递归函数会不断的调用自己，其实也就是不断地<strong>进入</strong>问题，相当于是从<strong>外部层层进入内部</strong>，这在代码里其实是比较好清晰的，也就是递归函数的写法（怎么层层进入）<br>而回溯是函数f()从内部完成后<strong>跳出</strong>到外部到的过程，相当于是从<strong>内部层层跳出到外部</strong>，在代码里不是很能体现出来，但的确是进行了回溯。那么进入从外到内，跳出从内到外，是不是突然发现和一个数据结构很匹配，没错就是<strong>栈</strong><br>这里我们 通过递归函数 使用了隐式的函数栈完成了进入和回溯的过程，这也是为什么涉及到递归的代码简短的原因。</p>
</blockquote>
<blockquote>
<p>然后关于恢复现场在这里有了更深刻的认识：其实主要就是看搜索元素是否会互相影响<br>连通性问题，搜索元素是点，点和点直接不会影响，因为每个点只会走一次，所以不需要恢复现场      &#x2F;&#x2F;外部多表现为搜一个分支<br>现在这道题，搜索元素是路径，路径之间可能有交叉受到影响，所以需要恢复现场                   &#x2F;&#x2F;外部多表现为搜多个分支</p>
</blockquote>
<p>主要就是注意日的方向有8个，其他的比较容易分析</p>
<h4 id="参考代码-3"><a href="#参考代码-3" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">bool</span> st[N][N];</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="type">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>&#125;;   <span class="comment">//方向数组 </span></span><br><span class="line"><span class="type">int</span> dy[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> cnt)</span>     <span class="comment">//cnt记录当前走了几个格子</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt == n * m)</span><br><span class="line">    &#123;</span><br><span class="line">        ans ++ ;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    st[x][y] = <span class="literal">true</span>;    <span class="comment">//标记</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (st[a][b]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(a, b, cnt + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    st[x][y] = <span class="literal">false</span>;   <span class="comment">//恢复现场，哪里标记，哪里恢复</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;x, &amp;y);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(x, y, <span class="number">1</span>);   <span class="comment">//因为递归的时候已经有一个点填进去了，因该赋值为1才对</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Reference-4"><a href="#Reference-4" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/6033/">[1]. yingzhaoyang</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/134135/">[2]. yxc</a></p>
<br>

<h3 id="1117-单词接龙"><a href="#1117-单词接龙" class="headerlink" title="1117. 单词接龙"></a><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1119/">1117. 单词接龙</a></h3><hr>
<h4 id="基本思路-5"><a href="#基本思路-5" class="headerlink" title="基本思路"></a>基本思路</h4><p>这里就是要明确搜索顺序，也就是存在公共前后缀的时候才可以往下搜索。</p>
<h4 id="参考代码-4"><a href="#参考代码-4" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string word[N];</span><br><span class="line"><span class="type">int</span> g[N][N];<span class="comment">//代表编号i的可以被j拼接  如i：asd，j：sdf，拼接长度为最小值g[i][j] = 2，i从0开始记位</span></span><br><span class="line"><span class="type">int</span> used[N];<span class="comment">//编号为i的单词使用次数</span></span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string dragon, <span class="type">int</span> last)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ans = <span class="built_in">max</span>((<span class="type">int</span>) dragon.<span class="built_in">size</span>(), ans);<span class="comment">//取最大值，dragon.size()为当前合并的长度</span></span><br><span class="line"></span><br><span class="line">    used[last]++;<span class="comment">//编号为last的单词被用次数++；</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (g[last][i] &amp;&amp; used[i] &lt; <span class="number">2</span>)<span class="comment">//used[i]&lt;2代表单词用次数不超过2</span></span><br><span class="line">            <span class="built_in">dfs</span>(dragon + word[i].<span class="built_in">substr</span>(g[last][i]), i); <span class="comment">//编号为last的可以被i拼接现在尾巴为i号</span></span><br><span class="line"></span><br><span class="line">    used[last]--;<span class="comment">//恢复现场</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; word[i];</span><br><span class="line">    <span class="type">char</span> start;</span><br><span class="line">    cin &gt;&gt; start;<span class="comment">//首字母</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)<span class="comment">//遍历得到各个g[i][j]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            string a = word[i], b = word[j];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt; <span class="built_in">min</span>(a.<span class="built_in">size</span>(), b.<span class="built_in">size</span>()); k++)</span><br><span class="line">                <span class="keyword">if</span> (a.<span class="built_in">substr</span>(a.<span class="built_in">size</span>() - k, k) == b.<span class="built_in">substr</span>(<span class="number">0</span>, k)) &#123;</span><br><span class="line">                    g[i][j] = k;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)<span class="comment">//找到首字母为strat的单词开始做dfs，dfs中会自动找到最大值</span></span><br><span class="line">        <span class="keyword">if</span> (word[i][<span class="number">0</span>] == start)</span><br><span class="line">            <span class="built_in">dfs</span>(word[i], i);<span class="comment">//从word[i]开始遍历，i代表现在是第几个单词</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Reference-5"><a href="#Reference-5" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/59984/">[1]. 单词接龙(y总代码详细解析版)</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/120915/">[2]. tonngw</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/118005/">[3]. DFS 求最优解</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/67911/">[4]. 字符串预处理搜索</a></p>
<br>

<h3 id="1118-分成互质组"><a href="#1118-分成互质组" class="headerlink" title="1118. 分成互质组"></a><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1120/">1118. 分成互质组</a></h3><h4 id="基本思路-6"><a href="#基本思路-6" class="headerlink" title="基本思路"></a>基本思路</h4><p>此题比较有难度，直接参照大佬们的题解把，原本是最大团问题，这里数据范围不大，所以就可以利用DFS来做<br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/120932/">[1]. tonngw</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/22629/">[2].  松鼠爱葡萄 </a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/10364/">[3]. 两种解法</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/56339/">[4]. 分成互质组(y总代码版的保姆级注释)</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/65632/">[5]. 分成互质组（最简单的思路</a></p>
<h4 id="参考代码-5"><a href="#参考代码-5" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如何搜所有方案：按照一组一组的来搜，直到当前组不能放其他数了，再搜索下一组可以放哪些数，同时以组合的形式搜索，定一个 start</span></span><br><span class="line"><span class="comment">// 枚举每个数的时候，有两种选择</span></span><br><span class="line"><span class="comment">// 1. 把这个数加入到最后一组中</span></span><br><span class="line"><span class="comment">// 2. 如果不能加入，才新开一个组</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> p[N]; <span class="comment">// 存储每个数</span></span><br><span class="line"><span class="type">int</span> group[N][N]; <span class="comment">// 存储每个组中的数的‘下标’，最多有 N 组，每个数一组</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 记录每个数是否已经被加入到其他组了</span></span><br><span class="line"><span class="type">int</span> ans = N; <span class="comment">// 最多有 N 组，每个数一组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="comment">// 欧几里得算法 求最大公约数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> group[], <span class="type">int</span> gc, <span class="type">int</span> i)</span> <span class="comment">// 判断当前数和组内所有数是否互质</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; gc; j ++ )</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">gcd</span>(p[group[j]], p[i]) &gt; <span class="number">1</span>) <span class="comment">// 如果当前数 p[i] 和组内任意一个数的最大公约数大于 1 则不互质</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// g：第几组，gc：组内元素个数，tc：已经搜索了多少个数了，start：组内从哪个数开始搜索（组合形式搜索防止搜索重复方案）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> g, <span class="type">int</span> gc, <span class="type">int</span> tc, <span class="type">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (g &gt; ans) <span class="keyword">return</span>; <span class="comment">// 剪枝，如果当前方案组数大于 ans，那它一定不是最优，否则比答案小</span></span><br><span class="line">    <span class="keyword">if</span> (tc == n) ans = g; <span class="comment">// 更新最小值</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>; <span class="comment">// 是否需要开新组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; n; i ++ ) &#123; <span class="comment">// 搜索当前组内可以放哪些数</span></span><br><span class="line">        <span class="keyword">if</span> (!st[i] &amp;&amp; <span class="built_in">check</span>(group[g], gc, i)) &#123; <span class="comment">// 如果当前数没用过 且 和当前组内所有数都互质，则可以将其加入到组内</span></span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            group[g][gc] = i; <span class="comment">// 将当前数的下标加到组内</span></span><br><span class="line">            <span class="built_in">dfs</span>(g, gc + <span class="number">1</span>, tc + <span class="number">1</span>, i + <span class="number">1</span>); <span class="comment">// 从下标 i + 1 开始继续搜索</span></span><br><span class="line"></span><br><span class="line">            st[i] = <span class="literal">false</span>; <span class="comment">// 回溯</span></span><br><span class="line"></span><br><span class="line">            flag = <span class="literal">false</span>; <span class="comment">// 可以放到当前组中，不用开新租</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flag) <span class="built_in">dfs</span>(g + <span class="number">1</span>, <span class="number">0</span>, tc, <span class="number">0</span>); <span class="comment">// 开一个新组，组内 0 个数，已经搜了 tc 个数了，从下标 0 开始搜</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; p[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 从第 1 组开始搜索，当前组内 0 个数，总共搜索了 0 个数，从第一个数开始搜索</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="DFS之剪枝"><a href="#DFS之剪枝" class="headerlink" title="DFS之剪枝"></a>DFS之剪枝</h2><p>剪枝策略</p>
<ol>
<li>优化搜索顺序</li>
<li>排除等效冗余</li>
<li>可行性剪枝</li>
<li>最优性剪枝</li>
<li>记忆化搜索 （实际上是DP)</li>
</ol>
<h3 id="165-小猫爬山"><a href="#165-小猫爬山" class="headerlink" title="165. 小猫爬山"></a><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/167/">165. 小猫爬山</a></h3><h4 id="基本思路-7"><a href="#基本思路-7" class="headerlink" title="基本思路"></a>基本思路</h4><p>参照大佬们的题解看吧<br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/32118/">[1].  Bug-Free</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/13687/">[2]. 代码注释齐全</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/126574/">[3.] 方法选择思考</a></p>
<h4 id="参考代码-6"><a href="#参考代码-6" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> sum[N];<span class="comment">//每辆车装的重量</span></span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> res=N;<span class="comment">//最多N辆车，每人一辆</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a,<span class="type">const</span> <span class="type">int</span>&amp; b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> cnt)</span><span class="comment">//当前正在安排的猫的编号为u，已经使用的车辆数量为cnt,当前这只猫的两种安排方案：插到现有的或新开一辆</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//最优性剪枝</span></span><br><span class="line">    <span class="keyword">if</span>(cnt&gt;=res) <span class="keyword">return</span>;<span class="comment">//当前方案不是最优的，不用再搜了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//边界条件,正在安排第n+1只猫，结束</span></span><br><span class="line">    <span class="keyword">if</span>(u==n)</span><br><span class="line">    &#123;</span><br><span class="line">        res=cnt;<span class="comment">//cnt一定小于res，因为cnt过了第一个判断条件</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方案一：插入已有的cnt车辆，编号0-cnt-1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">//可行性剪枝，如果坐的下的话才能坐</span></span><br><span class="line">        <span class="keyword">if</span>(sum[i]+w[u]&lt;=m)</span><br><span class="line">        &#123;</span><br><span class="line">            sum[i]+=w[u];</span><br><span class="line">            <span class="built_in">dfs</span>(u+<span class="number">1</span>,cnt);</span><br><span class="line">            sum[i]-=w[u];<span class="comment">//恢复现场</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方案二：开一辆新车,编号cnt</span></span><br><span class="line">    sum[cnt]=w[u];</span><br><span class="line">    <span class="built_in">dfs</span>(u+<span class="number">1</span>,cnt+<span class="number">1</span>);</span><br><span class="line">    sum[cnt]=<span class="number">0</span>;<span class="comment">//恢复现场</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    cin&gt;&gt;w[i];</span><br><span class="line">    <span class="comment">//优化搜索顺序</span></span><br><span class="line">    <span class="built_in">sort</span>(w,w+n,cmp);<span class="comment">//从大到小排序</span></span><br><span class="line">    <span class="comment">//y总写法,nb</span></span><br><span class="line">    <span class="comment">//sort(w,w+n);</span></span><br><span class="line">    <span class="comment">//reverse(w,w+n);</span></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//从编号为0的小猫开始安排，刚开始一辆车也没有</span></span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>剪枝与优化还是比较难的，这里先留个坑以后来补！<br><br></p>
<h2 id="DFS之迭代加深，双向DFS，IDA"><a href="#DFS之迭代加深，双向DFS，IDA" class="headerlink" title="DFS之迭代加深，双向DFS，IDA*"></a>DFS之迭代加深，双向DFS，IDA*</h2><p>这个part其实比剪枝要简单，因为他们有个整体的大框架，比较好想，剪枝的话其实和DP一样，比较灵活。</p>
<p><strong>迭代加深</strong>：限制搜索深度，只有失败了，才迭代加深搜索层数。<br>其实和BFS比较相似，区别就是迭代加深它的空间要比BFS小很多，它比较适合答案出现在浅层，但是有非常长分支的时候。</p>
<p><strong>双向DFS</strong>：</p>
<p>对于每个部分直接看相应的题目理解算法。</p>
<h3 id="170-加成序列"><a href="#170-加成序列" class="headerlink" title="170. 加成序列"></a><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/172/">170. 加成序列</a></h3><h4 id="基本思路-8"><a href="#基本思路-8" class="headerlink" title="基本思路"></a>基本思路</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/38248/">[1]. Bug-Free</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/121043/">[2].  tonngw</a></p>
<h4 id="参考代码-7"><a href="#参考代码-7" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> path[N]; <span class="comment">// 存储加成序列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> depth)</span> <span class="comment">// u 表示当前搜索的深度以及要枚举的位置的下标，depth 表示最大搜索深度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u &gt; depth) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果当前搜索深度超过了最大深度还没找到答案，直接返回 false 剪枝</span></span><br><span class="line">    <span class="keyword">if</span> (path[u - <span class="number">1</span>] == n) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 如果序列最后一个数是 n 了说明找到了一种方案直接返回 true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> st[N] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 标记 和 是否被使用过，相同的和只搜一次，保证这个分支上不搜索重复的节点，st 数组只和当前层有关，不涉及恢复现场</span></span><br><span class="line">    <span class="comment">// 从大到小枚举当前位置上可以填的数，且必须是前两两个数的和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = u - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt;= <span class="number">0</span>; j -- ) &#123;</span><br><span class="line">            <span class="type">int</span> s = path[i] + path[j];</span><br><span class="line">            <span class="keyword">if</span> (s &gt; n || s &lt;= path[u - <span class="number">1</span>] || st[s]) <span class="keyword">continue</span>; <span class="comment">// 可行性剪枝 + 排除等效冗余（st[s]）</span></span><br><span class="line"></span><br><span class="line">            st[s] = <span class="literal">true</span>;</span><br><span class="line">            path[u] = s; <span class="comment">// 将和 s 放到当前位置上（下次搜索直接覆盖就行，所以不需要恢复现场）</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(u + <span class="number">1</span>, depth)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 搜索下一个位置上的数</span></span><br><span class="line">            <span class="comment">// 这里不需要 st[s] = false; 回溯，因为在当前层每个和只能用一次</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    path[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 任何序列的第一个数都是 1，最后一个数是 n</span></span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n, n) &#123;</span><br><span class="line">        <span class="type">int</span> max_depth = <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">dfs</span>(<span class="number">1</span>, max_depth)) max_depth ++ ; <span class="comment">// 从第 1 层开始搜下标为 1 的位置上应该填哪个数，搜不到扩大一层</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环结束说明找到了答案，输出加成序列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; max_depth; i ++ ) cout &lt;&lt; path[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="171-送礼物"><a href="#171-送礼物" class="headerlink" title="171. 送礼物"></a><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/173/">171. 送礼物</a></h3><h4 id="基本思路-9"><a href="#基本思路-9" class="headerlink" title="基本思路"></a>基本思路</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/38250/">[1]. Bug-Free</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/118287/">[2]. 美琴</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/127127/">[3]. Repeater</a></p>
<h4 id="参考代码-8"><a href="#参考代码-8" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1</span> &lt;&lt; <span class="number">25</span>;  <span class="comment">// k最大是25， 因此最多可能有2^25种方案</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">int</span> g[<span class="number">50</span>];       <span class="comment">// 存储所有物品的重量</span></span><br><span class="line"><span class="type">int</span> weights[N];  <span class="comment">// weights存储能凑出来的所有的重量</span></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> ans;  <span class="comment">// 用ans来记录一个全局最大值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// u表示当前枚举到哪个数了， s表示当前的和</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果我们当前已经枚举完第k个数（下标从0开始的）了， 就把当前的s， 加到weights中去</span></span><br><span class="line">    <span class="keyword">if</span> (u == k) &#123;</span><br><span class="line">        weights[cnt++] = s;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举当前不选这个物品</span></span><br><span class="line">    <span class="built_in">dfs</span>(u + <span class="number">1</span>, s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选这个物品, 做一个可行性剪枝</span></span><br><span class="line">    <span class="keyword">if</span> ((LL)s + g[u] &lt;= m) &#123;  <span class="comment">//计算和的时候转成long long防止溢出</span></span><br><span class="line">        <span class="built_in">dfs</span>(u + <span class="number">1</span>, s + g[u]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == n) &#123;  <span class="comment">// 如果已经找完了n个节点， 那么需要二分一下</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = cnt - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (weights[mid] &lt;= m - s)</span><br><span class="line">                l = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, weights[l] + s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不选择当前这个物品</span></span><br><span class="line">    <span class="built_in">dfs2</span>(u + <span class="number">1</span>, s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择当前这个物品</span></span><br><span class="line">    <span class="keyword">if</span> ((LL)s + g[u] &lt;= m)</span><br><span class="line">        <span class="built_in">dfs2</span>(u + <span class="number">1</span>, s + g[u]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cin &gt;&gt; g[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优化搜索顺序（从大到小）</span></span><br><span class="line">    <span class="built_in">sort</span>(g, g + n);</span><br><span class="line">    <span class="built_in">reverse</span>(g, g + n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把前k个物品的重量打一个表</span></span><br><span class="line">    k = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 做完之后， 把weights数组从小到大排序</span></span><br><span class="line">    <span class="built_in">sort</span>(weights, weights + cnt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判重</span></span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; cnt; i++)</span><br><span class="line">        <span class="keyword">if</span> (weights[i] != weights[i - <span class="number">1</span>])</span><br><span class="line">            weights[t++] = weights[i];</span><br><span class="line">    cnt = t;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从k开始， 当前的和是0</span></span><br><span class="line">    <span class="built_in">dfs2</span>(k, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>


<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><ol>
<li>最短路问题一般可以用BFS</li>
<li>DP问题是特殊的最短路问题，即没有环存在的最短路问题</li>
<li>DFS可以保证搜到终点，但不能保证搜到的路径是最短的，所以一般要搜出所有的路径，最短路问题里就很容易超时</li>
<li>DFS没有固定的模板，BFS有常用的模板</li>
<li>边权都为1的最短路问题才会用到BFS</li>
</ol>
<h3 id="844-走迷宫"><a href="#844-走迷宫" class="headerlink" title="844. 走迷宫"></a><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/846/">844. 走迷宫</a></h3><hr>
<h4 id="基本思路-10"><a href="#基本思路-10" class="headerlink" title="基本思路"></a>基本思路</h4><p>BFS模板：</p>
<ol>
<li>初始化队列</li>
<li>while queue不为空</li>
<li>队顶元素出队</li>
<li>遍历，合法的入队</li>
</ol>
<h4 id="参考代码-9"><a href="#参考代码-9" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;   <span class="comment">//定义坐标的数据结构</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> g[N][N], d[N][N];        <span class="comment">//g存图 d记录点的距离</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;PII&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);   <span class="comment">//初始化各个点到原点的距离为-1</span></span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;               <span class="comment">//原点到自己的距离为0</span></span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);            <span class="comment">//原点进队</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;    <span class="comment">//定义方向向量，这里是上右下左</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ )  <span class="comment">//往四个方向走</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = t.first + dx[i], y = t.second + dy[i];</span><br><span class="line">            <span class="comment">//在边界内 并且是空地可以走 且之前没有走过</span></span><br><span class="line">            <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m &amp;&amp; g[x][y] == <span class="number">0</span> &amp;&amp; d[x][y] == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                d[x][y] = d[t.first][t.second] + <span class="number">1</span>;     <span class="comment">//更新</span></span><br><span class="line">                q.<span class="built_in">push</span>(&#123;x, y&#125;);                         <span class="comment">//进队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d[n - <span class="number">1</span>][m - <span class="number">1</span>]; <span class="comment">//返回右下角点的距离</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">            cin &gt;&gt; g[i][j]; <span class="comment">//读入地图信息</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>

<h4 id="Reference-6"><a href="#Reference-6" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/47098/">[1]. yxc</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/57622/">[2]. AcWing 844. 走迷宫(C++详细注释)</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/9321/">[3]. 走迷宫(数组模拟，C++STL， python、打印路径)</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/39295/">[4]. Bug-Free</a></p>
<br>

<h2 id="DFS相关题目"><a href="#DFS相关题目" class="headerlink" title="DFS相关题目"></a>DFS相关题目</h2><h3 id="思路大方向"><a href="#思路大方向" class="headerlink" title="思路大方向"></a>思路大方向</h3><p>个人理解，DFS分为回溯角度(回溯法)和遍历角度<br>回溯角度：处理DFS每一层的信息（一层有多个节点）回溯角度的DFS其实就是回溯法<br>遍历角度：处理DFS每一个节点的信息</p>
<p>对于求所有的解，所有路径，所有分支，很明显应该是用回溯角度的DFS，也就是回溯法。大部分的DFS题目都是采用的回溯角度的DFS<br>对于遍历所有节点，搜索所有节点的一些信息，很明显应该用遍历角度的DFS，这个时候我们只是用DFS去遍历而已。常见于二叉树一些搜索问题</p>
<p>其中回溯角度的DFS写法很多变，因为回溯的写法可以很灵活。这里我们尽量把写法统一，便于速度和个人风格的培养。<br>本质就是确立DFS函数，从以下方面考虑</p>
<ol>
<li>DFS函数的意义         &#x2F;&#x2F;明确搜索顺序，DFS的当前层的含义，通俗来讲当前层搜的是什么</li>
<li>DFS函数的返回值   &#x2F;&#x2F;当前层需要返回的信息，大部分都不需要返回所以返回值常为void </li>
<li>DFS的参数        &#x2F;&#x2F;输入和全局变量(对于所有分支)，都当作引用传进DFS函数 其余的就是局部变量(对于当前分支)，自动回溯<br>然后判断还是否需要手动回溯，就是看当前层是不是我们想要的结果，如果不是就手动回溯一下</li>
</ol>
<h3 id="已打卡题目"><a href="#已打卡题目" class="headerlink" title="已打卡题目"></a>已打卡题目</h3><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/problem/content/2350/">LeetCode 17. 电话号码的字母组合</a></p>
<link rel="stylesheet" href="/blog/css/spoiler.css" type="text/css"><script src="/blog/js/spoiler.js" type="text/javascript" async></script>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://vendestine.github.io/blog/2022/04/20/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/acwing/bfs-dfs/" data-id="cll9axhcc000vxgud5lckhgb5" data-title="算法-搜索" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/%E6%90%9C%E7%B4%A2/" rel="tag">搜索</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/blog/2022/04/22/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/acwing/map/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          算法-图论
        
      </div>
    </a>
  
  
    <a href="/blog/2022/04/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/acwing/trie-heap/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">算法-数据结构：Trie树和堆</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E5%BA%95%E5%B1%82%E5%BC%80%E5%8F%91/">底层开发</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E5%BA%95%E5%B1%82%E5%BC%80%E5%8F%91/Linux%E4%B8%93%E6%A0%8F/">Linux专栏</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E5%BA%95%E5%B1%82%E5%BC%80%E5%8F%91/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E6%8A%80%E6%9C%AF%E7%BB%8F%E9%AA%8C/">技术经验</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/">算法笔记</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/AcWing/">AcWing</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/LeetCode/">LeetCode</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/">个人总结</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/">C++</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/">Python</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/">项目经历</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">个人博客</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/C-Primer/" rel="tag">C++ Primer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Django/" rel="tag">Django</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Flask/" rel="tag">Flask</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E4%BA%8C%E5%88%86/" rel="tag">二分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/" rel="tag">位运算</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/" rel="tag">前缀和与差分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/" rel="tag">区间合并</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" rel="tag">双指针</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E5%9B%BE%E8%AE%BA/" rel="tag">图论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E6%8E%92%E5%BA%8F/" rel="tag">排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E6%90%9C%E7%B4%A2/" rel="tag">搜索</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/" rel="tag">离散化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/" rel="tag">高精度</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/blog/tags/C/" style="font-size: 18px;">C++</a> <a href="/blog/tags/C-Primer/" style="font-size: 10px;">C++ Primer</a> <a href="/blog/tags/Django/" style="font-size: 10px;">Django</a> <a href="/blog/tags/Flask/" style="font-size: 10px;">Flask</a> <a href="/blog/tags/Linux/" style="font-size: 12px;">Linux</a> <a href="/blog/tags/Python/" style="font-size: 14px;">Python</a> <a href="/blog/tags/%E4%BA%8C%E5%88%86/" style="font-size: 10px;">二分</a> <a href="/blog/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 10px;">二叉树</a> <a href="/blog/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/" style="font-size: 10px;">位运算</a> <a href="/blog/tags/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/" style="font-size: 10px;">前缀和与差分</a> <a href="/blog/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">动态规划</a> <a href="/blog/tags/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/" style="font-size: 10px;">区间合并</a> <a href="/blog/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" style="font-size: 10px;">双指针</a> <a href="/blog/tags/%E5%9B%BE%E8%AE%BA/" style="font-size: 10px;">图论</a> <a href="/blog/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">排序</a> <a href="/blog/tags/%E6%90%9C%E7%B4%A2/" style="font-size: 10px;">搜索</a> <a href="/blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">操作系统</a> <a href="/blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 16px;">数据结构</a> <a href="/blog/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/" style="font-size: 10px;">离散化</a> <a href="/blog/tags/%E7%AE%97%E6%B3%95/" style="font-size: 20px;">算法</a> <a href="/blog/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 10px;">面试</a> <a href="/blog/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/" style="font-size: 10px;">高精度</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2023/07/">July 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2023/05/">May 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2023/02/">February 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2023/01/">January 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2022/11/">November 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2022/03/">March 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2023/07/04/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/blog_tutorial/">博客建站</a>
          </li>
        
          <li>
            <a href="/blog/2023/05/04/%E5%BA%95%E5%B1%82%E5%BC%80%E5%8F%91/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/os-learn-memory/">操作系统--内存管理</a>
          </li>
        
          <li>
            <a href="/blog/2023/04/07/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/c++-primer-p1/">C++ Primer Part1 - C++基础</a>
          </li>
        
          <li>
            <a href="/blog/2023/03/14/%E5%BA%95%E5%B1%82%E5%BC%80%E5%8F%91/linux%E4%B8%93%E6%A0%8F/web-server/">Linux-开发笔记</a>
          </li>
        
          <li>
            <a href="/blog/2023/02/24/%E6%8A%80%E6%9C%AF%E7%BB%8F%E9%AA%8C/remote-vscode-config/">配置远程开发环境</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 Wenzhe Li<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">Home</a>
  
    <a href="/blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/blog/js/jquery-3.6.4.min.js"></script>



  
<script src="/blog/fancybox/jquery.fancybox.min.js"></script>




<script src="/blog/js/script.js"></script>





  </div>
</body>
</html>