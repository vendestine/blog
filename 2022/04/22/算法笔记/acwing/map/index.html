<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>算法-图论 | Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="图论的常见算法">
<meta property="og:type" content="article">
<meta property="og:title" content="算法-图论">
<meta property="og:url" content="https://vendestine.github.io/blog/2022/04/22/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/acwing/map/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="图论的常见算法">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://vendestine.github.io/img/algorithm_map/summary.jpg">
<meta property="article:published_time" content="2022-04-22T14:32:54.000Z">
<meta property="article:modified_time" content="2023-08-13T09:07:29.228Z">
<meta property="article:author" content="Wenzhe Li">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="图论">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://vendestine.github.io/img/algorithm_map/summary.jpg">
  
    <link rel="alternate" href="/blog/atom.xml" title="Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/blog/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/blog/css/style.css">

  
    
<link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/blog/">Home</a>
        
          <a class="main-nav-link" href="/blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/blog/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://vendestine.github.io/blog"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-算法笔记/acwing/map" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/2022/04/22/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/acwing/map/" class="article-date">
  <time class="dt-published" datetime="2022-04-22T14:32:54.000Z" itemprop="datePublished">2022-04-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/">算法笔记</a>►<a class="article-category-link" href="/blog/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/AcWing/">AcWing</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      算法-图论
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="树和图"><a href="#树和图" class="headerlink" title="树和图"></a>树和图</h1><ol>
<li>树是一种特殊的图，无环连通图。</li>
<li>图的话分为两种，有向图（a-&gt;b)和无向图(a&lt;-&gt;b)，无向图是一种特殊的有向图,所以只需要考虑有向图就行。</li>
<li>有向图的存储分为两种，第一种是邻接矩阵（g[a][b]二维数组),空间复杂度比较高$O(n^2)$，有权重的话g[a][b]指的是权重,无权重的话就是bool值，表示有边或者无边。比较适合存储稠密图</li>
<li>另一种是邻接表（其实就是每个节点开个单链表）,存这个点可以走到哪个点，次序是无关的，插入节点是用头插法</li>
</ol>
<br>

<h2 id="树与图的深度优先遍历"><a href="#树与图的深度优先遍历" class="headerlink" title="树与图的深度优先遍历"></a>树与图的深度优先遍历</h2><p>首先我们要明确一个概念，那就是树是一种特殊的图，也就是无环连通图。<br>所以如果一个树有n个节点，那么对于任意两个节点之间有两条边，也就是2n - 2条边</p>
<p>然后对于树我们一般用邻接表来存，邻接表其实就是多个单链表。</p>
<p>关于节点，链表，邻接表，以及如何用邻接表表示树，这其中涉及到的概念很容易混淆，我们在这里进行详细的解读</p>
<p><img src="/blog/../img/algorithm_map/summary.jpg" alt="完全解读"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了方便快速转化，这里列出一些常见的操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 地址，指针，下标 （这三个词基本可以等价）</span></span><br><span class="line"><span class="comment">// 2. 地址（唯一）可以指代节点，所以指针or下标可以直接指代节点</span></span><br><span class="line"><span class="comment">// 3. 常见操作一一对应</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//动态</span></span><br><span class="line">ListNode* i： 指针i，指向一个节点，简称 i的节点（不固定，因为指针会移动）</span><br><span class="line">i-&gt;val: i的节点的val</span><br><span class="line">i-&gt;next: i的节点的next指针</span><br><span class="line">i = p: 指针i移动到指针p的位置</span><br><span class="line">i-&gt;next = p: i的节点指向p的节点</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态</span></span><br><span class="line"><span class="type">int</span> i: 节点下标i，指向一个节点，简称 i的节点（不固定，因为下标会变）</span><br><span class="line">e[i]: i的节点的val</span><br><span class="line">ne[i]: i的节点的next下标</span><br><span class="line">i = p: 下标i变成下标p</span><br><span class="line">ne[i] = p: i的节点指向p的节点</span><br></pre></td></tr></table></figure>

<p><strong>Reference</strong><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/117855/">[1]. 当前节点和邻接点的图示</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/104791/">[2]. 邻接表存储细节的详解</a></p>
<br>

<h3 id="846-树的重心"><a href="#846-树的重心" class="headerlink" title="846. 树的重心"></a><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/848/">846. 树的重心</a></h3><hr>
<h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><p>首先我们要知道怎么找到树的重心，就是搜索每一个点，求删除该节点后的连通块中点数的最大值（简称连通块最大值），对应连通块最大值最小的那个节点就是树的重心</p>
<p>搜索树里的每一个点，显然用DFS或者是BFS</p>
<p>然后我们需要求每个节点的连通块最大值，对于每个节点的连通块最大值，我们要求每个节点的所有邻接点的连通块的值。<br>邻接点的连通块分为两个部分，一个是上面（一个邻接点，一个连通块），一个是下面（若干邻接点，多个连通块）</p>
<p>所以我们找到了突破口，下面部分的邻接点的连通块值，实际就是邻接点为根节点的树的大小（很明显求很多个节点为根节点的树的xxx用DFS递归）</p>
<p>然后我们DFS函数定义就是节点u的连通块最大值，在函数里面，我们先求u下面的连通块最大值，也就是遍历u所有下方邻接点得到连通块的值（实质就是以邻接点为根节点的子树大小）<br>然后再求u上面的连通块的值（n - 1（u节点） - u节点所有子树大小(u节点的下方邻接点的连通块值)）</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; <span class="comment">//数据范围是10的5次方</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">2</span> * N; <span class="comment">//以有向图的格式存储无向图，所以每个节点至多对应2n-2条边</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N]; <span class="comment">//邻接表存储树，有n个节点，所以需要n个队列头节点</span></span><br><span class="line"><span class="type">int</span> e[M]; <span class="comment">//存储元素</span></span><br><span class="line"><span class="type">int</span> ne[M]; <span class="comment">//存储列表的next值</span></span><br><span class="line"><span class="type">int</span> idx; <span class="comment">//单链表指针</span></span><br><span class="line"><span class="type">int</span> n; <span class="comment">//题目所给的输入，n个节点</span></span><br><span class="line"><span class="type">int</span> ans = N; <span class="comment">//表示重心的所有的子树中，最大的子树的结点数目</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">//记录节点是否被访问过，访问过则标记为true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//a所对应的单链表中插入b  a作为根 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回以u为根的子树中节点的个数，包括u节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>; <span class="comment">//存储 删掉某个节点之后，最大的连通子图节点数</span></span><br><span class="line">    st[u] = <span class="literal">true</span>; <span class="comment">//标记访问过u节点</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">1</span>; <span class="comment">//存储 以u为根的树 的节点数, 包括u，如图中的4号节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//访问u的每个子节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i]) &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="comment">//因为每个节点的编号都是不一样的，所以 用编号为下标 来标记是否被访问过</span></span><br><span class="line">        <span class="keyword">if</span> (!st[j]) &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="built_in">dfs</span>(j);  <span class="comment">// u节点的单棵子树节点数 如图中的size值</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, s); <span class="comment">// 记录最大联通子图的节点数</span></span><br><span class="line">            sum += s; <span class="comment">//以j为根的树 的节点数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//n-sum 如图中的n-size值，不包括根节点4；</span></span><br><span class="line">    res = <span class="built_in">max</span>(res, n - sum); <span class="comment">// 选择u节点为重心，最大的 连通子图节点数</span></span><br><span class="line">    ans = <span class="built_in">min</span>(res, ans); <span class="comment">//遍历过的假设重心中，最小的最大联通子图的 节点数</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h); <span class="comment">//初始化h数组 -1表示尾节点</span></span><br><span class="line">    cin &gt;&gt; n; <span class="comment">//表示树的结点数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 题目接下来会输入，n-1行数据，</span></span><br><span class="line">    <span class="comment">// 树中是不存在环的，对于有n个节点的树，必定是n-1条边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a); <span class="comment">//无向图</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>); <span class="comment">//可以任意选定一个节点开始 u&lt;=n</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/47105/">[1]. yxc</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/13513/">[2]. 松鼠爱葡萄</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/104791/">[3]. 对邻接表存储细节的详解</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/41204/">[4]. Bug-Free</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/79072/">[5]. 最详细的题解–易懂</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/18704/">[6]. yx</a></p>
<br>

<h2 id="树与图的广度优先遍历"><a href="#树与图的广度优先遍历" class="headerlink" title="树与图的广度优先遍历"></a>树与图的广度优先遍历</h2><h3 id="847-图中点的层次"><a href="#847-图中点的层次" class="headerlink" title="847. 图中点的层次"></a><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/849/">847. 图中点的层次</a></h3><hr>
<h4 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h4><p>求最短距离，并且每条边的权重一样，所以可以用BFS</p>
<h4 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[N], idx, ne[N];   <span class="comment">//邻接表</span></span><br><span class="line"><span class="type">int</span> d[N]; <span class="comment">//存储每个节点离起点的距离  d[1]=0</span></span><br><span class="line"><span class="type">int</span> n, m; <span class="comment">//n个节点m条边</span></span><br><span class="line"><span class="type">int</span> q[N]; <span class="comment">//手动模拟队列 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部节点a, 邻接表的表头值b</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh=<span class="number">0</span>,tt=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    q[<span class="number">0</span>]=<span class="number">1</span>; <span class="comment">//队列初始化队头是1号节点</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line"></span><br><span class="line">    d[<span class="number">1</span>]=<span class="number">0</span>; <span class="comment">//存储每个节点离起点的距离</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//当我们的队列不为空时</span></span><br><span class="line">    <span class="keyword">while</span>(hh&lt;=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//取出队列头部节点</span></span><br><span class="line">        <span class="type">int</span> t=q[hh++];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历t节点的每一个邻接点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j=e[i];</span><br><span class="line">            <span class="comment">//如果j没有被搜索过</span></span><br><span class="line">            <span class="keyword">if</span>(d[j]==<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                d[j]=d[t]+<span class="number">1</span>; <span class="comment">//d[j]存储j节点离起点的距离，并标记为访问过</span></span><br><span class="line">                q[++tt] = j; <span class="comment">//把j结点 压入队列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="built_in">bfs</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Reference-1"><a href="#Reference-1" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/47104/">[1]. 847. 图中点的层次</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/13514/">[2]. 图中点的层次 详细注释</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/76019/">[3]. 真正本题需要实现的核心代码只有6句！</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/3126/">[4]. Bug-Free</a></p>
<br>

<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>首先我们需要明确一个概念叫拓扑序列：一张图的<strong>所有边</strong>的前后关系可以用一个<strong>线性序列</strong>来简化表示（其实就是省略了一些边的信息）<br>那么这个线性序列就叫做该图的一个拓扑序列，<strong>一张图可能存在多个拓扑序列</strong></p>
<p><strong>如果图里存在还，就无法表示成线性序列，所以有环就没有拓扑序列</strong></p>
<p>总结：</p>
<ol>
<li>无向图，有向有还图没有拓扑序列，而有向无环图必然存在拓扑序列</li>
<li>拓扑序列只有从前向后的边，没有从后向前的边</li>
</ol>
<h3 id="848-有向图的拓扑序列"><a href="#848-有向图的拓扑序列" class="headerlink" title="848. 有向图的拓扑序列"></a><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/850/">848. 有向图的拓扑序列</a></h3><hr>
<h4 id="基本思路-2"><a href="#基本思路-2" class="headerlink" title="基本思路"></a>基本思路</h4><p>拓扑序列只有从前向后的边，没有从后向前的边</p>
<p>根据这个性质。我们只要每次放入队列的都是入度为0的点，那就一定满足都是从前向后的边</p>
<p>队列维护</p>
<ol>
<li>将所有入度为0的点入队</li>
<li>删除这些点和他们的出边</li>
<li>循环上面的步骤</li>
<li>比较队列和图中点的数量</li>
</ol>
<p>和BFS过程十分类似</p>
<h4 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[N],idx;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> q[N],d[N];<span class="comment">//q表示队列,d表示点的入度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh=<span class="number">0</span>,tt=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">     <span class="keyword">if</span>(!d[i]) </span><br><span class="line">     q[++tt]=i;<span class="comment">//将入度为零的点入队</span></span><br><span class="line">    <span class="keyword">while</span>(hh&lt;=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t=q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j=e[i];</span><br><span class="line">            d[j]--;<span class="comment">//删除点t指向点j的边</span></span><br><span class="line">            <span class="keyword">if</span>(d[j]==<span class="number">0</span>)<span class="comment">//如果点j的入度为零了,就将点j入队</span></span><br><span class="line">            q[++tt]=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tt==n<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//表示如果n个点都入队了话,那么该图为拓扑图,返回true,否则返回false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="built_in">sizeof</span>(h));<span class="comment">//如果程序时间溢出，就是没有加上这一句</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a,b);<span class="comment">//因为是a指向b,所以b点的入度要加1</span></span><br><span class="line">        d[b]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">topsort</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,q[i]);</span><br><span class="line">        <span class="comment">//经上方循环可以发现队列中的点的次序就是拓扑序列</span></span><br><span class="line">        <span class="comment">//注:拓扑序列的答案并不唯一,可以从解析中找到解释</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Reference-2"><a href="#Reference-2" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/47106/">[1].  yxc</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/21908/">[2]. E.lena</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/103954/">[3]. 思路介绍+图解模拟+详细代码注释</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/41362/">[4].  Bug-Free</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/18766/">[5]. 注释</a></p>
<br>

<h1 id="最短路问题"><a href="#最短路问题" class="headerlink" title="最短路问题"></a>最短路问题</h1><p>最短路问题是图论里比较重要的篇章，下面简要的给单源最短路的相关算法的应用场景分一个类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">                                 |-------朴素dijkstra算法  O(n^2)</span><br><span class="line">                                 |   </span><br><span class="line">                                 |   </span><br><span class="line">         |------所有边权都是正数---   </span><br><span class="line">         |                       |</span><br><span class="line">         |                       |</span><br><span class="line">         |                       |-------堆优化的Dijkstra算法  O(mlogn)</span><br><span class="line">单源最短路</span><br><span class="line">         |                       |-------Bellman-ford  O(nm)</span><br><span class="line">         |                       |</span><br><span class="line">         |                       | </span><br><span class="line">         |-----存在负权边---------</span><br><span class="line">                                 |</span><br><span class="line">                                 |</span><br><span class="line">                                 |-------SPFA   一般O(m), 最坏O(nm)</span><br></pre></td></tr></table></figure>

<p>然后再介绍一下稠密图和稀疏图的概念：（n为点数，m为边数）<br>如果m和n是一个级别，那就是稀疏图，一般用邻接表来存<br>如果m和$n^2$是一个级别，那就是稠密图，一般用邻接矩阵来存</p>
<p>所以基本上SPFA可以解决 所有问题，但是有两个限制</p>
<ol>
<li>如果对边数做了限制，那就只能用Bellman-ford</li>
<li>如果正权边的题目卡SPFA，把它变成了最坏情况O(mn),那就用Dijkstra算法</li>
</ol>
<h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><h3 id="849-Dijkstra求最短路-I"><a href="#849-Dijkstra求最短路-I" class="headerlink" title="849. Dijkstra求最短路 I"></a><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/851/">849. Dijkstra求最短路 I</a></h3><hr>
<h4 id="基本思路-3"><a href="#基本思路-3" class="headerlink" title="基本思路"></a>基本思路</h4><p>图论的题目，首先都要看看数据范围，确定是稀疏图还是稠密图，然后选择合适的存储方式</p>
<p>这里m和n^2是一个级别，所以是稠密图，我们选择朴素的Dijkstra算法和邻接矩阵来存图</p>
<p>朴素的Digkstra算法基本流程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//dis[i] 是i号节点到源点的距离，st为True表示在 S集合：存储当前已经确定最短距离的点)</span><br><span class="line">1. 初始化dis[1] = 0, dis[i] = INF， st[1] = True</span><br><span class="line">2. for i: i ~ n:          //n    </span><br><span class="line">        t &lt;-不在s中的距离源点最近的点   // O(n)</span><br><span class="line">        s &lt;- t        // O(1)</span><br><span class="line">        用t更新其他点的距离    // O(n)</span><br></pre></td></tr></table></figure>
<p>时间复杂度：$O(n^2)$</p>
<h4 id="参考代码-3"><a href="#参考代码-3" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> dist[N],g[N][N];<span class="comment">//dist存储的是最短的距离,g存储的是邻接矩阵</span></span><br><span class="line"><span class="type">bool</span> st[N];<span class="comment">//表示该点是否已经确定了最短距离</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dist));<span class="comment">//初始化距离</span></span><br><span class="line"></span><br><span class="line">    dist[<span class="number">1</span>]=<span class="number">0</span>;<span class="comment">//起点到起点的距离为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)<span class="comment">//因为每次循环中都可以确定一个最短距离的点,因为总共有n个点,1这个点的距离已经确定了,所以循环n-1次</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t=<span class="number">-1</span>;<span class="comment">//t=-1的作用是可以找出第一个点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)<span class="comment">//第一轮循环,寻找与起点最短距离的点</span></span><br><span class="line">        <span class="keyword">if</span>(!st[j]&amp;&amp;(t==<span class="number">-1</span>||dist[t]&gt;dist[j]))</span><br><span class="line">        t=j;</span><br><span class="line"></span><br><span class="line">        st[t]=<span class="literal">true</span>;<span class="comment">//标记该点的最短距离已经确定了,然后用确定的点更新其他点的最短距离</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)<span class="comment">//第二轮循环,用已经确定了的最短距离的点来更新到其他点的最短距离</span></span><br><span class="line">        dist[j]=<span class="built_in">min</span>(dist[j],dist[t]+g[t][j]);</span><br><span class="line">        <span class="comment">//比较 起点到j的距离 和 起点到t的距离加上t到j的距离;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dist[n]==<span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//如果n到起点的距离为0x3f说明走不到n这个点</span></span><br><span class="line">    <span class="comment">//注:不能写成0x3f,只有清空操作时才能用0x3f,其他操作时需要写成0x3f3f3f3f,否则会报错</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> dist[n];<span class="comment">//返回起点到n的最短距离</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(g));<span class="comment">//将所有边的权值更新为一个非常大的数字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--)<span class="comment">//输入边与边之间的权值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        g[a][b]=<span class="built_in">min</span>(g[a][b],c);<span class="comment">//可能存在重边,而本题追求的是最短距离,所以选择重边中最短的那条边</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t=<span class="built_in">dijkstra</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Reference-3"><a href="#Reference-3" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/48488/">[1]. yxc</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/23358/">[2]. 超级详细的题解</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/21909/">[3]. E.lena</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/77603/">[4]. 两点小解释</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/5806/">[5]. 注意</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/13602/">[6]. 松鼠爱葡萄</a></p>
<br>

<h3 id="850-Dijkstra求最短路-II"><a href="#850-Dijkstra求最短路-II" class="headerlink" title="850. Dijkstra求最短路 II"></a><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/852/">850. Dijkstra求最短路 II</a></h3><hr>
<h4 id="基本思路-4"><a href="#基本思路-4" class="headerlink" title="基本思路"></a>基本思路</h4><p>还是先观察数据范围，这里m和n是一个级别，所以是稀疏图，我们选择堆优化的Dijkstra算法和邻接表来存图</p>
<p>堆优化的Digkstra算法基本流程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 初始化dis[1] = 0, dis[i] = INF， st[1] = True</span><br><span class="line">2. while(heap.size()):      </span><br><span class="line">        t &lt;-不在s中的距离源点最近的点(直接取小根堆的堆顶)  //总共n次，每次O(1), O(n)</span><br><span class="line">        s &lt;- t  // 总共n次，每次O(1), O(n)</span><br><span class="line">        用t更新其他点的距离（更新需要将更新后的值插入堆里）   //最多m次，每次O(logn)手写堆 或者O(logm) 优先队列, 这两者只有常数级变化，O(mlogn)</span><br></pre></td></tr></table></figure>
<p>时间复杂度：$O(mlogn)$</p>
<h4 id="参考代码-4"><a href="#参考代码-4" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;  <span class="comment">//w表示权重</span></span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//小根堆的定义方式,PII的第一个变量存储的是距离,第二个变量存储的是该点的编号,</span></span><br><span class="line">    <span class="comment">//内部按照第一个变量排序,即按距离排序</span></span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1、找到当前未在s中出现过且离源点最近的点</span></span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ver = t.second, distance = t.first;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、将该点进行标记</span></span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、用t更新其他点的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[ver]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[ver] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[ver] + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">dijkstra</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Reference-4"><a href="#Reference-4" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/48493/">[1]. yxc</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/6291/">[2]. 小呆呆</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/14007/">[3]. 松鼠爱葡萄</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/21910/">[4]. E.lena</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/46990/">[5]. 深入理解st数组的作用</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/7074/">[6]. 使用stl邻接表</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/5631/">[7]. 用手写堆实现</a></p>
<br>

<h2 id="Bellman-ford"><a href="#Bellman-ford" class="headerlink" title="Bellman-ford"></a>Bellman-ford</h2><h3 id="853-有边数限制的最短路"><a href="#853-有边数限制的最短路" class="headerlink" title="853. 有边数限制的最短路"></a><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/855/">853. 有边数限制的最短路</a></h3><hr>
<h4 id="基本思路-5"><a href="#基本思路-5" class="headerlink" title="基本思路"></a>基本思路</h4><p>有负权边，并且有边数限制，所以我们用Bellman-ford算法，基本流程如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for k次 ：</span><br><span class="line">    1. 备份</span><br><span class="line">    2. for 所有边 a, b, w   a--w--&gt;b    //遍历所有边 = 遍历所有点的出边(出边和邻接点是一一对应)</span><br><span class="line">        dist[b] = min(dist[b], dist[a] + w);   //松弛</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不管是有向图还是无向图，点的邻接点和点的出边是一一对应的！</p>
</blockquote>
<p>循环结束后，对于所有边都满足三角不等式，dist[b] &lt;&#x3D; dist[a] + w<br>所以每个点都找到了最短距离</p>
<p>注意事项</p>
<ol>
<li>备份是为了防止串联，串联后就有可能超出k的限制</li>
<li>最后答案可能为-1，所以不能用-1作为判断impossible的标识</li>
</ol>
<h4 id="参考代码-5"><a href="#参考代码-5" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = <span class="number">10010</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">int</span> backup[N];  <span class="comment">// 备份数组，防止串联</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edges</span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line"></span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(backup, dist, <span class="keyword">sizeof</span> dist);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m ; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = edges[j].a, b = edges[j].b, w = edges[j].w;</span><br><span class="line">            dist[b] = <span class="built_in">min</span>(dist[b], backup[a] + w);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] &gt; INF / <span class="number">2</span>) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, w;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;</span><br><span class="line">        edges[i] = &#123;a, b, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">bellman_ford</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t == INF) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Reference-5"><a href="#Reference-5" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/48523/">[1]. yxc</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/14088/">[2]. 松鼠爱葡萄</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/17551/">[3]. backup详解</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/12385/">[4]. 模拟</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/101394/">[5]. 问题汇总</a></p>
<br>

<h2 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h2><h3 id="851-spfa求最短路"><a href="#851-spfa求最短路" class="headerlink" title="851. spfa求最短路"></a><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/853/">851. spfa求最短路</a></h3><hr>
<h4 id="基本思路-6"><a href="#基本思路-6" class="headerlink" title="基本思路"></a>基本思路</h4><p>SPFA其实是队列优化后的Bellman-ford算法，优化了松弛的步骤<code>dist[b] = min(dist[b], dist[a]+w)</code><br>因为只有dist[a]更新之后变小, dist[b]更新之后才有可能变小<br>所以我们可以不用遍历所有点的出边，只需要遍历更新的点的出边即可</p>
<p>基本流程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">queue &lt;-- 1</span><br><span class="line">while queue非空</span><br><span class="line">    1. t &lt;-- q.front</span><br><span class="line">        q.pop</span><br><span class="line">    2. 更新t的所有出边 t--w--&gt;b</span><br><span class="line">        queue &lt;--b </span><br></pre></td></tr></table></figure>

<p>代码和堆优化的Dijkstra代码非常相似</p>
<h4 id="参考代码-6"><a href="#参考代码-6" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;  <span class="comment">// n个点m条边</span></span><br><span class="line"><span class="type">int</span> h[N], e[N], w[N], ne[N], idx;  <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N]; <span class="comment">// 存储1号点到每个点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];  <span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;  <span class="comment">// 初始化所有点的距离</span></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;  <span class="comment">// 定义队列存储所有待更新的点</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);  <span class="comment">// 1号点入队列</span></span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;  <span class="comment">// 标记该点，确定该点已放在队列里</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();  <span class="comment">//取出队头</span></span><br><span class="line">        st[t] = <span class="literal">false</span>;  <span class="comment">// 该点不在队列中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新所有出边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])  <span class="comment">// 扫描所有出边</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];  <span class="comment">// 找到出边，j存储编号</span></span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];  <span class="comment">//更新出边j的最短距离</span></span><br><span class="line">                <span class="keyword">if</span>(!st[j])  <span class="comment">// 如果队列中已存在j，则不需将j重复插入</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);  <span class="comment">// 若j不在队列中，把j加入队列里</span></span><br><span class="line">                    st[j] = <span class="literal">true</span>;  <span class="comment">//标记该点在队列中</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n] == INF) <span class="keyword">return</span> INF;  <span class="comment">// 1 ~ n不连通，返回-1</span></span><br><span class="line">    <span class="keyword">return</span> dist[n];  <span class="comment">// 返回第n个点到源点的最短距离</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">// 构建邻接表</span></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);  <span class="comment">// 初始化所有表头</span></span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">spfa</span>();</span><br><span class="line">    <span class="keyword">if</span>(t == INF) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Reference-6"><a href="#Reference-6" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/48498/">[1]. yxc</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/10245/">[2]. 队列优化的Bellman-Ford算法</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/19365/">[3]. 松鼠爱葡萄</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/42178/">[4]. Bug-Free</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/9306/">[5]. 分析</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/105508/">[6]. 图解+详细代码注释spfa求最短路−−−图解+详细代码注释 </a></p>
<br>

<h3 id="852-spfa判断负环"><a href="#852-spfa判断负环" class="headerlink" title="852. spfa判断负环"></a><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/854/">852. spfa判断负环</a></h3><h4 id="基本思路-7"><a href="#基本思路-7" class="headerlink" title="基本思路"></a>基本思路</h4><p>这里是利用spfa来判断负环，加上一个cnt数组表示点到源点的最短距离的边数<br>如果cnt &gt;&#x3D; n 说明有边数大于节点数，必然有环，而且一定是负环</p>
<p>注意</p>
<ol>
<li>dist数组不用初始化，因为如果有负环，最终这些点的距离肯定是负无穷，所以不需要初始化</li>
<li>因为要判断的是图里是否存在负环，可能负环路径没有出现在源点上，所以一开始把所有的点入队</li>
</ol>
<h4 id="参考代码-7"><a href="#参考代码-7" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2010</span>, M = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], w[M], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> dist[N], cnt[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cnt[j] &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">spfa</span>()) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Reference-7"><a href="#Reference-7" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/48499/">[1]. yxc</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/6336/">[2]. 小呆呆</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/42308/">[3].  Bug-Free</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/92094/">[4]. 判断负环详解</a></p>
<br>

<h2 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h2><h3 id="854-Floyd求最短路"><a href="#854-Floyd求最短路" class="headerlink" title="854. Floyd求最短路"></a><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/856/">854. Floyd求最短路</a></h3><h4 id="基本思路-8"><a href="#基本思路-8" class="headerlink" title="基本思路"></a>基本思路</h4><p>多源最短路问题，一般就是用Floyd算法，它是基于动态规划的思想</p>
<ol>
<li>状态表示：f[k][i][j] 表示经过前k个点从i到j的距离</li>
<li>状态计算：f[k][i][j] &#x3D; f[k - 1][i][j] + f[k - 1][k][j]   &#x2F;&#x2F;划分为不经过k和经过k两部分</li>
<li>省略k这个维度，因为它只和k - 1有关</li>
</ol>
<h4 id="参考代码-8"><a href="#参考代码-8" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>, M = <span class="number">2e+10</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, k, x, y, z;</span><br><span class="line"><span class="type">int</span> d[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span>(i == j) d[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> d[i][j] = INF;</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        d[x][y] = <span class="built_in">min</span>(d[x][y], z);</span><br><span class="line">        <span class="comment">//注意保存最小的边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">floyd</span>();</span><br><span class="line">    <span class="keyword">while</span>(k--) &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span>(d[x][y] &gt; INF/<span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">        <span class="comment">//由于有负权边存在所以约大过INF/2也很合理</span></span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; d[x][y] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Reference-8"><a href="#Reference-8" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/48531/">[1]. yxc</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/49316/">[2]. Floyd闫式dp分析法</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/42309/">[3]. Bug-Free</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/6976/">[4]. 文字性复习</a></p>
<br>

<h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p>关于生成树和最小生成树的定义<br>生成树：一个连通无向图的生成子图，同时要求是树。也即在n个点的图的边集中选择n - 1条，将所有顶点连通。<br>最小生成树（Minimum Spanning Tree，MST）为边权和最小的生成树</p>
<p>为了求解最小生成树，我们常用的有Prim算法和Kruskal算法</p>
<h2 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h2><p>朴素Prim算法基本流程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. dist[i] = INF, dist[1]=0  //S集合存储当前已经确定在最小生成树里的点</span><br><span class="line">2. for i in 0..n-1</span><br><span class="line">      t &lt;- 不在s中距离s最近的点</span><br><span class="line">      s &lt;- t</span><br><span class="line">      用t更新其他点到s的距离</span><br></pre></td></tr></table></figure>

<p>所以我们发现此算法跟Dijkstra算法非常相似<br>但是有一些区别：</p>
<ol>
<li>Dijkstra算法的t是距离源点最近的点，更新也是更新其他点到源点的距离</li>
<li>如果现在的距离为无穷大，那么说明没有最小生成树</li>
</ol>
<h3 id="858-Prim算法求最小生成树"><a href="#858-Prim算法求最小生成树" class="headerlink" title="858. Prim算法求最小生成树"></a><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/860/">858. Prim算法求最小生成树</a></h3><hr>
<h4 id="基本思路-9"><a href="#基本思路-9" class="headerlink" title="基本思路"></a>基本思路</h4><p>模板题，prim算法求解最小生成树,注意处理自环和重边</p>
<h4 id="参考代码-9"><a href="#参考代码-9" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;      <span class="comment">// n表示点数</span></span><br><span class="line"><span class="type">int</span> g[N][N];        <span class="comment">// 邻接矩阵，存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// 存储其他点到当前最小生成树的距离</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点是否已经在生成树中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist); <span class="comment">// dist初始化为正无穷</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    <span class="comment">/* dijkstra是n - 1，是因为找到剩一个点时候，它不需要在计算了。而这里的n，</span></span><br><span class="line"><span class="comment">    最后剩一个点的时候，答案还是要加入边的，所以最后一个点必须实实在在的计算</span></span><br><span class="line"><span class="comment">    一遍所以迭代n次*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; dist[t] == INF) <span class="keyword">return</span> INF; <span class="comment">// 如果是第一次，那么肯定是无穷，此时不应该返回无穷</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i) res += dist[t]; <span class="comment">// 不是第一次，就把这条边加进去。第一次是不存在边的，不应该计算</span></span><br><span class="line">        st[t] = <span class="literal">true</span>; <span class="comment">// 标记下该点已经到达</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ ) dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]); <span class="comment">// 更新其他点到集合的最短距离</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res; <span class="comment">// 返回最小生成树的边权重之和</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g); <span class="comment">// 图的初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        g[a][b] = g[b][a] = <span class="built_in">min</span>(g[a][b], c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">prim</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t == INF) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>); <span class="comment">// 不存在生成树就输出 impossible，反之输出答案</span></span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Reference-9"><a href="#Reference-9" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/48767/">[1]. yxc</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/77633/">[2]. 课上详解</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/71258/">[3]. 边界条件和细节</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/76880/">[4]. Prim算法思想动图</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/1825/">[5]. 简要注释</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/34197/">[6]. 切分原理</a></p>
<br>

<h2 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h2><h3 id="859-Kruskal算法求最小生成树"><a href="#859-Kruskal算法求最小生成树" class="headerlink" title="859. Kruskal算法求最小生成树"></a><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/861/">859. Kruskal算法求最小生成树</a></h3><hr>
<h4 id="基本思路-10"><a href="#基本思路-10" class="headerlink" title="基本思路"></a>基本思路</h4><p>Kruskal算法流程:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 将所有边按照权重从小到大排序 O(mlog(m))</span><br><span class="line">2. 枚举每条边(a, b， 权重c) O(m)</span><br><span class="line">      if a, b 两点不连通</span><br><span class="line">            将a, b边加入集合中</span><br></pre></td></tr></table></figure>

<h4 id="参考代码-10"><a href="#参考代码-10" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">200010</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;       <span class="comment">// n是点数，m是边数</span></span><br><span class="line"><span class="type">int</span> p[N];       <span class="comment">// 并查集的父节点数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>     <span class="comment">// 存储边</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge &amp;W)<span class="type">const</span> <span class="comment">// 运算符重载</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span>     <span class="comment">// 查询祖宗结点 + 路径压缩</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges, edges + m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;    <span class="comment">// 初始化并查集</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line"></span><br><span class="line">        a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (a != b)     <span class="comment">// 如果两个连通块不连通，则将这两个连通块合并</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b; <span class="comment">// 合并集合</span></span><br><span class="line">            res += w;</span><br><span class="line">            cnt ++ ; <span class="comment">// 记录边数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> INF; <span class="comment">// 边数小于 n - 1，不存在最小生成树</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ ) <span class="comment">// 读入数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">        edges[i] = &#123;a, b, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">kruskal</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t == INF) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Reference-10"><a href="#Reference-10" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/48773/">[1]. yxc</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/77635/">[2]. 课上笔记详解</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/76908/">[3]. Kruskal算法思想gif图解</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/62319/">[4]. 朴素Prim算法+Kruskal算法</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/42480/">[5]. Bug-Free</a></p>
<link rel="stylesheet" href="/blog/css/spoiler.css" type="text/css"><script src="/blog/js/spoiler.js" type="text/javascript" async></script>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://vendestine.github.io/blog/2022/04/22/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/acwing/map/" data-id="cll9axhc8000hxgudccgm6yj4" data-title="算法-图论" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/%E5%9B%BE%E8%AE%BA/" rel="tag">图论</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/blog/2022/05/05/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/acwing/bit-discrete/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          算法-位运算，离散化，区间合并
        
      </div>
    </a>
  
  
    <a href="/blog/2022/04/20/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/acwing/bfs-dfs/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">算法-搜索</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E5%BA%95%E5%B1%82%E5%BC%80%E5%8F%91/">底层开发</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E5%BA%95%E5%B1%82%E5%BC%80%E5%8F%91/Linux%E4%B8%93%E6%A0%8F/">Linux专栏</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E5%BA%95%E5%B1%82%E5%BC%80%E5%8F%91/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E6%8A%80%E6%9C%AF%E7%BB%8F%E9%AA%8C/">技术经验</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/">算法笔记</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/AcWing/">AcWing</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/LeetCode/">LeetCode</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/">个人总结</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/">C++</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/">Python</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/">项目经历</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">个人博客</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/C-Primer/" rel="tag">C++ Primer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Django/" rel="tag">Django</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Flask/" rel="tag">Flask</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E4%BA%8C%E5%88%86/" rel="tag">二分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/" rel="tag">位运算</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/" rel="tag">前缀和与差分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/" rel="tag">区间合并</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" rel="tag">双指针</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E5%9B%BE%E8%AE%BA/" rel="tag">图论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E6%8E%92%E5%BA%8F/" rel="tag">排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E6%90%9C%E7%B4%A2/" rel="tag">搜索</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/" rel="tag">离散化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/" rel="tag">高精度</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/blog/tags/C/" style="font-size: 18px;">C++</a> <a href="/blog/tags/C-Primer/" style="font-size: 10px;">C++ Primer</a> <a href="/blog/tags/Django/" style="font-size: 10px;">Django</a> <a href="/blog/tags/Flask/" style="font-size: 10px;">Flask</a> <a href="/blog/tags/Linux/" style="font-size: 12px;">Linux</a> <a href="/blog/tags/Python/" style="font-size: 14px;">Python</a> <a href="/blog/tags/%E4%BA%8C%E5%88%86/" style="font-size: 10px;">二分</a> <a href="/blog/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 10px;">二叉树</a> <a href="/blog/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/" style="font-size: 10px;">位运算</a> <a href="/blog/tags/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/" style="font-size: 10px;">前缀和与差分</a> <a href="/blog/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">动态规划</a> <a href="/blog/tags/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/" style="font-size: 10px;">区间合并</a> <a href="/blog/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" style="font-size: 10px;">双指针</a> <a href="/blog/tags/%E5%9B%BE%E8%AE%BA/" style="font-size: 10px;">图论</a> <a href="/blog/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">排序</a> <a href="/blog/tags/%E6%90%9C%E7%B4%A2/" style="font-size: 10px;">搜索</a> <a href="/blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">操作系统</a> <a href="/blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 16px;">数据结构</a> <a href="/blog/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/" style="font-size: 10px;">离散化</a> <a href="/blog/tags/%E7%AE%97%E6%B3%95/" style="font-size: 20px;">算法</a> <a href="/blog/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 10px;">面试</a> <a href="/blog/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/" style="font-size: 10px;">高精度</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2023/07/">July 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2023/05/">May 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2023/02/">February 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2023/01/">January 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2022/11/">November 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2022/03/">March 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2023/07/04/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/blog_tutorial/">博客建站</a>
          </li>
        
          <li>
            <a href="/blog/2023/05/04/%E5%BA%95%E5%B1%82%E5%BC%80%E5%8F%91/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/os-learn-memory/">操作系统--内存管理</a>
          </li>
        
          <li>
            <a href="/blog/2023/04/07/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/c++-primer-p1/">C++ Primer Part1 - C++基础</a>
          </li>
        
          <li>
            <a href="/blog/2023/03/14/%E5%BA%95%E5%B1%82%E5%BC%80%E5%8F%91/linux%E4%B8%93%E6%A0%8F/web-server/">Linux-开发笔记</a>
          </li>
        
          <li>
            <a href="/blog/2023/02/24/%E6%8A%80%E6%9C%AF%E7%BB%8F%E9%AA%8C/remote-vscode-config/">配置远程开发环境</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 Wenzhe Li<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">Home</a>
  
    <a href="/blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/blog/js/jquery-3.6.4.min.js"></script>



  
<script src="/blog/fancybox/jquery.fancybox.min.js"></script>




<script src="/blog/js/script.js"></script>





  </div>
</body>
</html>