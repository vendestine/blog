<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>LeetCode题目合集 | Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="LeetCode编号顺序排列，主要阐述思路，附AC代码">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode题目合集">
<meta property="og:url" content="https://vendestine.github.io/blog/2023/01/10/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/leetcode/leetcode-1-100/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="LeetCode编号顺序排列，主要阐述思路，附AC代码">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.acwing.com/media/article/image/2020/10/29/29289_4cd0c9ec19-image-20201029145857313.png">
<meta property="article:published_time" content="2023-01-10T23:28:01.000Z">
<meta property="article:modified_time" content="2023-08-13T09:10:24.150Z">
<meta property="article:author" content="Wenzhe Li">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.acwing.com/media/article/image/2020/10/29/29289_4cd0c9ec19-image-20201029145857313.png">
  
    <link rel="alternate" href="/blog/atom.xml" title="Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/blog/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/blog/css/style.css">

  
    
<link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/blog/">Home</a>
        
          <a class="main-nav-link" href="/blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/blog/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://vendestine.github.io/blog"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-算法笔记/leetcode/leetcode-1-100" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/2023/01/10/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/leetcode/leetcode-1-100/" class="article-date">
  <time class="dt-published" datetime="2023-01-10T23:28:01.000Z" itemprop="datePublished">2023-01-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/">算法笔记</a>►<a class="article-category-link" href="/blog/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/LeetCode/">LeetCode</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      LeetCode题目合集
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="LeetCode-1-100"><a href="#LeetCode-1-100" class="headerlink" title="LeetCode 1 - 100"></a>LeetCode 1 - 100</h2><h3 id="LeetCode-1-两数之和"><a href="#LeetCode-1-两数之和" class="headerlink" title="LeetCode 1. 两数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/">LeetCode 1. 两数之和</a></h3><hr>
<h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><p>首先想到暴力枚举两个数的朴素做法，然后尝试双指针优化，和哈希表优化</p>
<ol>
<li><p>暴力枚举两个数<br>枚举两个数$O(n^2)$，每组数检查合法$O(1)$<br>时间复杂度：$O(n^2)$</p>
</li>
<li><p>排序后得到单调性，双指针优化<br>注意这里要返回的是下标，排序后拿到的值的下标不是原下标，所以需要用空间存储原数组下标<br>(不能简单的用hash表存，因为类似于<code>[3,3] target = 6</code>，如果用hash表<code>key = nums[i], value = i</code>, 最后寻值下标会是相同的索引，C++建议用<code>vector&lt;pair&lt;int, int&gt;&gt;</code><br>时间复杂度：$O(nlogn)(排序) + O(n)(双指针) &#x3D; O(nlogn)$<br>空间复杂度：$O(n)$</p>
</li>
<li><p>枚举一个数，找合法的另一个数（哈希表）<br>查找某一个数是否存在，很明显用哈希表，这里很明显用了空间换时间的tradeoff<br>时间复杂度：$O(n) + O(1)(哈希表) &#x3D; O(n) $<br>空间复杂度：$O(n)$</p>
</li>
</ol>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++ )</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) <span class="keyword">return</span> &#123;j, i&#125;;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路2
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; p;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++) p.<span class="built_in">push_back</span>(&#123;nums[i], i&#125;);</span><br><span class="line">        <span class="built_in">sort</span>(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>, j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); j++ ) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; i &amp;&amp; p[i].first + p[j].first &gt; target) i -- ;</span><br><span class="line">            <span class="keyword">if</span> (p[i].first + p[j].first == target) <span class="keyword">return</span> &#123;p[j].second, p[i].second&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路3 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; heap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ ) &#123;</span><br><span class="line">            <span class="type">int</span> r = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (heap.<span class="built_in">count</span>(r)) <span class="keyword">return</span> &#123;heap[r], i&#125;;</span><br><span class="line">            heap[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/problem/content/2326/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-2-两数相加"><a href="#LeetCode-2-两数相加" class="headerlink" title="LeetCode 2. 两数相加"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/add-two-numbers/">LeetCode 2. 两数相加</a></h3><hr>
<h4 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h4><p><strong>模拟题</strong>，思路就是模拟大数相加 基本的列竖式流程</p>
<p>所以主要注意模拟竖式相加的关键点</p>
<ol>
<li>低位开始逐位相加，有进位或是数位还存在，继续相加</li>
<li>利用模表示数位，除10表示进位</li>
<li>链表返回一般就是返回head，如果边界为空不能返回head，所以需要特判头节点</li>
<li>需要特判头节点，可以加入dummy节点，简化边界，统一返回dummy-&gt;next</li>
</ol>
<p>时间复杂度：$O(n)$ （两个序列都只扫描一遍）<br><br></p>
<h4 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), cur = dummy;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 || l2 || t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1) t += l1-&gt;val, l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (l2) t += l2-&gt;val, l2 = l2-&gt;next;</span><br><span class="line">            cur = cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(t % <span class="number">10</span>);</span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-1"><a href="#Reference-1" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/problem/content/2327/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-3-无重复字符的最长子串"><a href="#LeetCode-3-无重复字符的最长子串" class="headerlink" title="LeetCode 3. 无重复字符的最长子串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">LeetCode 3. 无重复字符的最长子串</a></h3><hr>
<h4 id="基本思路-2"><a href="#基本思路-2" class="headerlink" title="基本思路"></a>基本思路</h4><p>朴素做法，枚举起点和终点，得到所有子串，所以很容易想到双指针优化</p>
<ol>
<li><p>暴力枚举<br>枚举子串的终点和起点$O(n^2)$, 得到所有的子串，然后每个子串判断合法(无重复)，拿到最大的无重复子串$O(n)$<br>时间复杂度：$O(n^3)$</p>
</li>
<li><p>双指针优化<br>发现了终点指针和起点指针的单调性，枚举新的终点指针（指针右移），为了满足合法的性质（最长不重复子串），起点指针不能左移，所以发现单调性，可以利用双指针优化。然后注意可以用哈希表维护指针内部的这段区间，判断是否无重复。<br>时间复杂度：$O(n)$<br>空间复杂度：$O(n)$</p>
</li>
</ol>
<h4 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1 - TLE
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// brute force </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">unique</span><span class="params">(string &amp;s, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; heap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (heap.<span class="built_in">count</span>(s[i])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            heap[s[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++ )</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">unique</span>(s, j, i)) res = <span class="built_in">max</span>(res, i - j + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路2 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//哈希表涉及到删除： 1. 用count（看key），必须配套用erase   2. 用heap[] &gt;= 1 （看value），必须用heap[]-- 不要混用！</span></span><br><span class="line"><span class="comment">//注意哈希表的操作需要统一，如果是针对key的那就统一用count，erase； 如果是针对value的那就不能用key的操作去判断</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ ) &#123;</span><br><span class="line">            hash[s[i]] ++ ;</span><br><span class="line">            <span class="keyword">while</span> (hash[s[i]] &gt; <span class="number">1</span>) hash[s[j ++ ]] -- ;</span><br><span class="line">            res = <span class="built_in">max</span>(res, i - j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-2"><a href="#Reference-2" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/problem/content/2328/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-5-最长回文子串"><a href="#LeetCode-5-最长回文子串" class="headerlink" title="LeetCode 5. 最长回文子串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-substring/">LeetCode 5. 最长回文子串</a></h3><hr>
<h4 id="基本思路-3"><a href="#基本思路-3" class="headerlink" title="基本思路"></a>基本思路</h4><p>朴素做法，枚举起点和终点得到所有子串，然后判断回文，这显然会超时<br>所以想办法优化，利用回文的性质，枚举子串的中点，然后中心扩展得到回文串</p>
<ol>
<li><p>暴力枚举<br>枚举子串的终点和起点$O(n^2)$, 得到所有的子串，然后每个子串判断合法(回文)，拿到最长回文子串$O(n)$<br>时间复杂度：$O(n^3)$</p>
</li>
<li><p>中心暴力枚举<br>因为暴力枚举，所以尝试用双指针优化，发现指针之间并无单调性，所以无法用常规的双指针算法，那么就观察回文串的一些性质，尝试用性质去解题，这里利用回文串中心对称的特点，先枚举回文串中心（分奇偶），然后两个指针从中心向外扩展判合法<br>时间复杂度：$O(n^2)$</p>
</li>
<li><p>动态规划<br>最优化问题，可以尝试用动态规划去做，目前不是很熟练（以后填坑）</p>
</li>
</ol>
<h4 id="参考代码-3"><a href="#参考代码-3" class="headerlink" title="参考代码"></a>参考代码</h4><hr>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1 - TLE
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">palindrome</span> <span class="params">(string &amp;s, <span class="type">int</span> j, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> l = j, r = i; l &lt;= r; l++, r-- ) <span class="keyword">if</span> (s[l] != s[r]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++ )</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">palindrome</span>(s, j, i) &amp;&amp; i - j + <span class="number">1</span>&gt; len) </span><br><span class="line">                    l = j, r = i, len = i - j + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(l, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路2 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ ) &#123;</span><br><span class="line">            <span class="type">int</span> l = i - <span class="number">1</span>, r = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; s.<span class="built_in">size</span>() &amp;&amp; s[l] == s[r]) l --, r ++ ;</span><br><span class="line">            <span class="keyword">if</span> (res.<span class="built_in">size</span>() &lt; r - l - <span class="number">1</span>) res = s.<span class="built_in">substr</span>(l + <span class="number">1</span>, r - l - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            l = i, r = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; s.<span class="built_in">size</span>() &amp;&amp; s[l] == s[r]) l --, r ++ ;</span><br><span class="line">            <span class="keyword">if</span> (res.<span class="built_in">size</span>() &lt; r - l - <span class="number">1</span>) res = s.<span class="built_in">substr</span>(l + <span class="number">1</span>, r - l - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-3"><a href="#Reference-3" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/problem/content/2330/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-6-Z-字形变换"><a href="#LeetCode-6-Z-字形变换" class="headerlink" title="LeetCode 6. Z 字形变换"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zigzag-conversion/">LeetCode 6. Z 字形变换</a></h3><hr>
<h4 id="基本思路-4"><a href="#基本思路-4" class="headerlink" title="基本思路"></a>基本思路</h4><p>将Z形顺序的字符串按行输出，变换运算这种类型的题目第一反应<strong>模拟</strong>，或者寻找<strong>数学规律</strong></p>
<ol>
<li><p>模拟<br>创立一个行数组，最后就是输出每一行的字符串，所以我们只需要遍历这个字符串，然后模拟上下的过程，把每个字符填入正确的行里即可。<br>然后注意行为1，需要特判<br>时间复杂度：$O(n)$<br>空间复杂度：$O(n)$</p>
</li>
<li><p>数学规律<br>如果模拟没有发现思路，那么可以尝试暴力地去发现一些数学规律，利用通项打印每行的字符（所以去发现是否有等差或者等比的关系）画一画图，发现</p>
<ul>
<li>对于第一行和最后一行，是公差为2(n−1)的等差数列，首项是0和n−1；</li>
<li>对于第i行(0&lt;i&lt;n−1)，是两个公差为2(n−1)的等差数列交替排列，首项分别是i和2n−i−2，2n−i−2;<br>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</li>
</ul>
</li>
</ol>
<h4 id="参考代码-4"><a href="#参考代码-4" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1 - k
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convert</span><span class="params">(string s, <span class="type">int</span> numRows)</span> </span>&#123;       </span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">if</span> (numRows == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">rows</span><span class="params">(numRows)</span></span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, flag = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">            rows[i].<span class="built_in">push_back</span>(c);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || i == numRows - <span class="number">1</span>) flag = -flag;</span><br><span class="line">            i += flag;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;row : rows) res += row;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路2 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convert</span><span class="params">(string s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || i == n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); j += <span class="number">2</span> * n - <span class="number">2</span>)</span><br><span class="line">                    res += s[j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i, k = <span class="number">2</span> * n - <span class="number">2</span> - i; j &lt; s.<span class="built_in">size</span>() || k &lt; s.<span class="built_in">size</span>(); j += <span class="number">2</span> * n - <span class="number">2</span>, k += <span class="number">2</span> * n - <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j &lt; s.<span class="built_in">size</span>()) res += s[j];</span><br><span class="line">                    <span class="keyword">if</span> (k &lt; s.<span class="built_in">size</span>()) res += s[k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        自己的不优雅代码
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convert</span><span class="params">(string s, <span class="type">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = numRows;</span><br><span class="line">        string rows[n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> r = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">                rows[r++] += s[i];</span><br><span class="line">                <span class="keyword">if</span> (r == n) &#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    r -= <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                rows[r--] += s[i];</span><br><span class="line">                <span class="keyword">if</span> (r == <span class="number">-1</span>) &#123;</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">                    r += <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line">            res += rows[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-4"><a href="#Reference-4" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/problem/content/2331/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-7-整数反转"><a href="#LeetCode-7-整数反转" class="headerlink" title="LeetCode 7. 整数反转"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-integer/">LeetCode 7. 整数反转</a></h3><hr>
<h4 id="基本思路-5"><a href="#基本思路-5" class="headerlink" title="基本思路"></a>基本思路</h4><p>整数反转，很容易联想到数学方式反转或者字符串方式反转</p>
<ol>
<li>数学方式反转<br>将原整数，从低位到高位逐位取出，然后在新整数里从高位到低位逐位插入。所以这里就是如何模拟取出和插入<ul>
<li>取出： <code>x % 10, x / 10</code> 取出最低位然后删除最低位，循环取出</li>
<li>插入：<code>x * 10</code>空出新的低位</li>
<li>注意整数逆序后可能溢出，所以要用<code>INT_MAX，INT_MIN</code>判断，并且改变原式子的形式</li>
<li>一定要先空出低位再放入，否则最后会多个0，此题虽然思维简单但是还是难AC</li>
</ul>
</li>
</ol>
<p>时间复杂度：数字n，数字大约有$\log_{10}n$位。复杂度为$O(logn)$<br>空间复杂度：$O(1)$</p>
<br>

<h4 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r &gt; <span class="number">0</span> &amp;&amp; r &gt; (INT_MAX - x % <span class="number">10</span>) / <span class="number">10</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (r &lt; <span class="number">0</span> &amp;&amp; r &lt; (INT_MIN - x % <span class="number">10</span>) / <span class="number">10</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            r = r * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-5"><a href="#Reference-5" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/problem/content/2332/">[1]. yxc</a></p>
<br>


<h3 id="LeetCode-8-字符串转换整数-atoi"><a href="#LeetCode-8-字符串转换整数-atoi" class="headerlink" title="LeetCode 8. 字符串转换整数 (atoi)"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/string-to-integer-atoi/">LeetCode 8. 字符串转换整数 (atoi)</a></h3><hr>
<h4 id="基本思路-6"><a href="#基本思路-6" class="headerlink" title="基本思路"></a>基本思路</h4><p>字符串转整数，就是逐位判断。<br>本提复杂在把所有的情况考虑全，并且按照正确的顺序</p>
<ol>
<li>去除空格</li>
<li>判断正负号或者无符号</li>
<li>去除前导0</li>
<li>只加入数字，数字以外的字符就停止</li>
<li>如果溢出需要截断</li>
<li>注意负数恰好是INT_MIN的时候，无法用绝对值加上符号表示，因为溢出了</li>
</ol>
<p>关于第6点，可以这么考虑，对于正数 &gt; 2147483647截断了，&lt;&#x3D; 2147483647 绝对值用int存没有溢出；对于负数，&lt; -2147483648截断了，&gt;&#x3D; -2147483648的数里面 INTMIN的绝对值用INT存会溢出，所以需要特判</p>
<h4 id="参考代码-5"><a href="#参考代码-5" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        long long
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">myAtoi</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] == <span class="string">&#x27; &#x27;</span>) i ++;</span><br><span class="line">        <span class="type">int</span> minus = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;-&#x27;</span>) i ++, minus = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;+&#x27;</span>) i ++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s[i] &lt; <span class="string">&#x27;0&#x27;</span> || s[i] &gt; <span class="string">&#x27;9&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] == <span class="string">&#x27;0&#x27;</span>) i ++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; res &lt; INT_MAX) res = res * <span class="number">10</span> + (s[i++] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        res *= minus;</span><br><span class="line">        <span class="keyword">if</span> (res &gt; INT_MAX) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (res &lt; INT_MIN) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> res; </span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        int
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">myAtoi</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] == <span class="string">&#x27; &#x27;</span>) i ++;</span><br><span class="line">        <span class="type">int</span> minus = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;-&#x27;</span>) i ++, minus = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;+&#x27;</span>) i ++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s[i] &lt; <span class="string">&#x27;0&#x27;</span> || s[i] &gt; <span class="string">&#x27;9&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] == <span class="string">&#x27;0&#x27;</span>) i ++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            <span class="type">int</span> x = s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (minus &gt; <span class="number">0</span> &amp;&amp; res &gt; (INT_MAX - x) / <span class="number">10</span>) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">            <span class="keyword">if</span> (minus &lt; <span class="number">0</span> &amp;&amp; -res &lt; (INT_MIN + x) / <span class="number">10</span>) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (-res * <span class="number">10</span> - x == INT_MIN) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">            </span><br><span class="line">            res = res * <span class="number">10</span> + x;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        res *= minus;</span><br><span class="line">        <span class="keyword">return</span> res; </span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-6"><a href="#Reference-6" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/339980/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-9-回文数"><a href="#LeetCode-9-回文数" class="headerlink" title="LeetCode 9. 回文数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-number/">LeetCode 9. 回文数</a></h3><hr>
<p>判断回文数，抓住回文数的性质，即反转前后相等<br>这里其实难点在于整数的反转，所以如果一时之间想不起来整数反转，可以转化为字符串反转</p>
<h4 id="基本思路-7"><a href="#基本思路-7" class="headerlink" title="基本思路"></a>基本思路</h4><ol>
<li><p>字符串反转<br>首先转化成字符串，然后直接通过函数反转,注意reverse函数的时间复杂度<br>时间复杂度：$O(logn)$ (数字n，数字位数logn，因为reverse函数)</p>
</li>
<li><p>数学方式反转<br>参考整数反转一题no.7，注意反转后的数可能溢出，用longlong表示<br>时间复杂度：$O(logn)$</p>
</li>
</ol>
<h4 id="参考代码-6"><a href="#参考代码-6" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        string s = <span class="built_in">to_string</span>(x);</span><br><span class="line">        <span class="keyword">return</span> s == <span class="built_in">string</span>(s.<span class="built_in">rbegin</span>(), s.<span class="built_in">rend</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路2 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> y = x;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            res = res * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-7"><a href="#Reference-7" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/problem/content/2334/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-11-盛最多水的容器"><a href="#LeetCode-11-盛最多水的容器" class="headerlink" title="LeetCode 11. 盛最多水的容器"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/container-with-most-water/">LeetCode 11. 盛最多水的容器</a></h3><hr>
<h4 id="基本思路-8"><a href="#基本思路-8" class="headerlink" title="基本思路"></a>基本思路</h4><p>首先想到朴素做法，枚举左右两个板，但是观察数据范围肯定会超时，所以想办法优化<br>常规双指针优化，指针之间没有单调性无法优化，但是根据短板性质，我们可以只有移动短板才有可能变大，所以枚举这些可能变大的组合，然后记录最大值</p>
<ol>
<li><p>暴力枚举<br>枚举左直线和右直线$O(n^2)$，每组直线计算面积$O(1)$<br>本质：枚举所有的组合，每次记录最大值<br>时间复杂度：$O(n^2)$</p>
</li>
<li><p>双指针+贪心<br>对于暴力枚举的题目，第一反应用双指针优化（裁剪搜索空间），尝试探索指针之间的单调性，发现两个指针没有单调性，所以不是常规的双指针解法（即顺序枚举一个指针，然后根据单调性不回退地移动另一个指针），但是这道题目因为<strong>性质</strong>（让两直线初始位于左右两侧，木桶容量由短板决定, 移动长板的话, 水面高度不可能再上升, 而宽度变小了, 所以只有通过移动短板, 才有可能使水位上升）所以利用贪心，非顺序性移动指针求解（本质也是裁剪搜索空间）<br>本质：利用贪心，枚举可能变大的组合，每次记录最大值<br>时间复杂度：$O(n)$</p>
</li>
</ol>
<h4 id="参考代码-7"><a href="#参考代码-7" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1 - TLE
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; height.<span class="built_in">size</span>(); i ++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; height.<span class="built_in">size</span>(); j ++)</span><br><span class="line">                res = <span class="built_in">max</span>(res, <span class="built_in">min</span>(height[i], height[j]) * (j - i));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路2
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = height.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt; j;) &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="built_in">min</span>(height[i], height[j]) * (j - i));</span><br><span class="line">            <span class="keyword">if</span> (height[i] &gt; height[j]) j -- ;</span><br><span class="line">            <span class="keyword">else</span> i ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-8"><a href="#Reference-8" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/problem/content/2344/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-12-整数转罗马数字"><a href="#LeetCode-12-整数转罗马数字" class="headerlink" title="LeetCode 12. 整数转罗马数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/integer-to-roman/">LeetCode 12. 整数转罗马数字</a></h3><hr>
<h4 id="基本思路-9"><a href="#基本思路-9" class="headerlink" title="基本思路"></a>基本思路</h4><p>将阿拉伯数字转化为罗马数字，类似于钞票问题，找到基本单位，然后由大到小</p>
<ol>
<li><p>暴力匹配<br>直接把每个数字在每个位上的表示形式，整理成一张硬编码表,然后暴力匹配每一位<br>技巧：数位是从1开始，下标是从0开始，所以将下标0空出来，就可以一致简化<br>时间复杂度：$O(1)$ 计算量与输入数字的大小无关。<br>空间复杂度：$O(1)$</p>
</li>
<li><p>贪心<br>罗马数字的设计初衷就是要<strong>字符尽可能的少</strong>（联想到找零钱问题：尽量选择面值大的纸币（硬币）给顾客，这样才会使得给顾客的纸币（硬币）张数最少），所以用这题可以用贪心，<strong>尽可能先选出大的数字进行转换。</strong><br>技巧：抓住基本单位，也就是1，4，5，9，10 …<br>时间复杂度：$O(1)$ 计算量与输入位数有关<br>空间复杂度：$O(1)$</p>
</li>
</ol>
<h4 id="参考代码-8"><a href="#参考代码-8" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        string I[] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="string">&quot;II&quot;</span>, <span class="string">&quot;III&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;VI&quot;</span>, <span class="string">&quot;VII&quot;</span>, <span class="string">&quot;VIII&quot;</span>, <span class="string">&quot;IX&quot;</span>&#125;;</span><br><span class="line">        string X[] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;XX&quot;</span>, <span class="string">&quot;XXX&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;LX&quot;</span>, <span class="string">&quot;LXX&quot;</span>, <span class="string">&quot;LXXX&quot;</span>, <span class="string">&quot;XC&quot;</span>&#125;;</span><br><span class="line">        string C[] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;CC&quot;</span>, <span class="string">&quot;CCC&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;DC&quot;</span>, <span class="string">&quot;DCC&quot;</span>, <span class="string">&quot;DCCC&quot;</span>, <span class="string">&quot;CM&quot;</span>&#125;;</span><br><span class="line">        string M[] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;MM&quot;</span>, <span class="string">&quot;MMM&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> M[num / <span class="number">1000</span>] + C[(num % <span class="number">1000</span>) / <span class="number">100</span>] + X[(num % <span class="number">100</span>) / <span class="number">10</span>] + I[num % <span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路2
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> values[] = &#123;</span><br><span class="line">            <span class="number">1000</span>,</span><br><span class="line">            <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>,</span><br><span class="line">            <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>,</span><br><span class="line">            <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span></span><br><span class="line">        &#125;;</span><br><span class="line">        string reps[] = &#123;</span><br><span class="line">            <span class="string">&quot;M&quot;</span>,</span><br><span class="line">            <span class="string">&quot;CM&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;C&quot;</span>,</span><br><span class="line">            <span class="string">&quot;XC&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;X&quot;</span>,</span><br><span class="line">            <span class="string">&quot;IX&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;I&quot;</span>,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">13</span>; i ++ ) &#123; <span class="comment">//贪心，从面值大的开始拼</span></span><br><span class="line">            <span class="keyword">while</span> (num &gt;= values[i]) &#123; <span class="comment">//注意是&gt;=!!!!!!</span></span><br><span class="line">                num -= values[i];</span><br><span class="line">                res += reps[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-9"><a href="#Reference-9" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/346728/">[1]. yxc</a></p>
<br>


<h3 id="LeetCode-13-罗马数字转整数"><a href="#LeetCode-13-罗马数字转整数" class="headerlink" title="LeetCode 13. 罗马数字转整数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/roman-to-integer/">LeetCode 13. 罗马数字转整数</a></h3><hr>
<h4 id="基本思路-10"><a href="#基本思路-10" class="headerlink" title="基本思路"></a>基本思路</h4><p>将罗马数字转化为阿拉伯数字，就是<strong>每个字符转换</strong><br>直接暴力匹配罗马数字的每一位，然后根据题目的提示信息按照固定规则进行转换</p>
<ul>
<li>通常情况：左边的字符 &gt; 右边字符 例如“XVI” &#x3D; 10（X）+5（V）+1（I）</li>
<li>特殊情况：左边的字符 &lt; 右边字符 根据规则需要减去小的数字(即将该数字的符号取反) XIV &#x3D; 10 (X) -1 (I)+5 (V) &#x3D; 14<br>所以直接遍历所有字符，判断当前字符与右边字符的关系，决定符号+ -</li>
</ul>
<h4 id="参考代码-9"><a href="#参考代码-9" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">romanToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        hash[<span class="string">&#x27;I&#x27;</span>] = <span class="number">1</span>, hash[<span class="string">&#x27;V&#x27;</span>] = <span class="number">5</span>;</span><br><span class="line">        hash[<span class="string">&#x27;X&#x27;</span>] = <span class="number">10</span>, hash[<span class="string">&#x27;L&#x27;</span>] = <span class="number">50</span>;</span><br><span class="line">        hash[<span class="string">&#x27;C&#x27;</span>] = <span class="number">100</span>, hash[<span class="string">&#x27;D&#x27;</span>] = <span class="number">500</span>;</span><br><span class="line">        hash[<span class="string">&#x27;M&#x27;</span>] = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &lt; s.<span class="built_in">size</span>() &amp;&amp; hash[s[i]] &lt; hash[s[i + <span class="number">1</span>]]) <span class="comment">//注意越界，虽然不加也可以AC但是养成好习惯</span></span><br><span class="line">                res -= hash[s[i]];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res += hash[s[i]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-10"><a href="#Reference-10" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/346746/">[1]. yxc</a></p>
<BR>

<h3 id="LeetCode-14-最长公共前缀"><a href="#LeetCode-14-最长公共前缀" class="headerlink" title="LeetCode 14. 最长公共前缀"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-prefix/">LeetCode 14. 最长公共前缀</a></h3><hr>
<h4 id="基本思路-11"><a href="#基本思路-11" class="headerlink" title="基本思路"></a>基本思路</h4><p>思路很简单，对每个字符串进行逐位检查，直到不满足公共前缀<br>两重循环，首先拿到第一个字符串的第i位，然后再拿到其余字符串的第i位<br>字符串的题目经常为空，注意越界, 然后string.size()是一个unsigned int，所以如果为0的时候减1就会溢出，所以必须用i &gt;&#x3D; s.size() 不能是 i &gt; s.size() - 1;</p>
<h4 id="参考代码-10"><a href="#参考代码-10" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        代码 -yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">if</span> (strs.<span class="built_in">empty</span>()) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;; i ++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= strs[<span class="number">0</span>].<span class="built_in">size</span>()) <span class="keyword">return</span> res;</span><br><span class="line">            <span class="type">char</span> c = strs[<span class="number">0</span>][i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; str: strs)</span><br><span class="line">                <span class="keyword">if</span> (str.<span class="built_in">size</span>() &lt;= i || str[i] != c)</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">            res += c;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-11"><a href="#Reference-11" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/346760/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-15-三数之和"><a href="#LeetCode-15-三数之和" class="headerlink" title="LeetCode 15. 三数之和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/3sum/">LeetCode 15. 三数之和</a></h3><hr>
<h4 id="基本思路-12"><a href="#基本思路-12" class="headerlink" title="基本思路"></a>基本思路</h4><p>首先暴力枚举$O(n^3)$肯定会超时，所以想办法优化，这里直接排序得到单调性，然后枚举一个指针，然后另外两个指针双指针优化<br>但是本题目的难点在于去重，去重的几个要点</p>
<ol>
<li>如果指针的指向值和上一轮指针指向的值一样跳过，达到去重的效果</li>
<li>指针i，j的去重比较简单，因为i，j每一轮只移动一格，所以上一轮的话直接比较i - 1 和 j - 1（注意和上一轮比较的前提是这两个指针存在移动，如果不存在移动，那么-1访问的并不是上一轮的i，j，就会错误答案</li>
<li>指针k，如果常规双指针做法，每轮会移动若干格，所以这里我们直接用k - 1试探法找到最左边的k，这样就可以达到去重k的效果，这一步也是最难的一点</li>
</ol>
<p>时间复杂度：$O(n^2)$</p>
<h4 id="参考代码-11"><a href="#参考代码-11" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        代码 -yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 枚举i，然后j和k双指针，保证i &lt; j &lt; k</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="comment">// 防止重复，如果和上一轮的一样就跳过</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>, k = nums.<span class="built_in">size</span>() - <span class="number">1</span>; j &lt; k; j ++) &#123;</span><br><span class="line">                <span class="comment">// 如果j和上一轮的一样也跳过</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 找到满足三个数相加大于等于0的最小的k</span></span><br><span class="line">                <span class="keyword">while</span> (j &lt; k - <span class="number">1</span> &amp;&amp; nums[i] + nums[j] + nums[k - <span class="number">1</span>] &gt;= <span class="number">0</span>) k --;</span><br><span class="line">                <span class="comment">// 如果相加是0就记录</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] == <span class="number">0</span>)</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;nums[i], nums[j], nums[k]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-12"><a href="#Reference-12" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/346791/">[1]. yxc k - 1 试探法</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/544218/">[2]. LauZyHou</a></p>
<br>

<h3 id="LeetCode-16-最接近的三数之和"><a href="#LeetCode-16-最接近的三数之和" class="headerlink" title="LeetCode 16. 最接近的三数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum-closest/">LeetCode 16. 最接近的三数之和</a></h3><hr>
<h4 id="基本思路-13"><a href="#基本思路-13" class="headerlink" title="基本思路"></a>基本思路</h4><p>和三数之和很像，但是这里是求和而不是求方案，所以不需要去重，然后因为是最接近target的，所以有两种情况，大于等于target和小于等于target<br>其中小等于的情况，在得到大于等于target的情况后，直接再减1就得到了<br>然后也是要特别注意越界问题 以及 while的判断里有两个条件，循环退出时有可能是第一个条件不满足。</p>
<h4 id="参考代码-12"><a href="#参考代码-12" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        yxc use Pair
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">res</span><span class="params">(INT_MAX, INT_MAX)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>, k = nums.<span class="built_in">size</span>() - <span class="number">1</span>; j &lt; k; j ++ ) &#123;</span><br><span class="line">                <span class="keyword">while</span> (k - <span class="number">1</span> &gt; j &amp;&amp; nums[i] + nums[j] + nums[k - <span class="number">1</span>] &gt;= target) k -- ;</span><br><span class="line">                <span class="type">int</span> s = nums[i] + nums[j] + nums[k];</span><br><span class="line">                res = <span class="built_in">min</span>(res, &#123;<span class="built_in">abs</span>(s - target), s&#125;);</span><br><span class="line">                <span class="keyword">if</span> (k - <span class="number">1</span> &gt; j) &#123;</span><br><span class="line">                    s = nums[i] + nums[j] + nums[k - <span class="number">1</span>];</span><br><span class="line">                    res = <span class="built_in">min</span>(res, &#123;target - s, s&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> res.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        no use Pair
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> diff = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ ) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>, k = nums.<span class="built_in">size</span>() - <span class="number">1</span>; j &lt; k; j ++) &#123;</span><br><span class="line">                <span class="keyword">while</span> (k - <span class="number">1</span> &gt; j &amp;&amp; nums[i] + nums[j] + nums[k - <span class="number">1</span>] &gt;= target) k--;</span><br><span class="line">                <span class="type">int</span> s = nums[i] + nums[j] + nums[k];</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">abs</span>(s - target) &lt; diff) res = s, diff = <span class="built_in">abs</span>(s - target);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (k - <span class="number">1</span> &gt; j) &#123;</span><br><span class="line">                    s = nums[i] + nums[j] + nums[k - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (target - s &lt; diff) res = s, diff = target - s; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-13"><a href="#Reference-13" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/346800/">[1]. yxc</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/64/">[2]. while</a></p>
<br>

<h3 id="LeetCode-17-电话号码的字母组合"><a href="#LeetCode-17-电话号码的字母组合" class="headerlink" title="LeetCode 17. 电话号码的字母组合"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">LeetCode 17. 电话号码的字母组合</a></h3><hr>
<h4 id="基本思路-14"><a href="#基本思路-14" class="headerlink" title="基本思路"></a>基本思路</h4><p>找到所有组合方案，相当于找到所有分支，所以回溯角度的DFS<br>然后题目中有个表的关系，我们可以建表，这里key是int，所以直接用vector存表<br>然后回溯角度的DFS就是思考每层需要存什么（DFS返回值，DFS参数），当前分支需要存什么（DFS参数），然后其实对于回溯角度的DFS就采用自己总结的那一套统一的写法</p>
<h4 id="参考代码-13"><a href="#参考代码-13" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        yxc - array
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    string strs[<span class="number">10</span>] = &#123;</span><br><span class="line">        <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>,</span><br><span class="line">        <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (digits.<span class="built_in">empty</span>()) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">dfs</span>(digits, <span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string&amp; digits, <span class="type">int</span> u, string path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == digits.<span class="built_in">size</span>()) ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> c : strs[digits[u] - <span class="string">&#x27;0&#x27;</span>])</span><br><span class="line">                <span class="built_in">dfs</span>(digits, u + <span class="number">1</span>, path + c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        unordered_map
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    vector&lt;string&gt; table = &#123;<span class="string">&quot;*&quot;</span>, <span class="string">&quot;*&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">    string path;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!digits.<span class="built_in">size</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(digits, <span class="number">0</span>, path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string&amp; digits, <span class="type">int</span> u, string path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == digits.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string a = table[digits[u] - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">        <span class="comment">// cout &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i ++ ) &#123;</span><br><span class="line">            <span class="comment">// path.push_back(a[i]);</span></span><br><span class="line">            <span class="built_in">dfs</span>(digits, u + <span class="number">1</span>, path + a[i]);</span><br><span class="line">            <span class="comment">// path.pop_back();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-14"><a href="#Reference-14" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/346821/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-18-四数之和"><a href="#LeetCode-18-四数之和" class="headerlink" title="LeetCode 18. 四数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum/">LeetCode 18. 四数之和</a></h3><hr>
<h4 id="基本思路-15"><a href="#基本思路-15" class="headerlink" title="基本思路"></a>基本思路</h4><p>与三数之和类似，注意几个点</p>
<ol>
<li>去重</li>
<li>四数相加可能会溢出</li>
</ol>
<h4 id="参考代码-14"><a href="#参考代码-14" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">0</span>; a &lt; nums.<span class="built_in">size</span>(); a ++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a &gt; <span class="number">0</span> &amp;&amp; nums[a] == nums[a - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> b = a + <span class="number">1</span>; b &lt; nums.<span class="built_in">size</span>(); b ++ ) &#123;</span><br><span class="line">                <span class="keyword">if</span> (b &gt; a + <span class="number">1</span> &amp;&amp; nums[b] == nums[b - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> c = b + <span class="number">1</span>, d = nums.<span class="built_in">size</span>() - <span class="number">1</span>; c &lt; d; c ++ ) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (c &gt; b + <span class="number">1</span> &amp;&amp; nums[c] == nums[c - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">while</span> (d - <span class="number">1</span> &gt; c &amp;&amp; nums[a] + nums[b] &gt;= (<span class="type">long</span> <span class="type">long</span>)target - nums[c] - nums[d - <span class="number">1</span>]) d--;</span><br><span class="line">                    <span class="keyword">if</span> (nums[a] + nums[b] == (<span class="type">long</span> <span class="type">long</span>)target - nums[c] - nums[d]) </span><br><span class="line">                        res.<span class="built_in">push_back</span>(&#123;nums[a], nums[b], nums[c], nums[d]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-15"><a href="#Reference-15" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/346837/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-19-删除链表的倒数第-N-个节点"><a href="#LeetCode-19-删除链表的倒数第-N-个节点" class="headerlink" title="LeetCode 19. 删除链表的倒数第 N 个节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">LeetCode 19. 删除链表的倒数第 N 个节点</a></h3><hr>
<h4 id="基本思路-16"><a href="#基本思路-16" class="headerlink" title="基本思路"></a>基本思路</h4><p>链表的题目，思路比较直接，要删除倒数第n个节点，首先得找到这个节点的前一个节点，然后就是常规删除操作<br>注意：</p>
<ol>
<li>这里涉及到头节点删除，所以最好建一个虚拟头节点，方便操作</li>
<li>然后就是如何求链表的长度，就是遍历一遍链表（非空 size++），如果是从dummy节点开始遍历的，多了一个虚拟头节点，所以-1以后才是链表的长度</li>
<li>跳的次数 其实 就是边的个数 所以 从dummy第 0 个节点 移动到 第size - n个节点（这就是倒数第n个节点的前一个节点），总共跳了size - n次</li>
</ol>
<h4 id="参考代码-15"><a href="#参考代码-15" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>); dummy-&gt;next = head;</span><br><span class="line">        <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p; p = p-&gt;next) size++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> p = dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size - n; i ++) p = p-&gt;next;</span><br><span class="line"></span><br><span class="line">        p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-16"><a href="#Reference-16" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/346852/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-20-有效的括号"><a href="#LeetCode-20-有效的括号" class="headerlink" title="LeetCode 20. 有效的括号"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses/">LeetCode 20. 有效的括号</a></h3><hr>
<h4 id="基本思路-17"><a href="#基本思路-17" class="headerlink" title="基本思路"></a>基本思路</h4><p>从题意我们可以知道，先出现的左括号配对的右括号在最后，所以很明显我们需要用一个栈来维护，栈里面只存左括号<br>如果是左括号就压栈，如果是右括号就判断是否和栈顶的左括号是否匹配，匹配那就弹出，不匹配说明已经非法了直接return false<br>最后如果栈为空return true 否则 return false</p>
<p>如何判断 右括号是否和栈顶的左括号匹配，这里有很多种方法，我的常规做法是开一个哈希表去匹配，同时也可以利用ASCII码简化代码</p>
<h4 id="参考代码-16"><a href="#参考代码-16" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; stk;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span>) stk.<span class="built_in">push</span>(c);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (stk.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">abs</span>(stk.<span class="built_in">top</span>() - c) &lt;= <span class="number">2</span>) stk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        first code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; stk;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; hash = &#123;&#123;<span class="string">&#x27;(&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;)&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;&#123;&#x27;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&#x27;&#125;&#x27;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&#x27;[&#x27;</span>, <span class="number">3</span>&#125;, &#123;<span class="string">&#x27;]&#x27;</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span> || s[i] == <span class="string">&#x27;[&#x27;</span> || s[i] == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (stk.<span class="built_in">size</span>() &amp;&amp; hash[stk.<span class="built_in">top</span>()] == hash[s[i]]) stk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stk.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-17"><a href="#Reference-17" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/346874/">[1]. yxc</a></p>
<br>


<h3 id="LeetCode-21-合并两个有序链表"><a href="#LeetCode-21-合并两个有序链表" class="headerlink" title="LeetCode 21. 合并两个有序链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-sorted-lists/">LeetCode 21. 合并两个有序链表</a></h3><hr>
<h4 id="基本思路-18"><a href="#基本思路-18" class="headerlink" title="基本思路"></a>基本思路</h4><p>基础算法，<strong>二路归并</strong>,三个指针，两个指针指向原序列起点，一个指针指向新序列起点<br>新的链表，旧的值，所以不需要new每个节点</p>
<p>时间复杂度：$O(n)$</p>
<br>

<h4 id="参考代码-17"><a href="#参考代码-17" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        没有开辟空间
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), tail = dummy;</span><br><span class="line">        <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) tail = tail-&gt;next = l1, l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> tail = tail-&gt;next = l2, l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l1) tail-&gt;next = l1;</span><br><span class="line">        <span class="keyword">if</span> (l2) tail-&gt;next = l2;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        开辟空间
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), tail = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (list1 &amp;&amp; list2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1-&gt;val &lt; list2-&gt;val) tail = tail-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(list1-&gt;val), list1 = list1-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> tail = tail-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(list2-&gt;val), list2 = list2-&gt;next;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (list1) tail = tail-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(list1-&gt;val), list1 = list1-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (list2) tail = tail-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(list2-&gt;val), list2 = list2-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-18"><a href="#Reference-18" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/347807/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-22-括号生成"><a href="#LeetCode-22-括号生成" class="headerlink" title="LeetCode 22. 括号生成"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/generate-parentheses/">LeetCode 22. 括号生成</a></h3><hr>
<h4 id="基本思路-19"><a href="#基本思路-19" class="headerlink" title="基本思路"></a>基本思路</h4><p>求所有方案，然后观察数据范围，很明显这道题目可以用DFS来做<br>然后对于括号问题，牢记<strong>两个性质</strong></p>
<ol>
<li>任意前缀中，左括号数量&gt;&#x3D;右括号数量</li>
<li>左右括号数量相等</li>
</ol>
<p>时间复杂度：复杂度为$O(C_{2n}^n)$,典型的卡特兰数问题。</p>
<br>

<h4 id="参考代码-18"><a href="#参考代码-18" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        代码 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(n, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> lc, <span class="type">int</span> rc, string seq)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lc == n &amp;&amp; rc == n) ans.<span class="built_in">push_back</span>(seq);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lc &lt; n) <span class="built_in">dfs</span>(n, lc + <span class="number">1</span>, rc, seq + <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (rc &lt; n &amp;&amp; lc &gt; rc) <span class="built_in">dfs</span>(n, lc, rc + <span class="number">1</span>, seq + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        first
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        string path;</span><br><span class="line">        <span class="built_in">dfs</span>(n, <span class="number">0</span>, path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> u, string path)</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">2</span>*n &amp;&amp; l == r) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l &lt; n) &#123;</span><br><span class="line">            l++;</span><br><span class="line">            <span class="built_in">dfs</span>(n, u + <span class="number">1</span>, path + <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            l--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (r &lt; n &amp;&amp; l &gt; r) &#123;</span><br><span class="line">            r ++;</span><br><span class="line">            <span class="built_in">dfs</span>(n, u + <span class="number">1</span>, path + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-19"><a href="#Reference-19" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/347825/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-23-合并K个排序链表"><a href="#LeetCode-23-合并K个排序链表" class="headerlink" title="LeetCode 23. 合并K个排序链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-k-sorted-lists/">LeetCode 23. 合并K个排序链表</a></h3><hr>
<h4 id="基本思路-20"><a href="#基本思路-20" class="headerlink" title="基本思路"></a>基本思路</h4><p>多路归并，可以基于二路归并的思想来做（因为每个序列有序不需要用分治）<br>关键在于<strong>每次从k个列表的头节点里拿出最小值这个操作</strong></p>
<ol>
<li><p>直接遍历当前的k个节点，拿到最小值,这步的时间复杂度$O(k)$<br>时间复杂度：$O(nk)$ n为链表总长度<br>空间复杂度：$O(1)$</p>
</li>
<li><p>把k个节点放入小根堆中，这样拿到最小值的操作就可以优化成$O(k)$<br>用到priority_queue，注意默认是大根堆，我们重写小括号改成小根堆。<br>时间复杂度: $O(nlogk)$ n为链表总长度<br>空间复杂度：$O(k)$</p>
</li>
</ol>
<h4 id="参考代码-19"><a href="#参考代码-19" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1
    </div>
    <div class='spoiler-content'>
        <p>&#x2F;&#x2F;以后实现~</p>

    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路2 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Cmp</span> &#123;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(ListNode* a, ListNode* b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, Cmp&gt; heap;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), tail = dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> l : lists) <span class="keyword">if</span> (l) heap.<span class="built_in">push</span>(l);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (heap.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">            heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            tail = tail-&gt;next = t;</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;next) heap.<span class="built_in">push</span>(t-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>


<br>


<h3 id="LeetCode-24-两两交换链表中的节点"><a href="#LeetCode-24-两两交换链表中的节点" class="headerlink" title="LeetCode 24. 两两交换链表中的节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/swap-nodes-in-pairs/">LeetCode 24. 两两交换链表中的节点</a></h3><hr>
<h4 id="基本思路-21"><a href="#基本思路-21" class="headerlink" title="基本思路"></a>基本思路</h4><p>链表的题目，关键就是画图和思考流程</p>
<ol>
<li>是否需要虚拟头节点</li>
<li>需要哪些节点，怎么拿到这些节点</li>
<li>具体逻辑，注意next指针更改顺序</li>
<li>边界情况分析</li>
</ol>
<p>对于本题</p>
<ol>
<li>头节点可能会变，所以需要一个dummy虚拟头节点</li>
<li>首先交换相邻的两个节点，所以需要这两个节点，然后发现交换操作还需要用到前面的节点，一点一段的操作，外部拿到最前面的，然后循环拿到段内的</li>
<li>画画图分析，然后注意顺序</li>
<li>边界分析，要交换的两个节点必须存在才能操作</li>
</ol>
<p><img src="https://cdn.acwing.com/media/article/image/2020/10/29/29289_4cd0c9ec19-image-20201029145857313.png" alt="示意图"></p>
<p>时间复杂度：$O(n)$，其中 n 是链表的节点数量。需要对每个节点进行更新指针的操作。<br>空间复杂度：$O(1)$<br><br></p>
<h4 id="参考代码-20"><a href="#参考代码-20" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        迭代
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = dummy; p-&gt;next &amp;&amp; p-&gt;next-&gt;next;) &#123;</span><br><span class="line">            <span class="keyword">auto</span> a = p-&gt;next, b = a-&gt;next;</span><br><span class="line">            p-&gt;next = b;</span><br><span class="line">            a-&gt;next = b-&gt;next;</span><br><span class="line">            b-&gt;next = a;</span><br><span class="line">            p = a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        允许修改节点值
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>); dummy-&gt;next = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = dummy; p-&gt;next &amp;&amp; p-&gt;next-&gt;next;) &#123;</span><br><span class="line">            <span class="keyword">auto</span> a = p-&gt;next;</span><br><span class="line">            <span class="keyword">auto</span> b = p-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">swap</span>(a-&gt;val, b-&gt;val);</span><br><span class="line"></span><br><span class="line">            p = p-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-20"><a href="#Reference-20" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/347847/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-25-K-个一组翻转链表"><a href="#LeetCode-25-K-个一组翻转链表" class="headerlink" title="LeetCode 25. K 个一组翻转链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">LeetCode 25. K 个一组翻转链表</a></h3><hr>
<h4 id="基本思路-22"><a href="#基本思路-22" class="headerlink" title="基本思路"></a>基本思路</h4><h4 id="参考代码-21"><a href="#参考代码-21" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        迭代实现
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = dummy; ;) &#123;</span><br><span class="line">            <span class="comment">// 测试后面够不够k个点</span></span><br><span class="line">            <span class="keyword">auto</span> q = p;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k &amp;&amp; q; i ++)</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (!q)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 至此，够k个，要两个两个一起翻转k-1次</span></span><br><span class="line">            <span class="keyword">auto</span> a = p-&gt;next, b = a-&gt;next;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i ++) &#123;</span><br><span class="line">                <span class="comment">// 记录一下b后面的c，不然就找不到了</span></span><br><span class="line">                <span class="keyword">auto</span> c = b-&gt;next;</span><br><span class="line">                b-&gt;next = a; <span class="comment">// 反向</span></span><br><span class="line">                a = b, b = c;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 翻转完的部分连好</span></span><br><span class="line">            <span class="keyword">auto</span> c = p-&gt;next;</span><br><span class="line">            c-&gt;next = b, p-&gt;next = a;</span><br><span class="line">            <span class="comment">// p往后走，做下一组</span></span><br><span class="line">            p = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>


<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        递归实现
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* head, ListNode* tail)</span>   <span class="comment">//反转链表模板，面试高频题</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode *pre = head, *cur = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (cur != tail)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* ne = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur, cur = ne;</span><br><span class="line">        &#125;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode* tail = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++ i)                <span class="comment">//遍历k个节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (tail == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;       <span class="comment">//不足k个节点则不反转，直接返回</span></span><br><span class="line">            <span class="comment">//注意，如果这里面试官要求最后不足k个也要翻转，就得改成下面一行</span></span><br><span class="line">            <span class="comment">//if (tail == nullptr) return reverse(head, tail);</span></span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* newhead = <span class="built_in">reverse</span>(head, tail);    <span class="comment">//反转长度为k的链表</span></span><br><span class="line">        head-&gt;next = <span class="built_in">reverseKGroup</span>(tail, k);        <span class="comment">//递归将下一段反转链表接到当前段的尾部</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-21"><a href="#Reference-21" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/546128/">[1].  LauZyHou</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/23649/">[2].  cyb-包子</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/52340/">[3. 递归写法]</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/62619/">[4].  有心人</a></p>
<br>

<h3 id="LeetCode-26-删除排序数组中的重复项"><a href="#LeetCode-26-删除排序数组中的重复项" class="headerlink" title="LeetCode 26. 删除排序数组中的重复项"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">LeetCode 26. 删除排序数组中的重复项</a></h3><hr>
<h4 id="基本思路-23"><a href="#基本思路-23" class="headerlink" title="基本思路"></a>基本思路</h4><p>常规的<strong>数组操作题</strong><br><strong>删除重复项 &#x3D; 找到所有首次出现的数</strong>，怎么找到所有首次出现的数，这里是排序数组，所以相同的元素一定连在一起，那么如果<strong>当前的数 ！&#x3D; 前面的数，那就是首次的数</strong><br>很显然可以用双指针算法，一个指针遍历数组，一个指针记录合法的数（首次出现的数）<br>代码虽然很简单，但是要注意思维怎么来的。</p>
<p>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$<br><br></p>
<h4 id="参考代码-22"><a href="#参考代码-22" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        代码 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            <span class="keyword">if</span> (!i || nums[i] != nums[i - <span class="number">1</span>]) <span class="comment">//注意第一个元素会导致越界，所以先特判一下</span></span><br><span class="line">                nums[k ++ ] = nums[i];</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<br>

<h3 id="LeetCode-27-移除元素"><a href="#LeetCode-27-移除元素" class="headerlink" title="LeetCode 27. 移除元素"></a><a href="">LeetCode 27. 移除元素</a></h3><hr>
<h4 id="基本思路-24"><a href="#基本思路-24" class="headerlink" title="基本思路"></a>基本思路</h4><p>常规的<strong>数组操作题</strong><br><strong>移除元素，也就是找出所有不等于val的数</strong><br>很显然可以用双指针算法，一个指针遍历数组，一个指针记录合法的数（不等于val的数）<br>leetcode26 如出一辙 属于经典爽题</p>
<h4 id="参考代码-23"><a href="#参考代码-23" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        代码 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != val)</span><br><span class="line">                nums[k ++ ] = nums[i];</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<BR>

<h3 id="LeetCode-31-下一个排列"><a href="#LeetCode-31-下一个排列" class="headerlink" title="LeetCode 31. 下一个排列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-permutation/">LeetCode 31. 下一个排列</a></h3><hr>
<h4 id="基本思路-25"><a href="#基本思路-25" class="headerlink" title="基本思路"></a>基本思路</h4><p><strong>数学规律题</strong> 个人认为这种题最折磨，思路很难搭上，要根据性质找到规律</p>
<p>如何找到下一个排列，首先观察下一个排列的<strong>性质</strong>：幅度最小的变大</p>
<p><strong>规律</strong>：就是<strong>不动高位，尽可能地在低位变大</strong>，然后将低位之后的数按照最小的顺序排列。按照这个思路我们数学模拟一下</p>
<ol>
<li><p>找到这个低位k<br>显然我们从低位往高位检查，<strong>不动高位的基础上，找到可以变大的第一个低位。所以第 k 位其实就是从低位到高位的第一个下降的数。</strong></p>
</li>
<li><p>低位k最小幅度变大<br>从 k 往后找，找到最小的比 k 要大的数，将两者交换。注意此时 k 以后的位置仍然是降序的</p>
</li>
<li><p>低位之后的数按照最小的顺序排列<br>直接将 k 以后的部分翻转（变为升序）</p>
</li>
</ol>
<h4 id="参考代码-24"><a href="#参考代码-24" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        代码
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k - <span class="number">1</span>] &gt;= nums[k]) k -- ;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> t = k;</span><br><span class="line">            <span class="keyword">while</span> (t &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[t] &gt; nums[k - <span class="number">1</span>]) t ++ ;</span><br><span class="line">            <span class="built_in">swap</span>(nums[t - <span class="number">1</span>], nums[k - <span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + k, nums.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<br>

<h3 id="LeetCode-41-缺失的第一个正数"><a href="#LeetCode-41-缺失的第一个正数" class="headerlink" title="LeetCode 41. 缺失的第一个正数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/first-missing-positive/">LeetCode 41. 缺失的第一个正数</a></h3><h4 id="基本思路-26"><a href="#基本思路-26" class="headerlink" title="基本思路"></a>基本思路</h4><p>求解缺失的第一个正数，<strong>枚举题</strong>，从1开始枚举，找到缺失的第一个正数</p>
<ol>
<li><p>暴力枚举 + 哈希表<br>寻找一个数很容易联想到哈希表，从1开始枚举正整数，然后找这个数是否存在（利用哈希表），不存在就找到了这个缺失的第一个正整数。<br>时间复杂度：$O(n)$<br>空间复杂度$O(n)$</p>
</li>
<li><p>桶排序</p>
</li>
</ol>
<br>

<h4 id="参考代码-25"><a href="#参考代码-25" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x: nums) hash.<span class="built_in">insert</span>(x);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; ; i ++ ) <span class="keyword">if</span> (!hash.<span class="built_in">count</span>(i)) <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<br>

<h3 id="LeetCode-53-最大子序和"><a href="#LeetCode-53-最大子序和" class="headerlink" title="LeetCode 53. 最大子序和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/">LeetCode 53. 最大子序和</a></h3><hr>
<h4 id="基本思路-27"><a href="#基本思路-27" class="headerlink" title="基本思路"></a>基本思路</h4><p>首先读题，我们知道就是要从所有的区间里，选出最大和的区间。暴力做法就是枚举区间的左右端点，结合数据范围大概率会超时。<br>所以要优化，这里从集合里选出最优解，很容易联想到动态规划来求解。</p>
<p>动态规划两步走</p>
<ol>
<li>状态表示：f[i]定义是所有以nums[i]结尾的区间中的最大和</li>
<li>状态计算：以区间长度为1区间只有nums[i]和区间长度&gt;&#x3D;2来划分，<br>得到状态转移方程 <code>f[i] max&#123;nums[i], nums[i] + f[i - 1]&#125;</code></li>
</ol>
<p>时间复杂度：$O(n)$</p>
<h4 id="参考代码-26"><a href="#参考代码-26" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1 - 动态规划
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, fi = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            fi = <span class="built_in">max</span>(nums[i], nums[i] + fi);</span><br><span class="line">            res = <span class="built_in">max</span>(res, fi);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1 - 分治
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">后续补坑</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-22"><a href="#Reference-22" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/550058/">[1].  LauZyHou</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/95749/">[2].  Cloudddddd</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/60882/">[3]. 有心人</a></p>
<h3 id="LeetCode-54-螺旋矩阵"><a href="#LeetCode-54-螺旋矩阵" class="headerlink" title="LeetCode 54. 螺旋矩阵"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix/">LeetCode 54. 螺旋矩阵</a></h3><hr>
<h4 id="基本思路-28"><a href="#基本思路-28" class="headerlink" title="基本思路"></a>基本思路</h4><ol>
<li><p>按照<strong>方向</strong>进行模拟，定义方向（也就是坐标偏移量），然后遍历这个矩阵，合法变向（每次碰到边界或已经访问过的数就改变方向）<br>时间复杂度：$O(mn)$<br>空间复杂度：$O(mn)$ 开了额外的数组记录是否被走过</p>
</li>
<li><p>按照<strong>层</strong>遍历，4个while遍历当前层，然后往里收，直到遍历完所有元素</p>
</li>
</ol>
<br>

<h4 id="参考代码-27"><a href="#参考代码-27" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!m) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">st</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, x = <span class="number">0</span>, y = <span class="number">0</span>, d = <span class="number">0</span>; i &lt; m * n; i ++ ) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(matrix[x][y]);</span><br><span class="line">            st[x][y] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> a = x + dx[d], b = y + dy[d];</span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= m || b &lt; <span class="number">0</span> || b &gt;= n || st[a][b]) &#123;</span><br><span class="line">                d = (d + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">                a = x + dx[d], b = y + dy[d];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            x = a, y = b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<br>

<h3 id="LeetCode-55-跳跃游戏"><a href="#LeetCode-55-跳跃游戏" class="headerlink" title="LeetCode 55. 跳跃游戏"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game/">LeetCode 55. 跳跃游戏</a></h3><hr>
<h4 id="基本思路-29"><a href="#基本思路-29" class="headerlink" title="基本思路"></a>基本思路</h4><p>贪心，尽可能到达最远位置<br>为什么用贪心，因为如果能到达某个位置，那一定能到达它前面的所有位置<br>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p>
<h4 id="参考代码-28"><a href="#参考代码-28" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        代码 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; i) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            j = <span class="built_in">max</span>(j, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<br>

<h3 id="LeetCode-56-合并区间"><a href="#LeetCode-56-合并区间" class="headerlink" title="LeetCode 56. 合并区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-intervals/">LeetCode 56. 合并区间</a></h3><hr>
<h4 id="基本思路-30"><a href="#基本思路-30" class="headerlink" title="基本思路"></a>基本思路</h4><p>模板题，直接上手</p>
<ol>
<li>按区间左端点排序</li>
<li>如果有交集，更新右端点；没交集就保存当前区间<br>时间复杂度：$O(nlogn)$ 排序 + 扫描<br>空间复杂度：$O(n)$  保存答案</li>
</ol>
<h4 id="参考代码-29"><a href="#参考代码-29" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        代码 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; a) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (a.<span class="built_in">empty</span>()) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> l = a[<span class="number">0</span>][<span class="number">0</span>], r = a[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; a.<span class="built_in">size</span>(); i ++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i][<span class="number">0</span>] &gt; r) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(&#123;l, r&#125;);</span><br><span class="line">                l = a[i][<span class="number">0</span>], r = a[i][<span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> r = <span class="built_in">max</span>(r, a[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res.<span class="built_in">push_back</span>(&#123;l, r&#125;);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<br>



<h3 id="LeetCode-57-插入区间"><a href="#LeetCode-57-插入区间" class="headerlink" title="LeetCode 57. 插入区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-interval/">LeetCode 57. 插入区间</a></h3><hr>
<h4 id="基本思路-31"><a href="#基本思路-31" class="headerlink" title="基本思路"></a>基本思路</h4><p>模拟即可</p>
<ol>
<li>结果中加上左边无交集部分</li>
<li>中间有交集部分，区间合并，加入结果</li>
<li>结果中加上右边无交集部分</li>
</ol>
<p>时间复杂度：$O(n)$ n是数组 intervals的长度，即给定的区间个数<br>空间复杂度：$O(1)$</p>
<br>

<h4 id="参考代码-30"><a href="#参考代码-30" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        代码 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">insert</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; a.<span class="built_in">size</span>() &amp;&amp; a[k][<span class="number">1</span>] &lt; b[<span class="number">0</span>]) res.<span class="built_in">push_back</span>(a[k ++ ]); <span class="comment">// 左边完全没交集的部分</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (k &lt; a.<span class="built_in">size</span>() &amp;&amp; a[k][<span class="number">0</span>] &lt;= b[<span class="number">1</span>]) &#123;</span><br><span class="line">            b[<span class="number">0</span>] = <span class="built_in">min</span>(b[<span class="number">0</span>], a[k][<span class="number">0</span>]);</span><br><span class="line">            b[<span class="number">1</span>] = <span class="built_in">max</span>(b[<span class="number">1</span>], a[k ++ ][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (k &lt; a.<span class="built_in">size</span>()) res.<span class="built_in">push_back</span>(a[k ++ ]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<br>

<h3 id="LeetCode-58-最后一个单词的长度"><a href="#LeetCode-58-最后一个单词的长度" class="headerlink" title="LeetCode 58. 最后一个单词的长度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/length-of-last-word/">LeetCode 58. 最后一个单词的长度</a></h3><hr>
<h4 id="基本思路-32"><a href="#基本思路-32" class="headerlink" title="基本思路"></a>基本思路</h4><p><strong>模拟</strong><br>两个指针，<strong>反向遍历</strong>，一个记录末尾单词的尾部，一个记录末尾单词的头部。<br>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$<br><br></p>
<h4 id="参考代码-31"><a href="#参考代码-31" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        代码 - sanye
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLastWord</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; s[i] == <span class="string">&#x27; &#x27;</span>) i--;</span><br><span class="line">        <span class="type">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[j] != <span class="string">&#x27; &#x27;</span>) j -- ;</span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<br>


<h3 id="LeetCode-59-螺旋矩阵-II"><a href="#LeetCode-59-螺旋矩阵-II" class="headerlink" title="LeetCode 59. 螺旋矩阵 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix-ii/">LeetCode 59. 螺旋矩阵 II</a></h3><hr>
<h4 id="基本思路-33"><a href="#基本思路-33" class="headerlink" title="基本思路"></a>基本思路</h4><p><strong>模拟</strong> 与螺旋矩阵思路完全一样，无非就是一个拿出来，一个放进去</p>
<ol>
<li><p>按方向模拟<br>时间复杂度：$O(n^2)$，其中 n是给定的正整数。矩阵的大小是 n×n，需要填入矩阵中的每个元素。<br>空间复杂度：$O(1)$ </p>
</li>
<li><p>按层模拟<br>时间复杂度：$O(n^2)$，其中 n是给定的正整数。矩阵的大小是 n×n，需要填入矩阵中的每个元素。<br>空间复杂度：$O(1)$ </p>
<br></li>
</ol>
<h4 id="参考代码-32"><a href="#参考代码-32" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, x = <span class="number">0</span>, y = <span class="number">0</span>, d = <span class="number">0</span>; i &lt;= n * n; i ++ ) &#123;</span><br><span class="line">            res[x][y] = i;</span><br><span class="line">            <span class="type">int</span> a = x + dx[d], b = y + dy[d];</span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= n || res[a][b]) &#123;</span><br><span class="line">                d = (d + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">                a = x + dx[d], b = y + dy[d];</span><br><span class="line">            &#125;</span><br><span class="line">            x = a, y = b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>



<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路2 - k
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, top = <span class="number">0</span>, right = n - <span class="number">1</span>, bottom = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">while</span> (num &lt;= n*n ) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//left to right</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt;= right; ++i) res[top][i] = num++;</span><br><span class="line">            ++top;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//top to bottom</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = top; i &lt;= bottom; ++i) res[i][right] = num++;</span><br><span class="line">            --right;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//right to left</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = right; i &gt;= left; --i) res[bottom][i] = num++;</span><br><span class="line">            --bottom;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//bottom to top</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = bottom; i &gt;= top; --i) res[i][left] = num++;</span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<br>

<h3 id="LeetCode-61-旋转链表"><a href="#LeetCode-61-旋转链表" class="headerlink" title="LeetCode 61. 旋转链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-list/">LeetCode 61. 旋转链表</a></h3><hr>
<h4 id="基本思路-34"><a href="#基本思路-34" class="headerlink" title="基本思路"></a>基本思路</h4><p>旋转k次的意思就是把后面k个节点移到前面，所以k &#x3D; n的时候其实就是原链表没有变化，所以先把k%n得到一个小于n的数，然后进行旋转操作。<br>所以先求出链表长度</p>
<p>然后就是常规思路</p>
<ol>
<li>头节点会变，所以需要一个dummy</li>
<li>需要哪些节点，需要原来的尾节点，新的头节点和尾节点，通过遍历，用指针拿到它们</li>
<li>然后具体逻辑，注意顺序 尾节点指向头节点 倒数第k个点更新为头节点 倒数第k个点变成尾节点（指向空）</li>
</ol>
<p>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p>
<h4 id="参考代码-33"><a href="#参考代码-33" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        代码 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        ListNode* tail;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p; p = p-&gt;next) &#123;</span><br><span class="line">            tail = p;</span><br><span class="line">            n ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        k %= n;</span><br><span class="line">        <span class="keyword">if</span> (!k) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> p = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - k - <span class="number">1</span>; i ++ ) p = p-&gt;next;</span><br><span class="line">        tail-&gt;next = head;</span><br><span class="line">        head = p-&gt;next;</span><br><span class="line">        p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<BR>


<h3 id="LeetCode-74-搜索二维矩阵"><a href="#LeetCode-74-搜索二维矩阵" class="headerlink" title="LeetCode 74. 搜索二维矩阵"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-a-2d-matrix/">LeetCode 74. 搜索二维矩阵</a></h3><hr>
<h4 id="基本思路-35"><a href="#基本思路-35" class="headerlink" title="基本思路"></a>基本思路</h4><p>有序数组寻找一个数，果断<strong>二分</strong><br>然后将二维数组转化成一维数组，注意下标变换<code>row = r / m, col = r % m</code><br>时间复杂度：$O(logmn)$，其中m和n分别是矩阵的行数和列数。<br>空间复杂度：$O(1)$。</p>
<br>

<h4 id="参考代码-34"><a href="#参考代码-34" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        代码 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>() || matrix[<span class="number">0</span>].<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>(), m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n * m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (matrix[mid / m][mid % m] &gt;= target) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> matrix[r / m][r % m] == target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<BR>

<h3 id="LeetCode-75-颜色分类"><a href="#LeetCode-75-颜色分类" class="headerlink" title="LeetCode 75. 颜色分类"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-colors/">LeetCode 75. 颜色分类</a></h3><hr>
<h4 id="基本思路-36"><a href="#基本思路-36" class="headerlink" title="基本思路"></a>基本思路</h4><p>因为这个题必须O(n)级别，所以普通快排肯定是不行的</p>
<ol>
<li><p>桶排序<br>扫描一遍记录012出现的次数，然后再扫描一遍按照顺序重写数组<br>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p>
</li>
<li><p>多路快排<br>可以只扫描一遍，但是很难想，荷兰国旗问题<br>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p>
</li>
</ol>
<h4 id="参考代码-35"><a href="#参考代码-35" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            ++count[nums[i]];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>;i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; count[i]; ++j)</span><br><span class="line">                nums[t++] = i;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路2 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt;= k;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) <span class="built_in">swap</span>(nums[i ++ ], nums[j ++ ]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == <span class="number">2</span>) <span class="built_in">swap</span>(nums[i], nums[k -- ]);</span><br><span class="line">            <span class="keyword">else</span> i ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<br>

<h3 id="LeetCode-77-组合"><a href="#LeetCode-77-组合" class="headerlink" title="LeetCode 77. 组合"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combinations/">LeetCode 77. 组合</a></h3><hr>
<h4 id="基本思路-37"><a href="#基本思路-37" class="headerlink" title="基本思路"></a>基本思路</h4><p><strong>搜索题</strong><br>枚举出所有情况，很明显爆搜DFS，然后注意去重<br>时间复杂度：$O((_n^k)×k)$ 组合枚举数$O((_n^k)×k)$，每次记录答案的复杂度为$O(k)$<br>空间复杂度：$O(n+k)&#x3D;O(n)$，即递归使用栈空间的空间代价和临时数组temp的空间代价</p>
<br>

<h4 id="参考代码-36"><a href="#参考代码-36" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        代码 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!k) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= n; i ++ ) &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="built_in">dfs</span>(n, k - <span class="number">1</span>, i + <span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<br>


<h3 id="LeetCode-78-子集"><a href="#LeetCode-78-子集" class="headerlink" title="LeetCode 78. 子集"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/">LeetCode 78. 子集</a></h3><hr>
<h4 id="基本思路-38"><a href="#基本思路-38" class="headerlink" title="基本思路"></a>基本思路</h4><ol>
<li><p>DFS<br>爆搜和上一题差不多</p>
</li>
<li><p>二进制<br>集合的子集有$2^n$种，所以利用二进制位数0或者1表示当前位的数字存不存在<br>时间复杂度：一共枚举$2^n$个数，每个数枚举n位，所以总时间复杂度是 $O(2^nn)$</p>
</li>
</ol>
<h4 id="参考代码-37"><a href="#参考代码-37" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路2
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i ++ ) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">                <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>)</span><br><span class="line">                    path.<span class="built_in">push_back</span>(nums[j]);</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<br>

<h3 id="LeetCode-79-单词搜索"><a href="#LeetCode-79-单词搜索" class="headerlink" title="LeetCode 79. 单词搜索"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-search/">LeetCode 79. 单词搜索</a></h3><hr>
<h4 id="基本思路-39"><a href="#基本思路-39" class="headerlink" title="基本思路"></a>基本思路</h4><p>搜索所有路径，显然爆搜DFS<br><br></p>
<h4 id="参考代码-38"><a href="#参考代码-38" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        代码
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); i ++ ) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; board[i].<span class="built_in">size</span>(); j ++ ) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">dfs</span>(board, word, <span class="number">0</span>, i, j)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string&amp; word, <span class="type">int</span> u, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board[x][y] != word[u]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (u == word.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> t = board[x][y];</span><br><span class="line">        board[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ ) &#123;</span><br><span class="line">            <span class="type">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= board.<span class="built_in">size</span>() || b &lt; <span class="number">0</span> || b &gt;= board[<span class="number">0</span>].<span class="built_in">size</span>() || board[a][b] == <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(board, word, u + <span class="number">1</span>, a, b)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[x][y] = t;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<br>


<h3 id="LeetCode-80-删除排序数组中的重复项-II"><a href="#LeetCode-80-删除排序数组中的重复项-II" class="headerlink" title="LeetCode 80. 删除排序数组中的重复项 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/">LeetCode 80. 删除排序数组中的重复项 II</a></h3><hr>
<h4 id="基本思路-40"><a href="#基本思路-40" class="headerlink" title="基本思路"></a>基本思路</h4><p>leetcode26删除排序数组中的重复项的变形<br><strong>双指针算法</strong><br>很显然可以用双指针算法，一个指针遍历数组，一个指针记录合法的数,<strong>关键在于怎么判断合法的数</strong><br>当前数x等于前两个数字，那么就跳过，所以当前数不等于前两个数字，就是合法的数<code>nums[k - 1] != x || nums[k - 2] != x</code>,其中因为数组有序，所以<code>nums[k - 2] != x</code>的话，<code>nums[k - 1]</code>肯定是不等于x的，所以可以舍去。<br>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$<br><br></p>
<h4 id="参考代码-39"><a href="#参考代码-39" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        代码 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x: nums)</span><br><span class="line">            <span class="keyword">if</span> (k &lt; <span class="number">2</span> || nums[k - <span class="number">2</span>] != x)</span><br><span class="line">                nums[k ++ ] = x;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<br>

<h3 id="LeetCode-82-删除排序链表中的重复元素-II"><a href="#LeetCode-82-删除排序链表中的重复元素-II" class="headerlink" title="LeetCode 82. 删除排序链表中的重复元素 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">LeetCode 82. 删除排序链表中的重复元素 II</a></h3><hr>
<h4 id="基本思路-41"><a href="#基本思路-41" class="headerlink" title="基本思路"></a>基本思路</h4><p>还是常规分析</p>
<ol>
<li>需要一个dummy节点，因为头节点可能被删除</li>
<li>需要拿到哪些节点，我们需要删除一段，所以需要这段的头节点和尾节点的最后一个节点，然后要删除他们，所以前一个节点也要知道。一点一段，外部拿到最前面的节点，循环内部拿到段内的节点</li>
<li>然后如果这两个节点之间只有一个数，代表不重复，否则就是重复的</li>
</ol>
<p>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p>
<br>

<h4 id="参考代码-40"><a href="#参考代码-40" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        代码 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-101</span>); dummy-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = dummy; p-&gt;next;) &#123;</span><br><span class="line">            <span class="keyword">auto</span> a = p-&gt;next;</span><br><span class="line">            <span class="keyword">auto</span> b = a-&gt;next;</span><br><span class="line">            <span class="keyword">while</span> (b &amp;&amp; b-&gt;val == a-&gt;val) b = b-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (a-&gt;next == b) p = a;</span><br><span class="line">            <span class="keyword">else</span> p-&gt;next = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-23"><a href="#Reference-23" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/375392/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-83-删除排序链表中的重复元素"><a href="#LeetCode-83-删除排序链表中的重复元素" class="headerlink" title="LeetCode 83. 删除排序链表中的重复元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">LeetCode 83. 删除排序链表中的重复元素</a></h3><hr>
<h4 id="基本思路-42"><a href="#基本思路-42" class="headerlink" title="基本思路"></a>基本思路</h4><p>思维跟数组一样，一个新的列表，然后存的是原列表里所有第一次出现的数<br>新的列表需要插入头节点，所以新建一个dummy节点方便操作<br>然后如何找到原列表里第一次出现的数呢，就是和新链表的tail比较，不同的话就是第一次出现，加到新链表里<br>然后注意最后新链表的tail后可能接上了原列表最后一段，所以需要tail后指向空</p>
<p>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p>
<br>

<h4 id="参考代码-41"><a href="#参考代码-41" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-101</span>), tail = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p; p = p-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;val != tail-&gt;val) tail = tail-&gt;next = p; </span><br><span class="line">        &#125;</span><br><span class="line">        tail-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-24"><a href="#Reference-24" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/375390/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-86-分隔链表"><a href="#LeetCode-86-分隔链表" class="headerlink" title="LeetCode 86. 分隔链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-list/">LeetCode 86. 分隔链表</a></h3><hr>
<h4 id="基本思路-43"><a href="#基本思路-43" class="headerlink" title="基本思路"></a>基本思路</h4><p>其实就是枚举出小于等于x的点，以及大于x的点，然后存入两个链表里，之后合并到一起<br>枚举出一些点，所以遍历的写法</p>
<h4 id="参考代码-42"><a href="#参考代码-42" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> lh = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), lt = lh;</span><br><span class="line">        <span class="keyword">auto</span> rh = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), rt = rh;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p; p = p-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;val &lt; x) lt = lt-&gt;next = p;</span><br><span class="line">            <span class="keyword">else</span> rt = rt-&gt;next = p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lt-&gt;next = rh-&gt;next;</span><br><span class="line">        rt-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lh-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-25"><a href="#Reference-25" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/375439/">[1]. yxc</a></p>
<br>


<h3 id="LeetCode-91-解码方法"><a href="#LeetCode-91-解码方法" class="headerlink" title="LeetCode 91. 解码方法"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/decode-ways/">LeetCode 91. 解码方法</a></h3><hr>
<h4 id="基本思路-44"><a href="#基本思路-44" class="headerlink" title="基本思路"></a>基本思路</h4><p>本题寻找总方案数 考虑用DFS或者是DP，这里的数据范围DFS会超时<br>所以选择DP的方法</p>
<p>DP问题两步走</p>
<ol>
<li><p>状态表示：f(i)表示<code>s[1,i]</code>解码的方案书（前i个数字解码的方案数）</p>
</li>
<li><p>状态计算：集合划分为两块，最后一个字符对应一位数字，或者最后一个字符对应两位数字<br>所以得到状态转移方程<code>f[i] = f[i-1] + f[i-2]</code></p>
</li>
</ol>
<p>时间复杂度：状态数是$n$个，状态转移的时间复杂度是$O(1)$，所以总时间复杂度是$O(n)$<br>空间复杂度：$O(n)$</p>
<br>

<h4 id="参考代码-43"><a href="#参考代码-43" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numDecodings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        s = <span class="string">&#x27; &#x27;</span> + s;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;1&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>) f[i] += f[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> t = (s[i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (t &gt;= <span class="number">10</span> &amp;&amp; t &lt;= <span class="number">26</span>) f[i] += f[i - <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<br>

<h4 id="Reference-26"><a href="#Reference-26" class="headerlink" title="Reference:"></a>Reference:</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/decode-ways/solution/gong-shui-san-xie-gen-ju-shu-ju-fan-wei-ug3dd/">[1]. 【宫水三叶】根据数据范围切换「递归」与「递推」</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/4396/">[2]. DP: Decode Ways</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/15235/">[3]. 解码方法</a></p>
<br>

<h3 id="LeetCode-92-反转链表-II"><a href="#LeetCode-92-反转链表-II" class="headerlink" title="LeetCode 92. 反转链表 II"></a><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/problem/content/2445/">LeetCode 92. 反转链表 II</a></h3><hr>
<h4 id="基本思路-45"><a href="#基本思路-45" class="headerlink" title="基本思路"></a>基本思路</h4><p>还是常规思路分析</p>
<ol>
<li>首先需要dummy头节点，因为头节点可能会变</li>
<li>反转这一段，所以需要拿到这一段的首尾节点，然后也要拿到这一段的前后节点</li>
<li>然后这一段的节点做反转链表的操作，之后改变其他的节点指向关系</li>
</ol>
<p>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p>
<h4 id="参考代码-44"><a href="#参考代码-44" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> a = dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++) a = a-&gt;next; <span class="comment">// 注意走 left-1 步</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> b = a-&gt;next, c = b-&gt;next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; right - left; i++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> d = c-&gt;next;</span><br><span class="line">            c-&gt;next = b;</span><br><span class="line">            b = c, c = d;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        a-&gt;next-&gt;next = c;</span><br><span class="line">        a-&gt;next = b;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-27"><a href="#Reference-27" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/54214/">[1]. 有心人</a></p>
<br>

<h3 id="LeetCode-93-复原IP地址"><a href="#LeetCode-93-复原IP地址" class="headerlink" title="LeetCode 93. 复原IP地址"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/restore-ip-addresses/">LeetCode 93. 复原IP地址</a></h3><hr>
<h4 id="基本思路-46"><a href="#基本思路-46" class="headerlink" title="基本思路"></a>基本思路</h4><p>题目要求得到所有方案，所以很明显先考虑DFS爆搜，数据范围很明确不会超时，所以DFS来做<br>DFS主要就是注意搜索的顺序，这里是一段IP一段IP的搜</p>
<p>时间复杂度：$O(3^{n-1}n)$ $O(n)$记录方案<br>空间复杂度：$O(n)$ 存答案</p>
<h4 id="参考代码-45"><a href="#参考代码-45" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(s, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string&amp; s, <span class="type">int</span> u, <span class="type">int</span> k, string path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">4</span>) &#123;</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">                ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = u, t = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; u &amp;&amp; s[u] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">break</span>;  <span class="comment">// 有前导0</span></span><br><span class="line">            t = t * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (t &lt;= <span class="number">255</span>) <span class="built_in">dfs</span>(s, i + <span class="number">1</span>, k + <span class="number">1</span>, path + <span class="built_in">to_string</span>(t) + <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-28"><a href="#Reference-28" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/554219/">[1]. LauZyHou </a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/98993/">[2]. Cloudddddd</a></p>
<br>

<h3 id="LeetCode-94-二叉树的中序遍历"><a href="#LeetCode-94-二叉树的中序遍历" class="headerlink" title="LeetCode 94. 二叉树的中序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">LeetCode 94. 二叉树的中序遍历</a></h3><hr>
<h4 id="基本思路-47"><a href="#基本思路-47" class="headerlink" title="基本思路"></a>基本思路</h4><p>二叉树的中序遍历，代码很简单，但是内部蕴含的思想需要深究，一下给出许多版本的代码，供思考</p>
<p>思路1：递归<br>构建递推式：f是中序遍历，f(二叉树) &#x3D; f(左子树)，遍历根节点，f(右子树)<br>所以可以用递归写法</p>
<p>思路2: 迭代 + 不加标记<br>以DFS角度出发，将DFS的系统栈用自己的辅助栈“模拟”一遍，这里是回溯到某个点的时候，如果已经遍历或者要遍历就pop出去，而不是实际DFS的出栈方式（只适用于二叉树问题）</p>
<p>思路3：迭代 + 标记<br>以DFS角度出发，也是用辅助栈自己模拟，但是这个出栈的顺序和DFS是一致的，是回溯到某个点的时候，如果分支都探索完了，就pop，和DFS实际的出栈方式一致（适用于所有DFS问题）</p>
<p>思路4：迭代 + 标记 + 空节点入栈<br>以DFS角度出发，这个就是完完全全把函数栈进出的过程模拟出来了（适用于所有DFS问题）</p>
<p>思路3，4在写代码的时候，都先处理标记，第四种比较容易写错！</p>
<h4 id="参考代码-46"><a href="#参考代码-46" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        递归
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;left);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        迭代 不加标记
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (root || stk.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root) &#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            root = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        迭代 + 标记 + 空节点不入栈
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;TreeNode*, <span class="type">int</span>&gt; vis;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (root || stk.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root) &#123;</span><br><span class="line">                vis[root] = <span class="number">1</span>;</span><br><span class="line">                stk.<span class="built_in">push</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            root = stk.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (vis[root] == <span class="number">1</span>) &#123;</span><br><span class="line">                vis[root] = <span class="number">2</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                root = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        迭代 + 标记 + 空节点入栈
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;pair&lt;TreeNode*, <span class="type">int</span>&gt;&gt;stk;</span><br><span class="line">        stk.<span class="built_in">push</span>(&#123;root, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (stk.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (stk.<span class="built_in">top</span>().first == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> t = stk.<span class="built_in">top</span>().second;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                stk.<span class="built_in">top</span>().second = <span class="number">1</span>;</span><br><span class="line">                stk.<span class="built_in">push</span>(&#123;stk.<span class="built_in">top</span>().first-&gt;left, <span class="number">0</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(stk.<span class="built_in">top</span>().first-&gt;val);</span><br><span class="line">                stk.<span class="built_in">top</span>().second = <span class="number">2</span>;</span><br><span class="line">                stk.<span class="built_in">push</span>(&#123;stk.<span class="built_in">top</span>().first-&gt;right, <span class="number">0</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> stk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<br>

<h4 id="Reference-29"><a href="#Reference-29" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/379732/">[1]. yxc</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/176/">[2]. 递归改迭代机械做法</a><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/shou-hua-tu-jie-yong-zhan-mo-ni-zhong-xu-bian-li-z/">[3]. 二叉树遍历本质</a></p>
<br>

<h3 id="LeetCode-95-不同的二叉搜索树-II"><a href="#LeetCode-95-不同的二叉搜索树-II" class="headerlink" title="LeetCode 95. 不同的二叉搜索树 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees-ii/">LeetCode 95. 不同的二叉搜索树 II</a></h3><hr>
<h4 id="基本思路-48"><a href="#基本思路-48" class="headerlink" title="基本思路"></a>基本思路</h4><p>构建二叉搜索树，一般都是通过它的中序遍历构建，也就是通过一段区间，就可以构建二叉搜索树<br>构建一棵二叉搜索树，有固定的递归写法</p>
<p>这里要得到所有的BST，显然DFS<br>二叉树的DFS返回值一般就是根据递推式分析，返回值可以理解成搜索当前层的xxx，xxx就是我们设置的返回值<br>然后注意关于二叉树问题的DFS，搜索顺序一般是按树搜索（当前树，下一步就是左子树，右子树），所以<strong>DFS的当前层这里就是当前树，而不是当前二叉树的某一层</strong><br>所以DFS 当前树，我们先要枚举所有的中点，然后对于每个中点，构建二叉树</p>
<h4 id="参考代码-47"><a href="#参考代码-47" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        DFS + 递归
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">1</span>, n); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">dfs</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> <span class="comment">//返回在区间[l, r]中所有合法方案</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;TreeNode*&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) </span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="literal">nullptr</span>); 结点为空，是一种子树的方案，需要加入方案集中</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i ++) <span class="comment">//枚举根节点位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> left = <span class="built_in">dfs</span>(l, i - <span class="number">1</span>); <span class="comment">//返回左子树所有合法方案</span></span><br><span class="line">            <span class="keyword">auto</span> right = <span class="built_in">dfs</span>(i + <span class="number">1</span>, r); <span class="comment">//返回右子树所有合法方案</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;lt : left) <span class="comment">//一个左子树</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;rt : right) <span class="comment">//一个右子树</span></span><br><span class="line">                &#123;</span><br><span class="line">                    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(i); <span class="comment">//创建根节点</span></span><br><span class="line">                    root -&gt; left = lt;</span><br><span class="line">                    root -&gt; right = rt;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(root); <span class="comment">//加入以该结点为根的合法方案</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-30"><a href="#Reference-30" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/379795/">[1]. yxc</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/14308/">[2]. 注释详细</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/35054/">[3]. 记忆化搜索</a></p>
<br>

<h3 id="LeetCode-96-不同的二叉搜索树"><a href="#LeetCode-96-不同的二叉搜索树" class="headerlink" title="LeetCode 96. 不同的二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees/">LeetCode 96. 不同的二叉搜索树</a></h3><hr>
<h4 id="基本思路-49"><a href="#基本思路-49" class="headerlink" title="基本思路"></a>基本思路</h4><p>和上题类似，这题我们不需要求所有解（路径），只需要求次数，递推公式 + 值落实到次数，所以很明显我们可以用DP</p>
<ol>
<li>top down dp 其实就是DFS加打表</li>
<li>自底向上dp，就是紧扣递推公式（状态转移方程），从底层向上状态转移</li>
</ol>
<h4 id="参考代码-48"><a href="#参考代码-48" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        top-down dp
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; f;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        f = vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(f[l][r]) <span class="keyword">return</span> f[l][r];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= r; i ++)&#123;</span><br><span class="line">            <span class="type">int</span> left = <span class="built_in">dfs</span>(l, i<span class="number">-1</span>);</span><br><span class="line">            <span class="type">int</span> right = <span class="built_in">dfs</span>(i+<span class="number">1</span>, r);</span><br><span class="line">            res+=left * right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[l][r] = res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        自底向上dp
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j ++ )</span><br><span class="line">                f[i] += f[j - <span class="number">1</span>] * f[i - j];</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<p>其实还可以直接卡特兰函数求解</p>
<h4 id="Reference-31"><a href="#Reference-31" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/379808/">[1]. yxc</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/98740/">[2]. 闫式dp分析</a></p>
<Br>

<h3 id="LeetCode-98-验证二叉搜索树"><a href="#LeetCode-98-验证二叉搜索树" class="headerlink" title="LeetCode 98. 验证二叉搜索树"></a><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/problem/content/2451/">LeetCode 98. 验证二叉搜索树</a></h3><hr>
<h4 id="基本思路-50"><a href="#基本思路-50" class="headerlink" title="基本思路"></a>基本思路</h4><p>思路1：递归<br>BST的问题，可以先试着从定义递推，左子树是BST + 右子树是BST + 根节点满足上下限关系 &#x3D; 该树是BST。所以递归函数返回值bool值，然后参数就是树 + 上下限<br>然后注意，我们说root节点的值从定义推都是严格大于和严格小于，所以上下限是开区间</p>
<p>思路2：中序遍历 递归<br>二叉搜索树 &lt;&#x3D;&#x3D;&gt; 中序遍历是升序<br>所以我们可以中序遍历的时候，检查每一个点是否严格大于前一个节点</p>
<p>思路3：中序遍历 迭代<br>其实就是上一个思路的迭代写法</p>
<h4 id="参考代码-49"><a href="#参考代码-49" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1：递归
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isvalid</span>(root, LONG_MIN, LONG_MAX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isvalid</span><span class="params">(TreeNode* root, <span class="type">long</span> <span class="type">long</span> down, <span class="type">long</span> <span class="type">long</span> up)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt;= down || root-&gt;val &gt;= up) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isvalid</span>(root-&gt;left, down, root-&gt;val) &amp;&amp; <span class="built_in">isvalid</span>(root-&gt;right, root-&gt;val, up);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路2：中序遍历 迭代
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> res = <span class="literal">true</span>;</span><br><span class="line">    TreeNode* pre;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (pre &amp;&amp; pre-&gt;val &gt;= root-&gt;val) &#123;</span><br><span class="line">            res = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pre = root;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路3：中序遍历 递归
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode *prev = <span class="literal">NULL</span>;</span><br><span class="line">        stack&lt;TreeNode *&gt; stk;</span><br><span class="line">        <span class="keyword">while</span> (root || stk.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root) &#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (prev &amp;&amp; prev-&gt;val &gt;= root-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            prev = root;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<br>

<h4 id="Reference-32"><a href="#Reference-32" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/15875/">[1]. adnil8130</a></p>
<br>

<h3 id="LeetCode-99-恢复二叉搜索树"><a href="#LeetCode-99-恢复二叉搜索树" class="headerlink" title="LeetCode 99. 恢复二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/recover-binary-search-tree/">LeetCode 99. 恢复二叉搜索树</a></h3><hr>
<h4 id="基本思路-51"><a href="#基本思路-51" class="headerlink" title="基本思路"></a>基本思路</h4><p>思路1：递归<br>二叉搜索树 &#x3D; 中序遍历有序<br>所以还是紧扣这个定义，中序遍历找到逆序对，注意位置相邻是一个逆序对，位置不相邻就是两个逆序对，但是我们就是记录第一个逆序对的第一个数，和最后一个逆序对的第二个数<br>然后swap就行</p>
<p>思路2：迭代<br>其实就是思路1的迭代写法</p>
<h4 id="参考代码-50"><a href="#参考代码-50" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* pre, *first, *second;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="built_in">swap</span>(first-&gt;val, second-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (pre &amp;&amp; pre-&gt;val &gt;= root-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!first) first = pre, second = root;</span><br><span class="line">            <span class="keyword">else</span> second = root;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>


<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路2
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* pre = <span class="literal">nullptr</span>, *first = <span class="literal">nullptr</span>, *second = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (root || stk.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root) &#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            root = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pre &amp;&amp; pre-&gt;val &gt;= root-&gt;val) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!first) first = pre, second = root;</span><br><span class="line">                <span class="keyword">else</span> second = root;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = root;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">swap</span>(first-&gt;val, second-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>


<h4 id="Reference-33"><a href="#Reference-33" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/35181/">[1]. 张小白</a></p>
<br>

<h3 id="LeetCode-100-相同的树"><a href="#LeetCode-100-相同的树" class="headerlink" title="LeetCode 100. 相同的树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/same-tree/">LeetCode 100. 相同的树</a></h3><hr>
<h4 id="基本思路-52"><a href="#基本思路-52" class="headerlink" title="基本思路"></a>基本思路</h4><p>思路1 递归<br>直接尝试递推式，两个树相等 &#x3D; 两个数左子树相等 + 两个数右子树相等 + root相等<br>参数直接就是树即可<br>然后注意递归边界</p>
<p>思路2 BFS<br>可以BFS搜索，如果每次遍历的点一样，那么就是相等的</p>
<h4 id="参考代码-51"><a href="#参考代码-51" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p &amp;&amp; !q) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!p || !q || p-&gt;val != q-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSameTree</span>(p-&gt;left, q-&gt;left) &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;right, q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路2
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode *&gt; Q; Q.<span class="built_in">push</span>(p); Q.<span class="built_in">push</span>(q);</span><br><span class="line">        <span class="keyword">while</span>(Q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            p = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">            q = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!p &amp;&amp; !q) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!p || !q || p-&gt;val != q-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            Q.<span class="built_in">push</span>(p-&gt;left);Q.<span class="built_in">push</span>(q-&gt;left);</span><br><span class="line">            Q.<span class="built_in">push</span>(p-&gt;right);Q.<span class="built_in">push</span>(q-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-34"><a href="#Reference-34" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/15871/">[1]. adnil8130</a></p>
<br>


<h2 id="LeetCode-101-200"><a href="#LeetCode-101-200" class="headerlink" title="LeetCode 101 - 200"></a>LeetCode 101 - 200</h2><h3 id="LeetCode-101-对称二叉树"><a href="#LeetCode-101-对称二叉树" class="headerlink" title="LeetCode 101. 对称二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">LeetCode 101. 对称二叉树</a></h3><hr>
<h4 id="基本思路-53"><a href="#基本思路-53" class="headerlink" title="基本思路"></a>基本思路</h4><p>思路1 递归<br>从定义入手找递推式 一个树是对称的 &#x3D; 左右子树互为镜像 &#x3D; 左子树和右子树的root相等 + 左子树的右边和右子树的左边互为镜像 + 左子树的左边和右子树的右边互为镜像<br>所以我们得到了递推式，然后注意递归边界</p>
<p>思路2 BFS<br>BFS当然也是可以做的，每层先后入队应该相等的点，然后比较</p>
<h4 id="参考代码-52"><a href="#参考代码-52" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">issym</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">issym</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p &amp;&amp; !q) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!p || !q || p-&gt;val != q-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">issym</span>(p-&gt;left, q-&gt;right) &amp;&amp; <span class="built_in">issym</span>(p-&gt;right, q-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>


<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路2
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(TreeNode *u, TreeNode *v)</span> </span>&#123;</span><br><span class="line">        queue &lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(u); q.<span class="built_in">push</span>(v);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            v = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (!u &amp;&amp; !v) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> ((!u || !v) || (u-&gt;val != v-&gt;val)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            q.<span class="built_in">push</span>(u-&gt;left); </span><br><span class="line">            q.<span class="built_in">push</span>(v-&gt;right);</span><br><span class="line"></span><br><span class="line">            q.<span class="built_in">push</span>(u-&gt;right); </span><br><span class="line">            q.<span class="built_in">push</span>(v-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">check</span>(root, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-35"><a href="#Reference-35" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/solution/dui-cheng-er-cha-shu-by-leetcode-solution/">[1]. Leetcode</a></p>
<h3 id="LeetCode-102-二叉树的层序遍历"><a href="#LeetCode-102-二叉树的层序遍历" class="headerlink" title="LeetCode 102. 二叉树的层序遍历 "></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">LeetCode 102. 二叉树的层序遍历 </a></h3><hr>
<h4 id="基本思路-54"><a href="#基本思路-54" class="headerlink" title="基本思路"></a>基本思路</h4><p>BFS模板，注意记录每层的节点</p>
<h4 id="参考代码-53"><a href="#参考代码-53" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        BFS
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="keyword">if</span> (root) q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; level;</span><br><span class="line">            <span class="type">int</span> len = q.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (len -- ) &#123;</span><br><span class="line">                <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                level.<span class="built_in">push_back</span>(t-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;left) q.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;right) q.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res.<span class="built_in">push_back</span>(level);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-36"><a href="#Reference-36" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/554636/">[1]. LauZyHou</a></p>
<br>


<h3 id="LeetCode-103-二叉树的锯齿形层次遍历"><a href="#LeetCode-103-二叉树的锯齿形层次遍历" class="headerlink" title="LeetCode 103. 二叉树的锯齿形层次遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">LeetCode 103. 二叉树的锯齿形层次遍历</a></h3><hr>
<h4 id="基本思路-55"><a href="#基本思路-55" class="headerlink" title="基本思路"></a>基本思路</h4><p>层序遍历模板 + 奇数行不需要反向，偶数行需要反向</p>
<h4 id="参考代码-54"><a href="#参考代码-54" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        BFS
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="keyword">if</span> (root) q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; level;</span><br><span class="line">            <span class="type">int</span> len = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span> (len -- ) &#123;</span><br><span class="line">                <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                level.<span class="built_in">push_back</span>(t-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;left) q.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;right) q.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ( ++ cnt % <span class="number">2</span> == <span class="number">0</span>) <span class="built_in">reverse</span>(level.<span class="built_in">begin</span>(), level.<span class="built_in">end</span>());</span><br><span class="line">            res.<span class="built_in">push_back</span>(level);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-37"><a href="#Reference-37" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/14337/">[1]. Coderoger</a></p>
<br>

<h3 id="LeetCode-104-二叉树的最大深度"><a href="#LeetCode-104-二叉树的最大深度" class="headerlink" title="LeetCode 104. 二叉树的最大深度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">LeetCode 104. 二叉树的最大深度</a></h3><hr>
<h4 id="基本思路-56"><a href="#基本思路-56" class="headerlink" title="基本思路"></a>基本思路</h4><p>思路1 递归<br>还是扣住定义找递推式，该树的最大深度 &#x3D; max（左子树的最大深度， 右子树的最大深度） + 1<br>注意递归边界</p>
<p>思路2 BFS<br>层序遍历，每遍历一层深度 + 1</p>
<h4 id="参考代码-55"><a href="#参考代码-55" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1： 递归
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left), <span class="built_in">maxDepth</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路2：BFS
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 解法三：BFS（队列实现）</span></span><br><span class="line">        <span class="type">int</span> max_depth = <span class="number">0</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root) q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 每次循环遍历一层</span></span><br><span class="line">            <span class="type">int</span> len = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">                TreeNode* e = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (e-&gt;left) q.<span class="built_in">push</span>(e-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (e-&gt;right) q.<span class="built_in">push</span>(e-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            max_depth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>


<h4 id="Reference-38"><a href="#Reference-38" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/134682/">[1]. Zzay</a></p>
<br>


<h3 id="LeetCode-105-从前序与中序遍历序列构造二叉树"><a href="#LeetCode-105-从前序与中序遍历序列构造二叉树" class="headerlink" title="LeetCode 105. 从前序与中序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">LeetCode 105. 从前序与中序遍历序列构造二叉树</a></h3><hr>
<h4 id="基本思路-57"><a href="#基本思路-57" class="headerlink" title="基本思路"></a>基本思路</h4><p>还是递归构造二叉树的思路，需要知道根节点，左子树和右子树的信息</p>
<p>所以难点就在于，如何在前序遍历和中序遍历的数组里，找到根节点，左子树和右子树的范围。对于前序遍历，我们可以很轻松找到根节点，就是左端点，但是找到根节点后，我们不好求出左右子树范围<br>但是对于中序遍历，如果找到根节点，我们可以很轻松找到左右子树范围</p>
<p>所以思路就是通过前序遍历找到根节点，然后再利用hash表找到中序遍历里的根节点，最后就可以得到左右子树范围了，然后就可以递归构建二叉树了</p>
<h4 id="参考代码-56"><a href="#参考代码-56" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        递归
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash; </span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; inorder.<span class="built_in">size</span>(); i ++ ) hash[inorder[i]] = i;</span><br><span class="line">        <span class="type">int</span> pl = <span class="number">0</span>, pr = preorder.<span class="built_in">size</span>() - <span class="number">1</span>, il = <span class="number">0</span>, ir = inorder.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">build</span>(preorder, inorder, pl, pr, il, ir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder, <span class="type">int</span> pl, <span class="type">int</span> pr, <span class="type">int</span> il, <span class="type">int</span> ir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pl &gt; pr) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[pl]);</span><br><span class="line">        <span class="keyword">auto</span> k = hash[root-&gt;val];</span><br><span class="line">        root-&gt;left = <span class="built_in">build</span>(preorder, inorder, pl + <span class="number">1</span>, pl + <span class="number">1</span> + k - <span class="number">1</span> - il, il, k - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">build</span>(preorder, inorder, pl + k - il + <span class="number">1</span>, pr, k + <span class="number">1</span>, ir);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-39"><a href="#Reference-39" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/384035/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-106-从中序与后序遍历序列构造二叉树"><a href="#LeetCode-106-从中序与后序遍历序列构造二叉树" class="headerlink" title="LeetCode 106. 从中序与后序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">LeetCode 106. 从中序与后序遍历序列构造二叉树</a></h3><hr>
<h4 id="基本思路-58"><a href="#基本思路-58" class="headerlink" title="基本思路"></a>基本思路</h4><p>和上一题思路差不多，只是现在我们从后序遍历中找到根节点，然后通过哈希表在中序遍历里找到根节点的位置，然后就可以得到左右子树的范围了</p>
<h4 id="参考代码-57"><a href="#参考代码-57" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        递归
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; inorder.<span class="built_in">size</span>(); i ++ ) hash[inorder[i]] = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">build</span>(inorder, postorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="number">0</span>, postorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder, <span class="type">int</span> il, <span class="type">int</span> ir, <span class="type">int</span> pl, <span class="type">int</span> pr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (il &gt; ir) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(postorder[pr]);</span><br><span class="line">        <span class="type">int</span> k = hash[root-&gt;val];</span><br><span class="line">        root-&gt;left = <span class="built_in">build</span>(inorder, postorder, il, k - <span class="number">1</span>, pl, pl + k - <span class="number">1</span> - il);</span><br><span class="line">        root-&gt;right = <span class="built_in">build</span>(inorder, postorder, k + <span class="number">1</span>, ir, pl + k - il, pr - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-40"><a href="#Reference-40" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/384041/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-107-二叉树的层次遍历-II"><a href="#LeetCode-107-二叉树的层次遍历-II" class="headerlink" title="LeetCode 107. 二叉树的层次遍历 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">LeetCode 107. 二叉树的层次遍历 II</a></h3><hr>
<h4 id="基本思路-59"><a href="#基本思路-59" class="headerlink" title="基本思路"></a>基本思路</h4><p>基本的层序遍历，然后最后把结果reverse一下就行</p>
<h4 id="参考代码-58"><a href="#参考代码-58" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        BFS
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrderBottom</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="keyword">if</span> (root) q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; level;</span><br><span class="line">            <span class="type">int</span> len = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span> (len -- ) &#123;</span><br><span class="line">                <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                level.<span class="built_in">push_back</span>(t-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;left) q.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;right) q.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-41"><a href="#Reference-41" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/384046/">[1]. yxc</a></p>
<br>


<h3 id="LeetCode-108-将有序数组转换为二叉搜索树"><a href="#LeetCode-108-将有序数组转换为二叉搜索树" class="headerlink" title="LeetCode 108. 将有序数组转换为二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">LeetCode 108. 将有序数组转换为二叉搜索树</a></h3><hr>
<h4 id="基本思路-60"><a href="#基本思路-60" class="headerlink" title="基本思路"></a>基本思路</h4><p>构建二叉树还是根据定义找递推式 构建二叉树 &#x3D; 构建左子树 + 构建右子树 + new出根节点连接左右子树<br>构建二叉树的参数需要数据范围，然后这里平衡二叉树是要根节点取中点<br>注意递归边界</p>
<p>难是难在证明为什么取中点作为根节点</p>
<h4 id="参考代码-59"><a href="#参考代码-59" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        递归
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">build</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[mid]);</span><br><span class="line">        root-&gt;left = <span class="built_in">build</span>(nums, l, mid - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">build</span>(nums, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>


<h4 id="Reference-42"><a href="#Reference-42" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/196/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-109-有序链表转换二叉搜索树"><a href="#LeetCode-109-有序链表转换二叉搜索树" class="headerlink" title="LeetCode 109. 有序链表转换二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/">LeetCode 109. 有序链表转换二叉搜索树</a></h3><hr>
<h4 id="基本思路-61"><a href="#基本思路-61" class="headerlink" title="基本思路"></a>基本思路</h4><p>和上一题本质一样，只是说把数组换成了链表<br>所以本题的考点，就是如何拿到链表的中点</p>
<p>思路1 转换成数组<br>直接存入数组</p>
<p>思路2 快慢指针拿中点</p>
<h4 id="参考代码-60"><a href="#参考代码-60" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p; p = p-&gt;next) &#123;</span><br><span class="line">            nums.<span class="built_in">emplace_back</span>(p-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">build</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[mid]);</span><br><span class="line">        root-&gt;left = <span class="built_in">build</span>(nums, l, mid - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">build</span>(nums, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路2
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getMedian</span><span class="params">(ListNode* left, ListNode* right)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = left;</span><br><span class="line">        ListNode* slow = left;</span><br><span class="line">        <span class="keyword">while</span> (fast != right &amp;&amp; fast-&gt;next != right) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(ListNode* left, ListNode* right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* mid = <span class="built_in">getMedian</span>(left, right);</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(mid-&gt;val);</span><br><span class="line">        root-&gt;left = <span class="built_in">buildTree</span>(left, mid);</span><br><span class="line">        root-&gt;right = <span class="built_in">buildTree</span>(mid-&gt;next, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">buildTree</span>(head, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>


<h4 id="Reference-43"><a href="#Reference-43" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/35664/">[1]. 张小白</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/554765/">[2]. LauZyHou</a></p>
<br>

<h3 id="LeetCode-110-平衡二叉树"><a href="#LeetCode-110-平衡二叉树" class="headerlink" title="LeetCode 110. 平衡二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/balanced-binary-tree/">LeetCode 110. 平衡二叉树</a></h3><hr>
<h4 id="基本思路-62"><a href="#基本思路-62" class="headerlink" title="基本思路"></a>基本思路</h4><p>首先还是尝试找递推式，发现没有办法找到关于平衡二叉树的一个递推式。<br>所以我们只能DFS遍历每一个节点的高度，然后对于每个节点去判断是否平衡。那么很显然，DFS返回值是高度，DFS参数只是遍历的话那就只需要树节点就行</p>
<h4 id="参考代码-61"><a href="#参考代码-61" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        DFS
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> ans = <span class="literal">true</span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> lt = <span class="built_in">dfs</span>(root-&gt;left), rt = <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(lt - rt) &gt; <span class="number">1</span>) ans = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(lt, rt) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-44"><a href="#Reference-44" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/384117/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-111-二叉树的最小深度"><a href="#LeetCode-111-二叉树的最小深度" class="headerlink" title="LeetCode 111. 二叉树的最小深度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">LeetCode 111. 二叉树的最小深度</a></h3><hr>
<h4 id="基本思路-63"><a href="#基本思路-63" class="headerlink" title="基本思路"></a>基本思路</h4><p>思路1： 递归<br>和之前的最大深度类似，还是找到递推式 树的最大深度 &#x3D; max(左子树的深度，右子树的深度) + 1;<br>这里的递归边界要注意，之前最小深度，null节点深度是0，不会影响最大值，但是这里是最小值，所以null会影响，所以应该边界更细化<br>难点就是注意递归的边界</p>
<p>思路2：BFS<br>深度，很明显我们可以用层序遍历的方式来做</p>
<h4 id="参考代码-62"><a href="#参考代码-62" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        递归
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left) <span class="keyword">return</span> <span class="built_in">minDepth</span>(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;right) <span class="keyword">return</span> <span class="built_in">minDepth</span>(root-&gt;left) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">minDepth</span>(root-&gt;left), <span class="built_in">minDepth</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        BFS
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">1</span>;</span><br><span class="line">        queue&lt;TreeNode *&gt; Q; Q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (Q.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="type">int</span> len = Q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span> (len--)&#123;</span><br><span class="line">                TreeNode *node = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (!node-&gt;left &amp;&amp; !node-&gt;right) <span class="keyword">return</span> depth;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) Q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) Q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            ++depth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-45"><a href="#Reference-45" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/390296/">[1]. yxc</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/15899/">[2]. adnil8130</a></p>
<br>

<h3 id="LeetCode-112-路径总和"><a href="#LeetCode-112-路径总和" class="headerlink" title="LeetCode 112. 路径总和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum/">LeetCode 112. 路径总和</a></h3><hr>
<h4 id="基本思路-64"><a href="#基本思路-64" class="headerlink" title="基本思路"></a>基本思路</h4><p>思路1：DFS + 回溯<br>直接思路就是搜索所有的路径，所以是回溯角度的DFS<br>回溯角度DFS一般有很多种写法，为了速度更快，我们把写法尽量统一，输入和全局变量，都当作引用传进DFS函数，其余的就是局部变量，自动回溯<br>然后判断还是否需要手动回溯，就是看当前层是不是我们想要的结果，如果不是就手动回溯一下</p>
<p>思路2：递归<br>还是根据定义去找递推式，树存在sum路径 &#x3D; 左子树 + 根节点 存在sum || 右子树 + 根节点 存在sum || 根节点存在sum<br>然后注意上述的递推式是存在分情况讨论的</p>
<h4 id="参考代码-63"><a href="#参考代码-63" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1：DFS - 回溯
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">    <span class="type">bool</span> ans;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root, targetSum, sum);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span>&amp; targetSum, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        sum += root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum == targetSum) ans = <span class="literal">true</span>; </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, targetSum, sum);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, targetSum, sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路2：递归
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sum -= root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> !sum;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;left &amp;&amp; <span class="built_in">hasPathSum</span>(root-&gt;left, sum) || root-&gt;right &amp;&amp; <span class="built_in">hasPathSum</span>(root-&gt;right, sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<br>

<h4 id="Reference-46"><a href="#Reference-46" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/390306/">[1]. yxc</a><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum/solution/yi-pian-wen-zhang-jie-jue-suo-you-er-cha-pqum/">[2]. 路径模板总结</a></p>
<br>

<h3 id="LeetCode-113-路径总和-II"><a href="#LeetCode-113-路径总和-II" class="headerlink" title="LeetCode 113. 路径总和 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-ii/">LeetCode 113. 路径总和 II</a></h3><hr>
<h4 id="基本思路-65"><a href="#基本思路-65" class="headerlink" title="基本思路"></a>基本思路</h4><p>跟上题思路一样，只是这里需要记录路径，回溯有很多种写法，我们这里采用我自己总结的一套写法</p>
<h4 id="参考代码-64"><a href="#参考代码-64" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        DFS + 回溯
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> targetSum) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(root, targetSum, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span>&amp; targetSum, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        sum += root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum == targetSum) res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, targetSum, sum);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, targetSum, sum);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-47"><a href="#Reference-47" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/390314/">[1]. yxc</a></p>
<br>


<h3 id="LeetCode-141-环形链表"><a href="#LeetCode-141-环形链表" class="headerlink" title="LeetCode 141. 环形链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle/">LeetCode 141. 环形链表</a></h3><hr>
<h4 id="基本思路-66"><a href="#基本思路-66" class="headerlink" title="基本思路"></a>基本思路</h4><p>思路1<br>直接开一个哈希表，然后存入每一个节点，如果一个节点重复出现，那么就有环</p>
<p>思路2<br>快慢指针，慢指针一次一步，快指针一次两步，如果有环快慢指针会重合，否则快指针先到空的位置</p>
<h4 id="参考代码-65"><a href="#参考代码-65" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;ListNode*, <span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            s[head] += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (s[head] &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            head = head-&gt;next; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路2
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">auto</span> p = head, q = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (p != q &amp;&amp; p &amp;&amp; q &amp;&amp; q-&gt;next) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q = q-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p == q; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-48"><a href="#Reference-48" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/404934/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-142-环形链表-II"><a href="#LeetCode-142-环形链表-II" class="headerlink" title="LeetCode 142. 环形链表 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/">LeetCode 142. 环形链表 II</a></h3><hr>
<h4 id="基本思路-67"><a href="#基本思路-67" class="headerlink" title="基本思路"></a>基本思路</h4><p>在环形链表1的基础上，还需要找到入口的位置，这里我们通过数学证明知道，相遇的时候，慢指针不会超过一圈，所以可以知道起点到入口的距离，等于相遇点到入口的距离<br>所以还是双指针，同时移动一格，相遇的时候就是入口</p>
<h4 id="参考代码-66"><a href="#参考代码-66" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> slow = head, fast = head-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (slow != fast &amp;&amp; slow &amp;&amp; fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (slow != fast) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> a = head, b = fast-&gt;next;</span><br><span class="line">            <span class="keyword">while</span> (a != b) &#123;</span><br><span class="line">                a = a-&gt;next, b = b-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-49"><a href="#Reference-49" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/404952/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-143-重排链表"><a href="#LeetCode-143-重排链表" class="headerlink" title="LeetCode 143. 重排链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reorder-list/">LeetCode 143. 重排链表</a></h3><hr>
<h4 id="基本思路-68"><a href="#基本思路-68" class="headerlink" title="基本思路"></a>基本思路</h4><p>思路1<br>如果是线性表这题直接双指针指向头尾，然后依次处理就行，但是需要额外的空间</p>
<p>思路2<br>最直接的思路，就是需要枚举出中点前的所有节点，和中点后的所有节点，枚举一些点所以很明显就是遍历然后放入新链表，然后这两个链表合并<br>所以几个步骤 1.找到中点 2.反转中点后面的列表 3.中点前的节点和中点后的节点分别放入两个新链表 4.合并这两个链表</p>
<h4 id="参考代码-67"><a href="#参考代码-67" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reorderList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;ListNode *&gt; vec;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p; p = p-&gt;next) &#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = vec.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            vec[i++]-&gt;next = vec[j];</span><br><span class="line">            <span class="keyword">if</span> (i == j) <span class="keyword">break</span>;</span><br><span class="line">            vec[j--]-&gt;next = vec[i];</span><br><span class="line">        &#125;</span><br><span class="line">        vec[i]-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路2
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> mid = <span class="built_in">getMiddle</span>(head);</span><br><span class="line">        <span class="keyword">auto</span> rHead = <span class="built_in">reverseList</span>(mid);</span><br><span class="line">        <span class="keyword">auto</span> lHead = head;</span><br><span class="line">        <span class="keyword">while</span> (lHead-&gt;next != rHead &amp;&amp; lHead != rHead)&#123;</span><br><span class="line">            <span class="keyword">auto</span> rNext = rHead-&gt;next;</span><br><span class="line">            rHead-&gt;next = lHead-&gt;next;</span><br><span class="line">            lHead-&gt;next = rHead;</span><br><span class="line">            rHead = rNext;</span><br><span class="line">            lHead = lHead-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">getMiddle</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> slow = head, fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            slow = slow-&gt;next, fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> a = head, b = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (b)&#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp = b-&gt;next;</span><br><span class="line">            b-&gt;next = a;</span><br><span class="line">            a = b, b = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>


<h4 id="Reference-50"><a href="#Reference-50" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/2947/">[1]. LeetCode 143. Reorder List</a></p>
<br>

<h3 id="LeetCode-144-二叉树的前序遍历"><a href="#LeetCode-144-二叉树的前序遍历" class="headerlink" title="LeetCode 144. 二叉树的前序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">LeetCode 144. 二叉树的前序遍历</a></h3><hr>
<h4 id="基本思路-69"><a href="#基本思路-69" class="headerlink" title="基本思路"></a>基本思路</h4><p>二叉树的前序遍历，代码很简单，但是内部蕴含的思想需要深究，一下给出许多版本的代码，供思考</p>
<p>参照中序遍历</p>
<h4 id="参考代码-68"><a href="#参考代码-68" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        递归
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        迭代 不加标记
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (root || stk.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">                stk.<span class="built_in">push</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            root = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        迭代 + 标记 + 空节点不入栈
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;TreeNode*, <span class="type">int</span>&gt; vis;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (root || stk.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root) &#123;</span><br><span class="line">                vis[root] = <span class="number">1</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">                stk.<span class="built_in">push</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            root = stk.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (vis[root] == <span class="number">1</span>) &#123;</span><br><span class="line">                vis[root] = <span class="number">2</span>;</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                root = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        迭代 + 标记 + 空节点入栈
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;pair&lt;TreeNode*, <span class="type">int</span>&gt;&gt;stk;</span><br><span class="line">        stk.<span class="built_in">push</span>(&#123;root, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (stk.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (stk.<span class="built_in">top</span>().first == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> t = stk.<span class="built_in">top</span>().second;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(stk.<span class="built_in">top</span>().first-&gt;val);</span><br><span class="line">                stk.<span class="built_in">top</span>().second = <span class="number">1</span>;</span><br><span class="line">                stk.<span class="built_in">push</span>(&#123;stk.<span class="built_in">top</span>().first-&gt;left, <span class="number">0</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                stk.<span class="built_in">top</span>().second = <span class="number">2</span>;</span><br><span class="line">                stk.<span class="built_in">push</span>(&#123;stk.<span class="built_in">top</span>().first-&gt;right, <span class="number">0</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> stk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<br>

<h4 id="Reference-51"><a href="#Reference-51" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/404978/">[1]. yxc</a></p>
<br>


<h3 id="LeetCode-145-二叉树的后序遍历"><a href="#LeetCode-145-二叉树的后序遍历" class="headerlink" title="LeetCode 145. 二叉树的后序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">LeetCode 145. 二叉树的后序遍历</a></h3><hr>
<h4 id="基本思路-70"><a href="#基本思路-70" class="headerlink" title="基本思路"></a>基本思路</h4><p>二叉树的后序遍历，代码很简单，但是内部蕴含的思想需要深究，一下给出许多版本的代码，供思考</p>
<p>参照中序遍历，这里不加标记的迭代法，有两种做法</p>
<h4 id="参考代码-69"><a href="#参考代码-69" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        递归
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;right);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        迭代 + 不加标记 + prev
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (root || stk.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root) &#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            root = stk.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right == <span class="literal">nullptr</span> || prev == root-&gt;right) &#123;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">                prev = root;</span><br><span class="line">                root = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        迭代 + 不加标记 + trick做法
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        <span class="keyword">while</span> (root || stk.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">                stk.<span class="built_in">push</span>(root);</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            root = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>



<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        迭代 + 标记 + 空节点不入栈
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;TreeNode*, <span class="type">int</span>&gt; vis;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (root || stk.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root) &#123;</span><br><span class="line">                vis[root] = <span class="number">1</span>;</span><br><span class="line">                stk.<span class="built_in">push</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            root = stk.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (vis[root] == <span class="number">1</span>) &#123;</span><br><span class="line">                vis[root] = <span class="number">2</span>;</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">                root = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        迭代 + 标记 + 空节点入栈
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;pair&lt;TreeNode*, <span class="type">int</span>&gt;&gt;stk;</span><br><span class="line">        stk.<span class="built_in">push</span>(&#123;root, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (stk.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (stk.<span class="built_in">top</span>().first == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> t = stk.<span class="built_in">top</span>().second;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                stk.<span class="built_in">top</span>().second = <span class="number">1</span>;</span><br><span class="line">                stk.<span class="built_in">push</span>(&#123;stk.<span class="built_in">top</span>().first-&gt;left, <span class="number">0</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                stk.<span class="built_in">top</span>().second = <span class="number">2</span>;</span><br><span class="line">                stk.<span class="built_in">push</span>(&#123;stk.<span class="built_in">top</span>().first-&gt;right, <span class="number">0</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(stk.<span class="built_in">top</span>().first-&gt;val);</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<br>

<h4 id="Reference-52"><a href="#Reference-52" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/404993/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-146-LRU缓存机制"><a href="#LeetCode-146-LRU缓存机制" class="headerlink" title="LeetCode 146. LRU缓存机制"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lru-cache/">LeetCode 146. LRU缓存机制</a></h3><hr>
<h4 id="基本思路-71"><a href="#基本思路-71" class="headerlink" title="基本思路"></a>基本思路</h4><p>设计类的题目一定要分析清楚题意再下手。<br>首先此题需要的数据结构需要有key-value对，然后get和put都需要在O(1)级别，所以很容易想到我们开个哈希表来维护。<br>然后对于get和put的不存在后的操作哈希表都可以完成，但是对于LRU机制是如果超过容量，需要把<strong>最久未使用</strong>的key删掉，这里涉及到了时间戳，也就是说我们需要对每个key加上时间戳的概念。<br>所以我们可以联想到队列，先入先出，这样就可以通过队列完成时间戳。对于LRU缓存机制我们这里需要对任意key删除后放到队头，然后超过容量就删掉队尾。<br>这里STL里的queue只能入队出队无法完成我们的操作，所以这里我们使用双链表实现队列（注意不能使用单链表，单链表删除是O(n))</p>
<p>所以数据结构确定下来了，就是利用双链表+哈希表来实现</p>
<h4 id="参考代码-70"><a href="#参考代码-70" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="type">int</span> key, val;</span><br><span class="line">            Node* left, *right;</span><br><span class="line">            <span class="built_in">Node</span>(<span class="type">int</span> _key, <span class="type">int</span> _val) : <span class="built_in">key</span>(_key), <span class="built_in">val</span>(_val), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    &#125; *L, *R; <span class="comment">// 两个哨兵结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从双链表里删除一个元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(Node* p)</span> </span>&#123;</span><br><span class="line">        p-&gt;left-&gt;right = p-&gt;right;</span><br><span class="line">        p-&gt;right-&gt;left = p-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在双链表的最左侧插入一个元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(Node* p)</span> </span>&#123;</span><br><span class="line">        p-&gt;right = L-&gt;right;</span><br><span class="line">        p-&gt;left = L;</span><br><span class="line">        p-&gt;right-&gt;left = p;</span><br><span class="line">        p-&gt;left-&gt;right = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, Node*&gt; hash;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        n = capacity;</span><br><span class="line">        L = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">-1</span>, <span class="number">-1</span>), R = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">        L -&gt; right = R, R -&gt; left = L;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!hash.<span class="built_in">count</span>(key))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">auto</span> p = hash[key];</span><br><span class="line">        <span class="comment">// 因为访问了，所以要把它移动到最左边</span></span><br><span class="line">        <span class="built_in">remove</span>(p);</span><br><span class="line">        <span class="built_in">insert</span>(p);</span><br><span class="line">        <span class="keyword">return</span> p-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hash.<span class="built_in">count</span>(key)) &#123; <span class="comment">// 表里有这个元素</span></span><br><span class="line">            <span class="keyword">auto</span> p = hash[key];</span><br><span class="line">            p-&gt;val = value;</span><br><span class="line">            <span class="built_in">remove</span>(p);</span><br><span class="line">            <span class="built_in">insert</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 表里没有这个元素</span></span><br><span class="line">            <span class="keyword">if</span> (hash.<span class="built_in">size</span>() == n) &#123; <span class="comment">// 表满了，要删除一个最右边的</span></span><br><span class="line">                <span class="keyword">auto</span> p = R-&gt;left;</span><br><span class="line">                hash.<span class="built_in">erase</span>(p-&gt;key);</span><br><span class="line">                <span class="built_in">remove</span>(p);</span><br><span class="line">                <span class="keyword">delete</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 插入元素</span></span><br><span class="line">            <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line">            <span class="built_in">insert</span>(p);</span><br><span class="line">            hash[key] = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-53"><a href="#Reference-53" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/562452/">[1]. LauZyHou</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/63191/">[2]. 有心人</a></p>
<h3 id="LeetCode-150-逆波兰表达式求值"><a href="#LeetCode-150-逆波兰表达式求值" class="headerlink" title="LeetCode 150. 逆波兰表达式求值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">LeetCode 150. 逆波兰表达式求值</a></h3><hr>
<h4 id="基本思路-72"><a href="#基本思路-72" class="headerlink" title="基本思路"></a>基本思路</h4><p>模拟题，用栈去模拟后缀表达式的计算过程<br>如果当前元素是数，那就压入栈；如果是运算符，那就将栈顶两个元素弹出做相应运算，然后将结果入栈</p>
<p>题目很简单，但是背后蕴含的一些思路我们这里深究一下</p>
<p>首先对于后缀表达式和前缀表达式，其实都对应了一棵表达式树（叶节点是数字，内部节点是运算符）：<br>中缀表达式其实就是表达式树的中序遍历<br>后缀表达式其实就是表达式树的后序遍历</p>
<p>所以最直接的做法可以建树，然后递归来做（递归函数里是求左右子树的值，然后根据节点的运算符求职）<br>这里用栈模拟达到递归的效果</p>
<blockquote>
<p>人类一般用中缀表达式计算，计算机用后缀表达式计算。</p>
</blockquote>
<h4 id="参考代码-71"><a href="#参考代码-71" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> b = stk.<span class="built_in">top</span>(); stk.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> a = stk.<span class="built_in">top</span>(); stk.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&quot;+&quot;</span>) stk.<span class="built_in">push</span>(a + b);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">&quot;-&quot;</span>) stk.<span class="built_in">push</span>(a - b);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">&quot;*&quot;</span>) stk.<span class="built_in">push</span>(a * b);</span><br><span class="line">        <span class="keyword">else</span> stk.<span class="built_in">push</span>(a / b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;string&gt; S&#123;<span class="string">&quot;+&quot;</span>, <span class="string">&quot;-&quot;</span>, <span class="string">&quot;*&quot;</span>, <span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;s: tokens) &#123;</span><br><span class="line">            <span class="keyword">if</span> (S.<span class="built_in">count</span>(s)) <span class="built_in">eval</span>(s);</span><br><span class="line">            <span class="keyword">else</span> stk.<span class="built_in">push</span>(<span class="built_in">stoi</span>(s));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Reference-54"><a href="#Reference-54" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/89218/">[1]. 详细笔记</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/19036/">[2]. 小呆呆</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/562864/">[3]. LauZyHou</a></p>
<br>

<h3 id="LeetCode-203-移除链表元素"><a href="#LeetCode-203-移除链表元素" class="headerlink" title="LeetCode 203. 移除链表元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-linked-list-elements/">LeetCode 203. 移除链表元素</a></h3><hr>
<h4 id="基本思路-73"><a href="#基本思路-73" class="headerlink" title="基本思路"></a>基本思路</h4><p>新建一个列表，然后遍历原链表，满足的放进去，不满足的就跳过，注意tail最后是原链表最后一个满足的点，后面还是有其他节点的<br>所以tail之后要指向空</p>
<h4 id="参考代码-72"><a href="#参考代码-72" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        迭代法
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), tail = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p; p = p-&gt;next)</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;val != val)</span><br><span class="line">                tail = tail-&gt;next = p;</span><br><span class="line">        tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-55"><a href="#Reference-55" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/422060/">[1]. yxc</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/420363/">[2]. other</a></p>
<h3 id="LeetCode-206-反转链表"><a href="#LeetCode-206-反转链表" class="headerlink" title="LeetCode 206. 反转链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/">LeetCode 206. 反转链表</a></h3><hr>
<h4 id="基本思路-74"><a href="#基本思路-74" class="headerlink" title="基本思路"></a>基本思路</h4><p><strong>迭代法</strong><br>链表的题目也是注意画图和思维流程</p>
<ol>
<li>首先要反转相邻两个节点间的指针，所以需要拿到这两个节点，“一段”直接枚举，然后指针移动即可</li>
<li>具体逻辑，就是改变后一个点的next，然后移动到下一段</li>
<li>最后把第一个节点的next指向空，然后返回新的头节点</li>
</ol>
<p>时间复杂度：只遍历一次链表，$O(n)$<br>空间复杂度：遍历时只有3个额外变量,$O(1)$</p>
<p><strong>递归法</strong><br>递归法主要就是明确递归函数的定义，reverseList 函数能做什么，它可以翻转一个链表，并返回新链表的头节点，也就是原链表的尾节点<br>然后结合定义直接处理剩余的步骤。</p>
<ol>
<li>递归处理 reverseList(head-&gt;next)，这样我们可以将以head-&gt;next为头节点的链表翻转，并得到原链表的尾节点tail。</li>
<li>此时head-&gt;next是新链表的尾节点，我们令它的next指针指向head，并将head-&gt;next指向空即可将整个链表翻转，且新链表的头节点是tail</li>
</ol>
<p>时间复杂度：只遍历一次链表，$O(n)$<br>空间复杂度：总共递归 n 层，系统栈的空间复杂度是$O(n)$</p>
<blockquote>
<p>这里我们需要知道为什么可以用递归，以及怎么写递归函数<br>  递归其实就是不断地层层进入，直到达到边界开始层层回溯到起点得到答案，所以我们先看看怎么进入，进入代码里对应的就是递归函数的写法，需要可以不断地进入，链表题一般是通过next<br>  然后看能否到达边界，这里的边界其实就是head指针移动到最后一个点或者是空点，因为这个时候反转的结果是它自己。所以此题可以用递归法做</p>
</blockquote>
<h4 id="参考代码-73"><a href="#参考代码-73" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        迭代法
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">auto</span> a = head, b = a-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (b) &#123;</span><br><span class="line">            <span class="keyword">auto</span> c = b-&gt;next;</span><br><span class="line">            b-&gt;next = a;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        递归法
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">auto</span> tail = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> tail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-56"><a href="#Reference-56" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/316/">[1]. Reverse Linked List</a></p>
<br>

<h3 id="LeetCode-215-数组中的第K个最大元素"><a href="#LeetCode-215-数组中的第K个最大元素" class="headerlink" title="LeetCode 215. 数组中的第K个最大元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">LeetCode 215. 数组中的第K个最大元素</a></h3><h4 id="基本思路-75"><a href="#基本思路-75" class="headerlink" title="基本思路"></a>基本思路</h4><p>模板题，快速选择算法，注意这里求的是第k大的元素，所以排序的时候翻转一下，其他的没区别</p>
<p>时间复杂度：$O(n)$<br>空间复杂度：$O(logn)$</p>
<h4 id="参考代码-74"><a href="#参考代码-74" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        快选模板
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">quick_select</span>(nums, <span class="number">0</span> , nums.<span class="built_in">size</span>() - <span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">quick_select</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> nums[r];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = nums[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">do</span> i++; <span class="keyword">while</span> (nums[i] &gt; x);</span><br><span class="line">            <span class="keyword">do</span> j--; <span class="keyword">while</span> (nums[j] &lt; x);</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sl = j - l + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= sl) <span class="keyword">return</span> <span class="built_in">quick_select</span>(nums, l, j, k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">quick_select</span>(nums, j + <span class="number">1</span>, r, k - sl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-57"><a href="#Reference-57" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/597477/">[1]. LauZyHou</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/63587/">[2]. 其他解法汇总</a></p>
<br>

<h3 id="LeetCode-237-删除链表中的节点"><a href="#LeetCode-237-删除链表中的节点" class="headerlink" title="LeetCode 237. 删除链表中的节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-node-in-a-linked-list/">LeetCode 237. 删除链表中的节点</a></h3><hr>
<h4 id="基本思路-76"><a href="#基本思路-76" class="headerlink" title="基本思路"></a>基本思路</h4><p>这题是一个比较特殊的一题，它无法访问头节点，所以我们无法用常规地找到前一个节点来删除，这里用了一个比较trick的做法，就是让当前节点<strong>覆盖</strong>成后一个节点，就可以达到删除的效果<br>但是这个方法没办法删除尾节点，因为尾节点不存在后一个节点</p>
<h4 id="参考代码-75"><a href="#参考代码-75" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        分步
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;val = node-&gt;next-&gt;val;</span><br><span class="line">        node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        一步到位
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        *node = *(node-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<br>

<h3 id="LeetCode-445-两数相加-II"><a href="#LeetCode-445-两数相加-II" class="headerlink" title="LeetCode 445. 两数相加 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/add-two-numbers-ii/">LeetCode 445. 两数相加 II</a></h3><hr>
<h4 id="基本思路-77"><a href="#基本思路-77" class="headerlink" title="基本思路"></a>基本思路</h4><p>因为这里低位在右边，所以为了从低位开始相加，所以反转链表<br>然后反转完后，得到的结果我们要保证低位在右边，所以新加的点往前放，所以头插法</p>
<h4 id="参考代码-76"><a href="#参考代码-76" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> a = head, b = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (b) &#123;</span><br><span class="line">            <span class="keyword">auto</span> c = b-&gt;next;</span><br><span class="line">            b-&gt;next = a;</span><br><span class="line">            a = b, b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        l1 = <span class="built_in">reverse</span>(l1), l2 = <span class="built_in">reverse</span>(l2);</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 || l2 || t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1) t += l1-&gt;val, l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (l2) t += l2-&gt;val, l2 = l2-&gt;next;</span><br><span class="line">            <span class="keyword">auto</span> cur = <span class="keyword">new</span> <span class="built_in">ListNode</span>(t % <span class="number">10</span>);</span><br><span class="line">            cur-&gt;next = dummy-&gt;next;</span><br><span class="line">            dummy-&gt;next = cur;</span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>


<h4 id="Reference-58"><a href="#Reference-58" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/541543/">[1]. yxc</a></p>
<BR>

<h3 id="LeetCode-876-链表的中间结点"><a href="#LeetCode-876-链表的中间结点" class="headerlink" title="LeetCode 876. 链表的中间结点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/middle-of-the-linked-list/">LeetCode 876. 链表的中间结点</a></h3><hr>
<h4 id="基本思路-78"><a href="#基本思路-78" class="headerlink" title="基本思路"></a>基本思路</h4><p>思路1<br>快慢指针，同一起点出发，当快指针下一个节点为空或者快指针为空，慢指针走到中点<br>如果想拿</p>
<p>思路2<br>两次遍历，第一次得到链表长度，第二次拿到中点<br>拓展 如果偶数拿后面的节点 奇偶中点都是 n &#x2F; 2 + 1;如果偶数拿前面的节点 (n + 1) &#x2F; 2.</p>
<h4 id="参考代码-77"><a href="#参考代码-77" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> slow = head, fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路2
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p = head; p != <span class="literal">NULL</span>; p = p-&gt;next) n ++;</span><br><span class="line">        <span class="keyword">auto</span> res = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n / <span class="number">2</span>;i ++) res = res-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-59"><a href="#Reference-59" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/1250718/">[1]. gaoren</a></p>
<h2 id="LeetCode-901-1000"><a href="#LeetCode-901-1000" class="headerlink" title="LeetCode 901 - 1000"></a>LeetCode 901 - 1000</h2><h3 id="LeetCode-912-排序数组"><a href="#LeetCode-912-排序数组" class="headerlink" title="LeetCode 912. 排序数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-an-array/">LeetCode 912. 排序数组</a></h3><hr>
<h4 id="基本思路-79"><a href="#基本思路-79" class="headerlink" title="基本思路"></a>基本思路</h4><p>快速排序，归并排序，堆排序，主要是掌握这三种排序</p>
<h4 id="参考代码-78"><a href="#参考代码-78" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        快选模板
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">quick_sort</span>(nums, <span class="number">0</span> , n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;q, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">do</span> i++; <span class="keyword">while</span>(q[i] &lt; x);</span><br><span class="line">            <span class="keyword">do</span> j--; <span class="keyword">while</span>(q[j] &gt; x);</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">quick_sort</span>(q, l, j);</span><br><span class="line">        <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>



<link rel="stylesheet" href="/blog/css/spoiler.css" type="text/css"><script src="/blog/js/spoiler.js" type="text/javascript" async></script>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://vendestine.github.io/blog/2023/01/10/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/leetcode/leetcode-1-100/" data-id="cll9axhcf0015xgud8f1oddfv" data-title="LeetCode题目合集" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/blog/2023/01/11/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/leetcode/binary-tree/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          算法-二叉树
        
      </div>
    </a>
  
  
    <a href="/blog/2022/11/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/flask-note/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Python-Flask开发笔记</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E5%BA%95%E5%B1%82%E5%BC%80%E5%8F%91/">底层开发</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E5%BA%95%E5%B1%82%E5%BC%80%E5%8F%91/Linux%E4%B8%93%E6%A0%8F/">Linux专栏</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E5%BA%95%E5%B1%82%E5%BC%80%E5%8F%91/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E6%8A%80%E6%9C%AF%E7%BB%8F%E9%AA%8C/">技术经验</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/">算法笔记</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/AcWing/">AcWing</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/LeetCode/">LeetCode</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/">个人总结</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/">C++</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/">Python</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/">项目经历</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">个人博客</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/C-Primer/" rel="tag">C++ Primer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Django/" rel="tag">Django</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Flask/" rel="tag">Flask</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E4%BA%8C%E5%88%86/" rel="tag">二分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/" rel="tag">位运算</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/" rel="tag">前缀和与差分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/" rel="tag">区间合并</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" rel="tag">双指针</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E5%9B%BE%E8%AE%BA/" rel="tag">图论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E6%8E%92%E5%BA%8F/" rel="tag">排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E6%90%9C%E7%B4%A2/" rel="tag">搜索</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/" rel="tag">离散化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/" rel="tag">高精度</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/blog/tags/C/" style="font-size: 18px;">C++</a> <a href="/blog/tags/C-Primer/" style="font-size: 10px;">C++ Primer</a> <a href="/blog/tags/Django/" style="font-size: 10px;">Django</a> <a href="/blog/tags/Flask/" style="font-size: 10px;">Flask</a> <a href="/blog/tags/Linux/" style="font-size: 12px;">Linux</a> <a href="/blog/tags/Python/" style="font-size: 14px;">Python</a> <a href="/blog/tags/%E4%BA%8C%E5%88%86/" style="font-size: 10px;">二分</a> <a href="/blog/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 10px;">二叉树</a> <a href="/blog/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/" style="font-size: 10px;">位运算</a> <a href="/blog/tags/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/" style="font-size: 10px;">前缀和与差分</a> <a href="/blog/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">动态规划</a> <a href="/blog/tags/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/" style="font-size: 10px;">区间合并</a> <a href="/blog/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" style="font-size: 10px;">双指针</a> <a href="/blog/tags/%E5%9B%BE%E8%AE%BA/" style="font-size: 10px;">图论</a> <a href="/blog/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">排序</a> <a href="/blog/tags/%E6%90%9C%E7%B4%A2/" style="font-size: 10px;">搜索</a> <a href="/blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">操作系统</a> <a href="/blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 16px;">数据结构</a> <a href="/blog/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/" style="font-size: 10px;">离散化</a> <a href="/blog/tags/%E7%AE%97%E6%B3%95/" style="font-size: 20px;">算法</a> <a href="/blog/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 10px;">面试</a> <a href="/blog/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/" style="font-size: 10px;">高精度</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2023/07/">July 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2023/05/">May 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2023/02/">February 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2023/01/">January 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2022/11/">November 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2022/03/">March 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2023/07/04/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/blog_tutorial/">博客建站</a>
          </li>
        
          <li>
            <a href="/blog/2023/05/04/%E5%BA%95%E5%B1%82%E5%BC%80%E5%8F%91/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/os-learn-memory/">操作系统--内存管理</a>
          </li>
        
          <li>
            <a href="/blog/2023/04/07/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/c++-primer-p1/">C++ Primer Part1 - C++基础</a>
          </li>
        
          <li>
            <a href="/blog/2023/03/14/%E5%BA%95%E5%B1%82%E5%BC%80%E5%8F%91/linux%E4%B8%93%E6%A0%8F/web-server/">Linux-开发笔记</a>
          </li>
        
          <li>
            <a href="/blog/2023/02/24/%E6%8A%80%E6%9C%AF%E7%BB%8F%E9%AA%8C/remote-vscode-config/">配置远程开发环境</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 Wenzhe Li<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">Home</a>
  
    <a href="/blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/blog/js/jquery-3.6.4.min.js"></script>



  
<script src="/blog/fancybox/jquery.fancybox.min.js"></script>




<script src="/blog/js/script.js"></script>





  </div>
</body>
</html>