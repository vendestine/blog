

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Wenzhe Li">
  <meta name="keywords" content="">
  
    <meta name="description" content="LeetCode编号顺序排列，主要阐述思路，附AC代码">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode题目合集">
<meta property="og:url" content="https://vendestine.com/2023/01/10/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/leetcode/leetcode-1-100/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="LeetCode编号顺序排列，主要阐述思路，附AC代码">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://vendestine.com/img/LeetCode.png">
<meta property="article:published_time" content="2023-01-10T23:28:01.000Z">
<meta property="article:modified_time" content="2023-08-13T09:10:24.150Z">
<meta property="article:author" content="Wenzhe Li">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://vendestine.com/img/LeetCode.png">
  
  
  
  <title>LeetCode题目合集 - Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"vendestine.com","root":"/","version":"1.9.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"rsfCNwYEYG167BlEXzFi6nFM-9Nh9j0Va","app_key":"YgnhSGLdGVYg7L4mapy5ab5f","server_url":"https://rsfcnwye.lc-cn-e1-shared.com","path":"window.location.pathname","ignore_local":true}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Vendestine&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/fox.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="LeetCode题目合集"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-01-10 18:28" pubdate>
          January 10, 2023 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          83k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          692 mins
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> views
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar category-bar" style="margin-right: -1rem">
    





<div class="category-list">
  
  
    
    
    
    <div class="category row nomargin-x">
      <a class="category-item 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="算法笔记"
        id="heading-6caacb5aaee15525d7a2b4768aa79852" role="tab" data-toggle="collapse" href="#collapse-6caacb5aaee15525d7a2b4768aa79852"
        aria-expanded="true"
      >
        算法笔记
        <span class="list-group-count">(16)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-6caacb5aaee15525d7a2b4768aa79852"
           role="tabpanel" aria-labelledby="heading-6caacb5aaee15525d7a2b4768aa79852">
        
        
          
          
  <div class="category-post-list">
    
    
  </div>

          
  
    
    
    
    <div class="category-sub row nomargin-x">
      <a class="category-subitem collapsed
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="AcWing"
        id="heading-beb5f7a9e4de27d5c6be7987245e5075" role="tab" data-toggle="collapse" href="#collapse-beb5f7a9e4de27d5c6be7987245e5075"
        aria-expanded="false"
      >
        AcWing
        <span class="list-group-count">(13)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse " id="collapse-beb5f7a9e4de27d5c6be7987245e5075"
           role="tabpanel" aria-labelledby="heading-beb5f7a9e4de27d5c6be7987245e5075">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/2022/03/19/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/acwing/binary-search/" title="算法-二分"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">算法-二分</span>
        </a>
      
    
      
      
        <a href="/2022/05/05/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/acwing/bit-discrete/" title="算法-位运算，离散化，区间合并"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">算法-位运算，离散化，区间合并</span>
        </a>
      
    
      
      
        <a href="/2022/03/27/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/acwing/prefix-difference/" title="算法-前缀和与差分"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">算法-前缀和与差分</span>
        </a>
      
    
      
      
        <a href="/2022/05/10/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/acwing/dp-basic/" title="算法-动态规划"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">算法-动态规划</span>
        </a>
      
    
      
      
        <a href="/2022/03/29/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/acwing/two-pointer/" title="算法-双指针算法"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">算法-双指针算法</span>
        </a>
      
    
      
      
        <a href="/2022/04/22/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/acwing/map/" title="算法-图论"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">算法-图论</span>
        </a>
      
    
      
      
        <a href="/2022/03/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/acwing/quick-sort/" title="算法-快速排序+归并排序"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">算法-快速排序+归并排序</span>
        </a>
      
    
      
      
        <a href="/2022/04/20/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/acwing/bfs-dfs/" title="算法-搜索"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">算法-搜索</span>
        </a>
      
    
      
      
        <a href="/2022/04/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/acwing/trie-heap/" title="算法-数据结构：Trie树和堆"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">算法-数据结构：Trie树和堆</span>
        </a>
      
    
      
      
        <a href="/2022/04/10/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/acwing/hash/" title="算法-数据结构：哈希表，并查集，KMP"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">算法-数据结构：哈希表，并查集，KMP</span>
        </a>
      
    
      
      
        <a href="/2022/04/07/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/acwing/stack-queue/" title="算法-数据结构：栈与队列"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">算法-数据结构：栈与队列</span>
        </a>
      
    
      
      
        <a href="/2022/04/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/acwing/list/" title="算法-数据结构：链表"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">算法-数据结构：链表</span>
        </a>
      
    
      
      
        <a href="/2022/03/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/acwing/big-integer/" title="算法-高精度运算"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">算法-高精度运算</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
    
    
    
    <div class="category-sub row nomargin-x">
      <a class="category-subitem 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="LeetCode"
        id="heading-071fda8ffed879b16c3308d2133bac46" role="tab" data-toggle="collapse" href="#collapse-071fda8ffed879b16c3308d2133bac46"
        aria-expanded="true"
      >
        LeetCode
        <span class="list-group-count">(2)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-071fda8ffed879b16c3308d2133bac46"
           role="tabpanel" aria-labelledby="heading-071fda8ffed879b16c3308d2133bac46">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/2023/01/10/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/leetcode/leetcode-1-100/" title="LeetCode题目合集"
           class="list-group-item list-group-item-action
           active">
          <span class="category-post">LeetCode题目合集</span>
        </a>
      
    
      
      
        <a href="/2023/01/11/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/leetcode/binary-tree/" title="算法-二叉树"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">算法-二叉树</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
    
    
    
    <div class="category-sub row nomargin-x">
      <a class="category-subitem collapsed
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="个人总结"
        id="heading-c61f002b167a04b1402e3274c1685ccf" role="tab" data-toggle="collapse" href="#collapse-c61f002b167a04b1402e3274c1685ccf"
        aria-expanded="false"
      >
        个人总结
        <span class="list-group-count">(1)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse " id="collapse-c61f002b167a04b1402e3274c1685ccf"
           role="tabpanel" aria-labelledby="heading-c61f002b167a04b1402e3274c1685ccf">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/2023/02/04/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/STL-application/" title="算法-数据结构：STL常用技巧"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">算法-数据结构：STL常用技巧</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
        
      </div>
    </div>
  
</div>


  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">LeetCode题目合集</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="LeetCode-1-100"><a href="#LeetCode-1-100" class="headerlink" title="LeetCode 1 - 100"></a>LeetCode 1 - 100</h2><h3 id="LeetCode-1-两数之和"><a href="#LeetCode-1-两数之和" class="headerlink" title="LeetCode 1. 两数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/">LeetCode 1. 两数之和</a></h3><hr>
<h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><p>首先想到暴力枚举两个数的朴素做法，然后尝试双指针优化，和哈希表优化</p>
<ol>
<li><p>暴力枚举两个数<br>枚举两个数$O(n^2)$，每组数检查合法$O(1)$<br>时间复杂度：$O(n^2)$</p>
</li>
<li><p>排序后得到单调性，双指针优化<br>注意这里要返回的是下标，排序后拿到的值的下标不是原下标，所以需要用空间存储原数组下标<br>(不能简单的用hash表存，因为类似于<code>[3,3] target = 6</code>，如果用hash表<code>key = nums[i], value = i</code>, 最后寻值下标会是相同的索引，C++建议用<code>vector&lt;pair&lt;int, int&gt;&gt;</code><br>时间复杂度：$O(nlogn)(排序) + O(n)(双指针) &#x3D; O(nlogn)$<br>空间复杂度：$O(n)$</p>
</li>
<li><p>枚举一个数，找合法的另一个数（哈希表）<br>查找某一个数是否存在，很明显用哈希表，这里很明显用了空间换时间的tradeoff<br>时间复杂度：$O(n) + O(1)(哈希表) &#x3D; O(n) $<br>空间复杂度：$O(n)$</p>
</li>
</ol>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++ )<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++ )<br>                <span class="hljs-keyword">if</span> (nums[i] + nums[j] == target) <span class="hljs-keyword">return</span> &#123;j, i&#125;;<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路2
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; p;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++) p.<span class="hljs-built_in">push_back</span>(&#123;nums[i], i&#125;);<br>        <span class="hljs-built_in">sort</span>(p.<span class="hljs-built_in">begin</span>(), p.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; j &lt; nums.<span class="hljs-built_in">size</span>(); j++ ) &#123;<br>            <span class="hljs-keyword">while</span> (j &lt; i &amp;&amp; p[i].first + p[j].first &gt; target) i -- ;<br>            <span class="hljs-keyword">if</span> (p[i].first + p[j].first == target) <span class="hljs-keyword">return</span> &#123;p[j].second, p[i].second&#125;;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路3 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; heap;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++ ) &#123;<br>            <span class="hljs-type">int</span> r = target - nums[i];<br>            <span class="hljs-keyword">if</span> (heap.<span class="hljs-built_in">count</span>(r)) <span class="hljs-keyword">return</span> &#123;heap[r], i&#125;;<br>            heap[nums[i]] = i;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/problem/content/2326/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-2-两数相加"><a href="#LeetCode-2-两数相加" class="headerlink" title="LeetCode 2. 两数相加"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/add-two-numbers/">LeetCode 2. 两数相加</a></h3><hr>
<h4 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h4><p><strong>模拟题</strong>，思路就是模拟大数相加 基本的列竖式流程</p>
<p>所以主要注意模拟竖式相加的关键点</p>
<ol>
<li>低位开始逐位相加，有进位或是数位还存在，继续相加</li>
<li>利用模表示数位，除10表示进位</li>
<li>链表返回一般就是返回head，如果边界为空不能返回head，所以需要特判头节点</li>
<li>需要特判头节点，可以加入dummy节点，简化边界，统一返回dummy-&gt;next</li>
</ol>
<p>时间复杂度：$O(n)$ （两个序列都只扫描一遍）<br><br></p>
<h4 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>), cur = dummy;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (l1 || l2 || t) &#123;<br>            <span class="hljs-keyword">if</span> (l1) t += l1-&gt;val, l1 = l1-&gt;next;<br>            <span class="hljs-keyword">if</span> (l2) t += l2-&gt;val, l2 = l2-&gt;next;<br>            cur = cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(t % <span class="hljs-number">10</span>);<br>            t /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-1"><a href="#Reference-1" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/problem/content/2327/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-3-无重复字符的最长子串"><a href="#LeetCode-3-无重复字符的最长子串" class="headerlink" title="LeetCode 3. 无重复字符的最长子串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">LeetCode 3. 无重复字符的最长子串</a></h3><hr>
<h4 id="基本思路-2"><a href="#基本思路-2" class="headerlink" title="基本思路"></a>基本思路</h4><p>朴素做法，枚举起点和终点，得到所有子串，所以很容易想到双指针优化</p>
<ol>
<li><p>暴力枚举<br>枚举子串的终点和起点$O(n^2)$, 得到所有的子串，然后每个子串判断合法(无重复)，拿到最大的无重复子串$O(n)$<br>时间复杂度：$O(n^3)$</p>
</li>
<li><p>双指针优化<br>发现了终点指针和起点指针的单调性，枚举新的终点指针（指针右移），为了满足合法的性质（最长不重复子串），起点指针不能左移，所以发现单调性，可以利用双指针优化。然后注意可以用哈希表维护指针内部的这段区间，判断是否无重复。<br>时间复杂度：$O(n)$<br>空间复杂度：$O(n)$</p>
</li>
</ol>
<h4 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1 - TLE
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// brute force </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">unique</span><span class="hljs-params">(string &amp;s, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; heap;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= r; i++ )<br>        &#123;<br>            <span class="hljs-keyword">if</span> (heap.<span class="hljs-built_in">count</span>(s[i])) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            heap[s[i]]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>     <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++ )<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j++ )<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">unique</span>(s, j, i)) res = <span class="hljs-built_in">max</span>(res, i - j + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路2 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//哈希表涉及到删除： 1. 用count（看key），必须配套用erase   2. 用heap[] &gt;= 1 （看value），必须用heap[]-- 不要混用！</span><br><span class="hljs-comment">//注意哈希表的操作需要统一，如果是针对key的那就统一用count，erase； 如果是针对value的那就不能用key的操作去判断</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i ++ ) &#123;<br>            hash[s[i]] ++ ;<br>            <span class="hljs-keyword">while</span> (hash[s[i]] &gt; <span class="hljs-number">1</span>) hash[s[j ++ ]] -- ;<br>            res = <span class="hljs-built_in">max</span>(res, i - j + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-2"><a href="#Reference-2" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/problem/content/2328/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-5-最长回文子串"><a href="#LeetCode-5-最长回文子串" class="headerlink" title="LeetCode 5. 最长回文子串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-substring/">LeetCode 5. 最长回文子串</a></h3><hr>
<h4 id="基本思路-3"><a href="#基本思路-3" class="headerlink" title="基本思路"></a>基本思路</h4><p>朴素做法，枚举起点和终点得到所有子串，然后判断回文，这显然会超时<br>所以想办法优化，利用回文的性质，枚举子串的中点，然后中心扩展得到回文串</p>
<ol>
<li><p>暴力枚举<br>枚举子串的终点和起点$O(n^2)$, 得到所有的子串，然后每个子串判断合法(回文)，拿到最长回文子串$O(n)$<br>时间复杂度：$O(n^3)$</p>
</li>
<li><p>中心暴力枚举<br>因为暴力枚举，所以尝试用双指针优化，发现指针之间并无单调性，所以无法用常规的双指针算法，那么就观察回文串的一些性质，尝试用性质去解题，这里利用回文串中心对称的特点，先枚举回文串中心（分奇偶），然后两个指针从中心向外扩展判合法<br>时间复杂度：$O(n^2)$</p>
</li>
<li><p>动态规划<br>最优化问题，可以尝试用动态规划去做，目前不是很熟练（以后填坑）</p>
</li>
</ol>
<h4 id="参考代码-3"><a href="#参考代码-3" class="headerlink" title="参考代码"></a>参考代码</h4><hr>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1 - TLE
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">palindrome</span> <span class="hljs-params">(string &amp;s, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = j, r = i; l &lt;= r; l++, r-- ) <span class="hljs-keyword">if</span> (s[l] != s[r]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>, len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i ++ )<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j++ )<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">palindrome</span>(s, j, i) &amp;&amp; i - j + <span class="hljs-number">1</span>&gt; len) <br>                    l = j, r = i, len = i - j + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">substr</span>(l, len);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路2 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        string res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i ++ ) &#123;<br>            <span class="hljs-type">int</span> l = i - <span class="hljs-number">1</span>, r = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (l &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[l] == s[r]) l --, r ++ ;<br>            <span class="hljs-keyword">if</span> (res.<span class="hljs-built_in">size</span>() &lt; r - l - <span class="hljs-number">1</span>) res = s.<span class="hljs-built_in">substr</span>(l + <span class="hljs-number">1</span>, r - l - <span class="hljs-number">1</span>);<br><br>            l = i, r = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (l &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[l] == s[r]) l --, r ++ ;<br>            <span class="hljs-keyword">if</span> (res.<span class="hljs-built_in">size</span>() &lt; r - l - <span class="hljs-number">1</span>) res = s.<span class="hljs-built_in">substr</span>(l + <span class="hljs-number">1</span>, r - l - <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-3"><a href="#Reference-3" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/problem/content/2330/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-6-Z-字形变换"><a href="#LeetCode-6-Z-字形变换" class="headerlink" title="LeetCode 6. Z 字形变换"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zigzag-conversion/">LeetCode 6. Z 字形变换</a></h3><hr>
<h4 id="基本思路-4"><a href="#基本思路-4" class="headerlink" title="基本思路"></a>基本思路</h4><p>将Z形顺序的字符串按行输出，变换运算这种类型的题目第一反应<strong>模拟</strong>，或者寻找<strong>数学规律</strong></p>
<ol>
<li><p>模拟<br>创立一个行数组，最后就是输出每一行的字符串，所以我们只需要遍历这个字符串，然后模拟上下的过程，把每个字符填入正确的行里即可。<br>然后注意行为1，需要特判<br>时间复杂度：$O(n)$<br>空间复杂度：$O(n)$</p>
</li>
<li><p>数学规律<br>如果模拟没有发现思路，那么可以尝试暴力地去发现一些数学规律，利用通项打印每行的字符（所以去发现是否有等差或者等比的关系）画一画图，发现</p>
<ul>
<li>对于第一行和最后一行，是公差为2(n−1)的等差数列，首项是0和n−1；</li>
<li>对于第i行(0&lt;i&lt;n−1)，是两个公差为2(n−1)的等差数列交替排列，首项分别是i和2n−i−2，2n−i−2;<br>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</li>
</ul>
</li>
</ol>
<h4 id="参考代码-4"><a href="#参考代码-4" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1 - k
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">convert</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> numRows)</span> </span>&#123;       <br>        string res;<br>        <span class="hljs-keyword">if</span> (numRows == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> s;<br><br>        <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">rows</span><span class="hljs-params">(numRows)</span></span>;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, flag = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s) &#123;<br>            rows[i].<span class="hljs-built_in">push_back</span>(c);<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> || i == numRows - <span class="hljs-number">1</span>) flag = -flag;<br>            i += flag;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;row : rows) res += row;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路2 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">convert</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        string res;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> s;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) &#123;<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> || i == n - <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; s.<span class="hljs-built_in">size</span>(); j += <span class="hljs-number">2</span> * n - <span class="hljs-number">2</span>)<br>                    res += s[j];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i, k = <span class="hljs-number">2</span> * n - <span class="hljs-number">2</span> - i; j &lt; s.<span class="hljs-built_in">size</span>() || k &lt; s.<span class="hljs-built_in">size</span>(); j += <span class="hljs-number">2</span> * n - <span class="hljs-number">2</span>, k += <span class="hljs-number">2</span> * n - <span class="hljs-number">2</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (j &lt; s.<span class="hljs-built_in">size</span>()) res += s[j];<br>                    <span class="hljs-keyword">if</span> (k &lt; s.<span class="hljs-built_in">size</span>()) res += s[k];<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        自己的不优雅代码
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">convert</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> numRows)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = numRows;<br>        string rows[n];<br><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> s;<br><br>        <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>, flag = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i ++ ) &#123;<br>            <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>) &#123;<br>                rows[r++] += s[i];<br>                <span class="hljs-keyword">if</span> (r == n) &#123;<br>                    flag = <span class="hljs-number">1</span>;<br>                    r -= <span class="hljs-number">2</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">else</span> &#123;<br>                rows[r--] += s[i];<br>                <span class="hljs-keyword">if</span> (r == <span class="hljs-number">-1</span>) &#123;<br>                    flag = <span class="hljs-number">0</span>;<br>                    r += <span class="hljs-number">2</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        string res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) &#123;<br>            res += rows[i];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br><br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-4"><a href="#Reference-4" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/problem/content/2331/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-7-整数反转"><a href="#LeetCode-7-整数反转" class="headerlink" title="LeetCode 7. 整数反转"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-integer/">LeetCode 7. 整数反转</a></h3><hr>
<h4 id="基本思路-5"><a href="#基本思路-5" class="headerlink" title="基本思路"></a>基本思路</h4><p>整数反转，很容易联想到数学方式反转或者字符串方式反转</p>
<ol>
<li>数学方式反转<br>将原整数，从低位到高位逐位取出，然后在新整数里从高位到低位逐位插入。所以这里就是如何模拟取出和插入<ul>
<li>取出： <code>x % 10, x / 10</code> 取出最低位然后删除最低位，循环取出</li>
<li>插入：<code>x * 10</code>空出新的低位</li>
<li>注意整数逆序后可能溢出，所以要用<code>INT_MAX，INT_MIN</code>判断，并且改变原式子的形式</li>
<li>一定要先空出低位再放入，否则最后会多个0，此题虽然思维简单但是还是难AC</li>
</ul>
</li>
</ol>
<p>时间复杂度：数字n，数字大约有$\log_{10}n$位。复杂度为$O(logn)$<br>空间复杂度：$O(1)$</p>
<br>

<h4 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (x) &#123;<br>            <span class="hljs-keyword">if</span> (r &gt; <span class="hljs-number">0</span> &amp;&amp; r &gt; (INT_MAX - x % <span class="hljs-number">10</span>) / <span class="hljs-number">10</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (r &lt; <span class="hljs-number">0</span> &amp;&amp; r &lt; (INT_MIN - x % <span class="hljs-number">10</span>) / <span class="hljs-number">10</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            r = r * <span class="hljs-number">10</span> + x % <span class="hljs-number">10</span>;<br>            x /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-5"><a href="#Reference-5" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/problem/content/2332/">[1]. yxc</a></p>
<br>


<h3 id="LeetCode-8-字符串转换整数-atoi"><a href="#LeetCode-8-字符串转换整数-atoi" class="headerlink" title="LeetCode 8. 字符串转换整数 (atoi)"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/string-to-integer-atoi/">LeetCode 8. 字符串转换整数 (atoi)</a></h3><hr>
<h4 id="基本思路-6"><a href="#基本思路-6" class="headerlink" title="基本思路"></a>基本思路</h4><p>字符串转整数，就是逐位判断。<br>本提复杂在把所有的情况考虑全，并且按照正确的顺序</p>
<ol>
<li>去除空格</li>
<li>判断正负号或者无符号</li>
<li>去除前导0</li>
<li>只加入数字，数字以外的字符就停止</li>
<li>如果溢出需要截断</li>
<li>注意负数恰好是INT_MIN的时候，无法用绝对值加上符号表示，因为溢出了</li>
</ol>
<p>关于第6点，可以这么考虑，对于正数 &gt; 2147483647截断了，&lt;&#x3D; 2147483647 绝对值用int存没有溢出；对于负数，&lt; -2147483648截断了，&gt;&#x3D; -2147483648的数里面 INTMIN的绝对值用INT存会溢出，所以需要特判</p>
<h4 id="参考代码-5"><a href="#参考代码-5" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        long long
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[i] == <span class="hljs-string">&#x27; &#x27;</span>) i ++;<br>        <span class="hljs-type">int</span> minus = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;-&#x27;</span>) i ++, minus = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;+&#x27;</span>) i ++;<br><br>        <span class="hljs-keyword">if</span> (s[i] &lt; <span class="hljs-string">&#x27;0&#x27;</span> || s[i] &gt; <span class="hljs-string">&#x27;9&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (i &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[i] == <span class="hljs-string">&#x27;0&#x27;</span>) i ++;<br><br>        <span class="hljs-keyword">while</span> (i &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span> &amp;&amp; res &lt; INT_MAX) res = res * <span class="hljs-number">10</span> + (s[i++] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>        res *= minus;<br>        <span class="hljs-keyword">if</span> (res &gt; INT_MAX) <span class="hljs-keyword">return</span> INT_MAX;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res &lt; INT_MIN) <span class="hljs-keyword">return</span> INT_MIN;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> res; <br>        &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        int
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[i] == <span class="hljs-string">&#x27; &#x27;</span>) i ++;<br>        <span class="hljs-type">int</span> minus = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;-&#x27;</span>) i ++, minus = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;+&#x27;</span>) i ++;<br><br>        <span class="hljs-keyword">if</span> (s[i] &lt; <span class="hljs-string">&#x27;0&#x27;</span> || s[i] &gt; <span class="hljs-string">&#x27;9&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (i &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[i] == <span class="hljs-string">&#x27;0&#x27;</span>) i ++;<br><br>        <span class="hljs-keyword">while</span> (i &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>            <span class="hljs-type">int</span> x = s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (minus &gt; <span class="hljs-number">0</span> &amp;&amp; res &gt; (INT_MAX - x) / <span class="hljs-number">10</span>) <span class="hljs-keyword">return</span> INT_MAX;<br>            <span class="hljs-keyword">if</span> (minus &lt; <span class="hljs-number">0</span> &amp;&amp; -res &lt; (INT_MIN + x) / <span class="hljs-number">10</span>) <span class="hljs-keyword">return</span> INT_MIN;<br>            <br>            <span class="hljs-keyword">if</span> (-res * <span class="hljs-number">10</span> - x == INT_MIN) <span class="hljs-keyword">return</span> INT_MIN;<br>            <br>            res = res * <span class="hljs-number">10</span> + x;<br>            i ++;<br>        &#125;<br>        res *= minus;<br>        <span class="hljs-keyword">return</span> res; <br>        &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-6"><a href="#Reference-6" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/339980/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-9-回文数"><a href="#LeetCode-9-回文数" class="headerlink" title="LeetCode 9. 回文数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-number/">LeetCode 9. 回文数</a></h3><hr>
<p>判断回文数，抓住回文数的性质，即反转前后相等<br>这里其实难点在于整数的反转，所以如果一时之间想不起来整数反转，可以转化为字符串反转</p>
<h4 id="基本思路-7"><a href="#基本思路-7" class="headerlink" title="基本思路"></a>基本思路</h4><ol>
<li><p>字符串反转<br>首先转化成字符串，然后直接通过函数反转,注意reverse函数的时间复杂度<br>时间复杂度：$O(logn)$ (数字n，数字位数logn，因为reverse函数)</p>
</li>
<li><p>数学方式反转<br>参考整数反转一题no.7，注意反转后的数可能溢出，用longlong表示<br>时间复杂度：$O(logn)$</p>
</li>
</ol>
<h4 id="参考代码-6"><a href="#参考代码-6" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        string s = <span class="hljs-built_in">to_string</span>(x);<br>        <span class="hljs-keyword">return</span> s == <span class="hljs-built_in">string</span>(s.<span class="hljs-built_in">rbegin</span>(), s.<span class="hljs-built_in">rend</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路2 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> y = x;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (x) &#123;<br>            res = res * <span class="hljs-number">10</span> + x % <span class="hljs-number">10</span>;<br>            x /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res == y;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-7"><a href="#Reference-7" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/problem/content/2334/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-11-盛最多水的容器"><a href="#LeetCode-11-盛最多水的容器" class="headerlink" title="LeetCode 11. 盛最多水的容器"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/container-with-most-water/">LeetCode 11. 盛最多水的容器</a></h3><hr>
<h4 id="基本思路-8"><a href="#基本思路-8" class="headerlink" title="基本思路"></a>基本思路</h4><p>首先想到朴素做法，枚举左右两个板，但是观察数据范围肯定会超时，所以想办法优化<br>常规双指针优化，指针之间没有单调性无法优化，但是根据短板性质，我们可以只有移动短板才有可能变大，所以枚举这些可能变大的组合，然后记录最大值</p>
<ol>
<li><p>暴力枚举<br>枚举左直线和右直线$O(n^2)$，每组直线计算面积$O(1)$<br>本质：枚举所有的组合，每次记录最大值<br>时间复杂度：$O(n^2)$</p>
</li>
<li><p>双指针+贪心<br>对于暴力枚举的题目，第一反应用双指针优化（裁剪搜索空间），尝试探索指针之间的单调性，发现两个指针没有单调性，所以不是常规的双指针解法（即顺序枚举一个指针，然后根据单调性不回退地移动另一个指针），但是这道题目因为<strong>性质</strong>（让两直线初始位于左右两侧，木桶容量由短板决定, 移动长板的话, 水面高度不可能再上升, 而宽度变小了, 所以只有通过移动短板, 才有可能使水位上升）所以利用贪心，非顺序性移动指针求解（本质也是裁剪搜索空间）<br>本质：利用贪心，枚举可能变大的组合，每次记录最大值<br>时间复杂度：$O(n)$</p>
</li>
</ol>
<h4 id="参考代码-7"><a href="#参考代码-7" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1 - TLE
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height.<span class="hljs-built_in">size</span>(); i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; height.<span class="hljs-built_in">size</span>(); j ++)<br>                res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">min</span>(height[i], height[j]) * (j - i));<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路2
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = height.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &lt; j;) &#123;<br>            res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">min</span>(height[i], height[j]) * (j - i));<br>            <span class="hljs-keyword">if</span> (height[i] &gt; height[j]) j -- ;<br>            <span class="hljs-keyword">else</span> i ++ ;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-8"><a href="#Reference-8" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/problem/content/2344/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-12-整数转罗马数字"><a href="#LeetCode-12-整数转罗马数字" class="headerlink" title="LeetCode 12. 整数转罗马数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/integer-to-roman/">LeetCode 12. 整数转罗马数字</a></h3><hr>
<h4 id="基本思路-9"><a href="#基本思路-9" class="headerlink" title="基本思路"></a>基本思路</h4><p>将阿拉伯数字转化为罗马数字，类似于钞票问题，找到基本单位，然后由大到小</p>
<ol>
<li><p>暴力匹配<br>直接把每个数字在每个位上的表示形式，整理成一张硬编码表,然后暴力匹配每一位<br>技巧：数位是从1开始，下标是从0开始，所以将下标0空出来，就可以一致简化<br>时间复杂度：$O(1)$ 计算量与输入数字的大小无关。<br>空间复杂度：$O(1)$</p>
</li>
<li><p>贪心<br>罗马数字的设计初衷就是要<strong>字符尽可能的少</strong>（联想到找零钱问题：尽量选择面值大的纸币（硬币）给顾客，这样才会使得给顾客的纸币（硬币）张数最少），所以用这题可以用贪心，<strong>尽可能先选出大的数字进行转换。</strong><br>技巧：抓住基本单位，也就是1，4，5，9，10 …<br>时间复杂度：$O(1)$ 计算量与输入位数有关<br>空间复杂度：$O(1)$</p>
</li>
</ol>
<h4 id="参考代码-8"><a href="#参考代码-8" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">intToRoman</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        string I[] = &#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;I&quot;</span>, <span class="hljs-string">&quot;II&quot;</span>, <span class="hljs-string">&quot;III&quot;</span>, <span class="hljs-string">&quot;IV&quot;</span>, <span class="hljs-string">&quot;V&quot;</span>, <span class="hljs-string">&quot;VI&quot;</span>, <span class="hljs-string">&quot;VII&quot;</span>, <span class="hljs-string">&quot;VIII&quot;</span>, <span class="hljs-string">&quot;IX&quot;</span>&#125;;<br>        string X[] = &#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;X&quot;</span>, <span class="hljs-string">&quot;XX&quot;</span>, <span class="hljs-string">&quot;XXX&quot;</span>, <span class="hljs-string">&quot;XL&quot;</span>, <span class="hljs-string">&quot;L&quot;</span>, <span class="hljs-string">&quot;LX&quot;</span>, <span class="hljs-string">&quot;LXX&quot;</span>, <span class="hljs-string">&quot;LXXX&quot;</span>, <span class="hljs-string">&quot;XC&quot;</span>&#125;;<br>        string C[] = &#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;CC&quot;</span>, <span class="hljs-string">&quot;CCC&quot;</span>, <span class="hljs-string">&quot;CD&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;DC&quot;</span>, <span class="hljs-string">&quot;DCC&quot;</span>, <span class="hljs-string">&quot;DCCC&quot;</span>, <span class="hljs-string">&quot;CM&quot;</span>&#125;;<br>        string M[] = &#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;M&quot;</span>, <span class="hljs-string">&quot;MM&quot;</span>, <span class="hljs-string">&quot;MMM&quot;</span>&#125;;<br><br>        <span class="hljs-keyword">return</span> M[num / <span class="hljs-number">1000</span>] + C[(num % <span class="hljs-number">1000</span>) / <span class="hljs-number">100</span>] + X[(num % <span class="hljs-number">100</span>) / <span class="hljs-number">10</span>] + I[num % <span class="hljs-number">10</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路2
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">intToRoman</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-type">int</span> values[] = &#123;<br>            <span class="hljs-number">1000</span>,<br>            <span class="hljs-number">900</span>, <span class="hljs-number">500</span>, <span class="hljs-number">400</span>, <span class="hljs-number">100</span>,<br>            <span class="hljs-number">90</span>, <span class="hljs-number">50</span>, <span class="hljs-number">40</span>, <span class="hljs-number">10</span>,<br>            <span class="hljs-number">9</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span><br>        &#125;;<br>        string reps[] = &#123;<br>            <span class="hljs-string">&quot;M&quot;</span>,<br>            <span class="hljs-string">&quot;CM&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;CD&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>,<br>            <span class="hljs-string">&quot;XC&quot;</span>, <span class="hljs-string">&quot;L&quot;</span>, <span class="hljs-string">&quot;XL&quot;</span>, <span class="hljs-string">&quot;X&quot;</span>,<br>            <span class="hljs-string">&quot;IX&quot;</span>, <span class="hljs-string">&quot;V&quot;</span>, <span class="hljs-string">&quot;IV&quot;</span>, <span class="hljs-string">&quot;I&quot;</span>,<br>        &#125;;<br><br>        string res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">13</span>; i ++ ) &#123; <span class="hljs-comment">//贪心，从面值大的开始拼</span><br>            <span class="hljs-keyword">while</span> (num &gt;= values[i]) &#123; <span class="hljs-comment">//注意是&gt;=!!!!!!</span><br>                num -= values[i];<br>                res += reps[i];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-9"><a href="#Reference-9" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/346728/">[1]. yxc</a></p>
<br>


<h3 id="LeetCode-13-罗马数字转整数"><a href="#LeetCode-13-罗马数字转整数" class="headerlink" title="LeetCode 13. 罗马数字转整数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/roman-to-integer/">LeetCode 13. 罗马数字转整数</a></h3><hr>
<h4 id="基本思路-10"><a href="#基本思路-10" class="headerlink" title="基本思路"></a>基本思路</h4><p>将罗马数字转化为阿拉伯数字，就是<strong>每个字符转换</strong><br>直接暴力匹配罗马数字的每一位，然后根据题目的提示信息按照固定规则进行转换</p>
<ul>
<li>通常情况：左边的字符 &gt; 右边字符 例如“XVI” &#x3D; 10（X）+5（V）+1（I）</li>
<li>特殊情况：左边的字符 &lt; 右边字符 根据规则需要减去小的数字(即将该数字的符号取反) XIV &#x3D; 10 (X) -1 (I)+5 (V) &#x3D; 14<br>所以直接遍历所有字符，判断当前字符与右边字符的关系，决定符号+ -</li>
</ul>
<h4 id="参考代码-9"><a href="#参考代码-9" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">romanToInt</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; hash;<br>        hash[<span class="hljs-string">&#x27;I&#x27;</span>] = <span class="hljs-number">1</span>, hash[<span class="hljs-string">&#x27;V&#x27;</span>] = <span class="hljs-number">5</span>;<br>        hash[<span class="hljs-string">&#x27;X&#x27;</span>] = <span class="hljs-number">10</span>, hash[<span class="hljs-string">&#x27;L&#x27;</span>] = <span class="hljs-number">50</span>;<br>        hash[<span class="hljs-string">&#x27;C&#x27;</span>] = <span class="hljs-number">100</span>, hash[<span class="hljs-string">&#x27;D&#x27;</span>] = <span class="hljs-number">500</span>;<br>        hash[<span class="hljs-string">&#x27;M&#x27;</span>] = <span class="hljs-number">1000</span>;<br><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i ++ ) &#123;<br>            <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; hash[s[i]] &lt; hash[s[i + <span class="hljs-number">1</span>]]) <span class="hljs-comment">//注意越界，虽然不加也可以AC但是养成好习惯</span><br>                res -= hash[s[i]];<br>            <span class="hljs-keyword">else</span><br>                res += hash[s[i]];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-10"><a href="#Reference-10" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/346746/">[1]. yxc</a></p>
<BR>

<h3 id="LeetCode-14-最长公共前缀"><a href="#LeetCode-14-最长公共前缀" class="headerlink" title="LeetCode 14. 最长公共前缀"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-prefix/">LeetCode 14. 最长公共前缀</a></h3><hr>
<h4 id="基本思路-11"><a href="#基本思路-11" class="headerlink" title="基本思路"></a>基本思路</h4><p>思路很简单，对每个字符串进行逐位检查，直到不满足公共前缀<br>两重循环，首先拿到第一个字符串的第i位，然后再拿到其余字符串的第i位<br>字符串的题目经常为空，注意越界, 然后string.size()是一个unsigned int，所以如果为0的时候减1就会溢出，所以必须用i &gt;&#x3D; s.size() 不能是 i &gt; s.size() - 1;</p>
<h4 id="参考代码-10"><a href="#参考代码-10" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        代码 -yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;<br>        string res;<br>        <span class="hljs-keyword">if</span> (strs.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> res;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;; i ++ ) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt;= strs[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> res;<br>            <span class="hljs-type">char</span> c = strs[<span class="hljs-number">0</span>][i];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; str: strs)<br>                <span class="hljs-keyword">if</span> (str.<span class="hljs-built_in">size</span>() &lt;= i || str[i] != c)<br>                    <span class="hljs-keyword">return</span> res;<br>            res += c;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-11"><a href="#Reference-11" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/346760/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-15-三数之和"><a href="#LeetCode-15-三数之和" class="headerlink" title="LeetCode 15. 三数之和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/3sum/">LeetCode 15. 三数之和</a></h3><hr>
<h4 id="基本思路-12"><a href="#基本思路-12" class="headerlink" title="基本思路"></a>基本思路</h4><p>首先暴力枚举$O(n^3)$肯定会超时，所以想办法优化，这里直接排序得到单调性，然后枚举一个指针，然后另外两个指针双指针优化<br>但是本题目的难点在于去重，去重的几个要点</p>
<ol>
<li>如果指针的指向值和上一轮指针指向的值一样跳过，达到去重的效果</li>
<li>指针i，j的去重比较简单，因为i，j每一轮只移动一格，所以上一轮的话直接比较i - 1 和 j - 1（注意和上一轮比较的前提是这两个指针存在移动，如果不存在移动，那么-1访问的并不是上一轮的i，j，就会错误答案</li>
<li>指针k，如果常规双指针做法，每轮会移动若干格，所以这里我们直接用k - 1试探法找到最左边的k，这样就可以达到去重k的效果，这一步也是最难的一点</li>
</ol>
<p>时间复杂度：$O(n^2)$</p>
<h4 id="参考代码-11"><a href="#参考代码-11" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        代码 -yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-comment">// 枚举i，然后j和k双指针，保证i &lt; j &lt; k</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-comment">// 防止重复，如果和上一轮的一样就跳过</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>, k = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; j &lt; k; j ++) &#123;<br>                <span class="hljs-comment">// 如果j和上一轮的一样也跳过</span><br>                <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-comment">// 找到满足三个数相加大于等于0的最小的k</span><br>                <span class="hljs-keyword">while</span> (j &lt; k - <span class="hljs-number">1</span> &amp;&amp; nums[i] + nums[j] + nums[k - <span class="hljs-number">1</span>] &gt;= <span class="hljs-number">0</span>) k --;<br>                <span class="hljs-comment">// 如果相加是0就记录</span><br>                <span class="hljs-keyword">if</span> (nums[i] + nums[j] + nums[k] == <span class="hljs-number">0</span>)<br>                    res.<span class="hljs-built_in">push_back</span>(&#123;nums[i], nums[j], nums[k]&#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-12"><a href="#Reference-12" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/346791/">[1]. yxc k - 1 试探法</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/544218/">[2]. LauZyHou</a></p>
<br>

<h3 id="LeetCode-16-最接近的三数之和"><a href="#LeetCode-16-最接近的三数之和" class="headerlink" title="LeetCode 16. 最接近的三数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum-closest/">LeetCode 16. 最接近的三数之和</a></h3><hr>
<h4 id="基本思路-13"><a href="#基本思路-13" class="headerlink" title="基本思路"></a>基本思路</h4><p>和三数之和很像，但是这里是求和而不是求方案，所以不需要去重，然后因为是最接近target的，所以有两种情况，大于等于target和小于等于target<br>其中小等于的情况，在得到大于等于target的情况后，直接再减1就得到了<br>然后也是要特别注意越界问题 以及 while的判断里有两个条件，循环退出时有可能是第一个条件不满足。</p>
<h4 id="参考代码-12"><a href="#参考代码-12" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        yxc use Pair
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">threeSumClosest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-function">pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(INT_MAX, INT_MAX)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++ )<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>, k = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; j &lt; k; j ++ ) &#123;<br>                <span class="hljs-keyword">while</span> (k - <span class="hljs-number">1</span> &gt; j &amp;&amp; nums[i] + nums[j] + nums[k - <span class="hljs-number">1</span>] &gt;= target) k -- ;<br>                <span class="hljs-type">int</span> s = nums[i] + nums[j] + nums[k];<br>                res = <span class="hljs-built_in">min</span>(res, &#123;<span class="hljs-built_in">abs</span>(s - target), s&#125;);<br>                <span class="hljs-keyword">if</span> (k - <span class="hljs-number">1</span> &gt; j) &#123;<br>                    s = nums[i] + nums[j] + nums[k - <span class="hljs-number">1</span>];<br>                    res = <span class="hljs-built_in">min</span>(res, &#123;target - s, s&#125;);<br>                &#125;<br>            &#125;<br>        <span class="hljs-keyword">return</span> res.second;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        no use Pair
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">threeSumClosest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> diff = <span class="hljs-number">0x3f3f3f3f</span>;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++ ) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>, k = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; j &lt; k; j ++) &#123;<br>                <span class="hljs-keyword">while</span> (k - <span class="hljs-number">1</span> &gt; j &amp;&amp; nums[i] + nums[j] + nums[k - <span class="hljs-number">1</span>] &gt;= target) k--;<br>                <span class="hljs-type">int</span> s = nums[i] + nums[j] + nums[k];<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(s - target) &lt; diff) res = s, diff = <span class="hljs-built_in">abs</span>(s - target);<br><br>                <span class="hljs-keyword">if</span> (k - <span class="hljs-number">1</span> &gt; j) &#123;<br>                    s = nums[i] + nums[j] + nums[k - <span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span> (target - s &lt; diff) res = s, diff = target - s; <br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-13"><a href="#Reference-13" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/346800/">[1]. yxc</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/64/">[2]. while</a></p>
<br>

<h3 id="LeetCode-17-电话号码的字母组合"><a href="#LeetCode-17-电话号码的字母组合" class="headerlink" title="LeetCode 17. 电话号码的字母组合"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">LeetCode 17. 电话号码的字母组合</a></h3><hr>
<h4 id="基本思路-14"><a href="#基本思路-14" class="headerlink" title="基本思路"></a>基本思路</h4><p>找到所有组合方案，相当于找到所有分支，所以回溯角度的DFS<br>然后题目中有个表的关系，我们可以建表，这里key是int，所以直接用vector存表<br>然后回溯角度的DFS就是思考每层需要存什么（DFS返回值，DFS参数），当前分支需要存什么（DFS参数），然后其实对于回溯角度的DFS就采用自己总结的那一套统一的写法</p>
<h4 id="参考代码-13"><a href="#参考代码-13" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        yxc - array
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; ans;<br>    string strs[<span class="hljs-number">10</span>] = &#123;<br>        <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>,<br>        <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>,<br>        <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>,<br>    &#125;;<br><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(string digits)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (digits.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-built_in">dfs</span>(digits, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string&amp; digits, <span class="hljs-type">int</span> u, string path)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (u == digits.<span class="hljs-built_in">size</span>()) ans.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : strs[digits[u] - <span class="hljs-string">&#x27;0&#x27;</span>])<br>                <span class="hljs-built_in">dfs</span>(digits, u + <span class="hljs-number">1</span>, path + c);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        unordered_map
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; res;<br>    vector&lt;string&gt; table = &#123;<span class="hljs-string">&quot;*&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>&#125;;<br>    string path;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(string digits)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!digits.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> &#123;&#125;;<br>        <span class="hljs-built_in">dfs</span>(digits, <span class="hljs-number">0</span>, path);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string&amp; digits, <span class="hljs-type">int</span> u, string path)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (u == digits.<span class="hljs-built_in">size</span>()) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        string a = table[digits[u] - <span class="hljs-string">&#x27;0&#x27;</span>];<br>        <span class="hljs-comment">// cout &lt;&lt; a &lt;&lt; endl;</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-built_in">size</span>(); i ++ ) &#123;<br>            <span class="hljs-comment">// path.push_back(a[i]);</span><br>            <span class="hljs-built_in">dfs</span>(digits, u + <span class="hljs-number">1</span>, path + a[i]);<br>            <span class="hljs-comment">// path.pop_back();</span><br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-14"><a href="#Reference-14" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/346821/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-18-四数之和"><a href="#LeetCode-18-四数之和" class="headerlink" title="LeetCode 18. 四数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum/">LeetCode 18. 四数之和</a></h3><hr>
<h4 id="基本思路-15"><a href="#基本思路-15" class="headerlink" title="基本思路"></a>基本思路</h4><p>与三数之和类似，注意几个点</p>
<ol>
<li>去重</li>
<li>四数相加可能会溢出</li>
</ol>
<h4 id="参考代码-14"><a href="#参考代码-14" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">fourSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a = <span class="hljs-number">0</span>; a &lt; nums.<span class="hljs-built_in">size</span>(); a ++ ) &#123;<br>            <span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">0</span> &amp;&amp; nums[a] == nums[a - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b = a + <span class="hljs-number">1</span>; b &lt; nums.<span class="hljs-built_in">size</span>(); b ++ ) &#123;<br>                <span class="hljs-keyword">if</span> (b &gt; a + <span class="hljs-number">1</span> &amp;&amp; nums[b] == nums[b - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c = b + <span class="hljs-number">1</span>, d = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; c &lt; d; c ++ ) &#123;<br>                    <span class="hljs-keyword">if</span> (c &gt; b + <span class="hljs-number">1</span> &amp;&amp; nums[c] == nums[c - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>                    <span class="hljs-keyword">while</span> (d - <span class="hljs-number">1</span> &gt; c &amp;&amp; nums[a] + nums[b] &gt;= (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)target - nums[c] - nums[d - <span class="hljs-number">1</span>]) d--;<br>                    <span class="hljs-keyword">if</span> (nums[a] + nums[b] == (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)target - nums[c] - nums[d]) <br>                        res.<span class="hljs-built_in">push_back</span>(&#123;nums[a], nums[b], nums[c], nums[d]&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-15"><a href="#Reference-15" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/346837/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-19-删除链表的倒数第-N-个节点"><a href="#LeetCode-19-删除链表的倒数第-N-个节点" class="headerlink" title="LeetCode 19. 删除链表的倒数第 N 个节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">LeetCode 19. 删除链表的倒数第 N 个节点</a></h3><hr>
<h4 id="基本思路-16"><a href="#基本思路-16" class="headerlink" title="基本思路"></a>基本思路</h4><p>链表的题目，思路比较直接，要删除倒数第n个节点，首先得找到这个节点的前一个节点，然后就是常规删除操作<br>注意：</p>
<ol>
<li>这里涉及到头节点删除，所以最好建一个虚拟头节点，方便操作</li>
<li>然后就是如何求链表的长度，就是遍历一遍链表（非空 size++），如果是从dummy节点开始遍历的，多了一个虚拟头节点，所以-1以后才是链表的长度</li>
<li>跳的次数 其实 就是边的个数 所以 从dummy第 0 个节点 移动到 第size - n个节点（这就是倒数第n个节点的前一个节点），总共跳了size - n次</li>
</ol>
<h4 id="参考代码-15"><a href="#参考代码-15" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>); dummy-&gt;next = head;<br>        <span class="hljs-type">int</span> size = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = head; p; p = p-&gt;next) size++;<br><br>        <span class="hljs-keyword">auto</span> p = dummy;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size - n; i ++) p = p-&gt;next;<br><br>        p-&gt;next = p-&gt;next-&gt;next;<br><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-16"><a href="#Reference-16" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/346852/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-20-有效的括号"><a href="#LeetCode-20-有效的括号" class="headerlink" title="LeetCode 20. 有效的括号"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses/">LeetCode 20. 有效的括号</a></h3><hr>
<h4 id="基本思路-17"><a href="#基本思路-17" class="headerlink" title="基本思路"></a>基本思路</h4><p>从题意我们可以知道，先出现的左括号配对的右括号在最后，所以很明显我们需要用一个栈来维护，栈里面只存左括号<br>如果是左括号就压栈，如果是右括号就判断是否和栈顶的左括号是否匹配，匹配那就弹出，不匹配说明已经非法了直接return false<br>最后如果栈为空return true 否则 return false</p>
<p>如何判断 右括号是否和栈顶的左括号匹配，这里有很多种方法，我的常规做法是开一个哈希表去匹配，同时也可以利用ASCII码简化代码</p>
<h4 id="参考代码-16"><a href="#参考代码-16" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">char</span>&gt; stk;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : s) &#123;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span> || c == <span class="hljs-string">&#x27;[&#x27;</span> || c == <span class="hljs-string">&#x27;&#123;&#x27;</span>) stk.<span class="hljs-built_in">push</span>(c);<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (stk.<span class="hljs-built_in">size</span>() &amp;&amp; <span class="hljs-built_in">abs</span>(stk.<span class="hljs-built_in">top</span>() - c) &lt;= <span class="hljs-number">2</span>) stk.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> stk.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        first code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">char</span>&gt; stk;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; hash = &#123;&#123;<span class="hljs-string">&#x27;(&#x27;</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-string">&#x27;)&#x27;</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-string">&#x27;&#123;&#x27;</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-string">&#x27;&#125;&#x27;</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-string">&#x27;[&#x27;</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-string">&#x27;]&#x27;</span>, <span class="hljs-number">3</span>&#125;&#125;;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i ++ ) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;(&#x27;</span> || s[i] == <span class="hljs-string">&#x27;[&#x27;</span> || s[i] == <span class="hljs-string">&#x27;&#123;&#x27;</span>) &#123;<br>                stk.<span class="hljs-built_in">push</span>(s[i]);<br>            &#125;<br><br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (stk.<span class="hljs-built_in">size</span>() &amp;&amp; hash[stk.<span class="hljs-built_in">top</span>()] == hash[s[i]]) stk.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (stk.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-17"><a href="#Reference-17" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/346874/">[1]. yxc</a></p>
<br>


<h3 id="LeetCode-21-合并两个有序链表"><a href="#LeetCode-21-合并两个有序链表" class="headerlink" title="LeetCode 21. 合并两个有序链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-sorted-lists/">LeetCode 21. 合并两个有序链表</a></h3><hr>
<h4 id="基本思路-18"><a href="#基本思路-18" class="headerlink" title="基本思路"></a>基本思路</h4><p>基础算法，<strong>二路归并</strong>,三个指针，两个指针指向原序列起点，一个指针指向新序列起点<br>新的链表，旧的值，所以不需要new每个节点</p>
<p>时间复杂度：$O(n)$</p>
<br>

<h4 id="参考代码-17"><a href="#参考代码-17" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        没有开辟空间
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>), tail = dummy;<br>        <span class="hljs-keyword">while</span> (l1 &amp;&amp; l2) &#123;<br>            <span class="hljs-keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) tail = tail-&gt;next = l1, l1 = l1-&gt;next;<br>            <span class="hljs-keyword">else</span> tail = tail-&gt;next = l2, l2 = l2-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (l1) tail-&gt;next = l1;<br>        <span class="hljs-keyword">if</span> (l2) tail-&gt;next = l2;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        开辟空间
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* list1, ListNode* list2)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>), tail = dummy;<br><br>        <span class="hljs-keyword">while</span> (list1 &amp;&amp; list2) &#123;<br>            <span class="hljs-keyword">if</span> (list1-&gt;val &lt; list2-&gt;val) tail = tail-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(list1-&gt;val), list1 = list1-&gt;next;<br>            <span class="hljs-keyword">else</span> tail = tail-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(list2-&gt;val), list2 = list2-&gt;next;<br>        &#125; <br><br>        <span class="hljs-keyword">while</span> (list1) tail = tail-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(list1-&gt;val), list1 = list1-&gt;next;<br>        <span class="hljs-keyword">while</span> (list2) tail = tail-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(list2-&gt;val), list2 = list2-&gt;next;<br><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-18"><a href="#Reference-18" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/347807/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-22-括号生成"><a href="#LeetCode-22-括号生成" class="headerlink" title="LeetCode 22. 括号生成"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/generate-parentheses/">LeetCode 22. 括号生成</a></h3><hr>
<h4 id="基本思路-19"><a href="#基本思路-19" class="headerlink" title="基本思路"></a>基本思路</h4><p>求所有方案，然后观察数据范围，很明显这道题目可以用DFS来做<br>然后对于括号问题，牢记<strong>两个性质</strong></p>
<ol>
<li>任意前缀中，左括号数量&gt;&#x3D;右括号数量</li>
<li>左右括号数量相等</li>
</ol>
<p>时间复杂度：复杂度为$O(C_{2n}^n)$,典型的卡特兰数问题。</p>
<br>

<h4 id="参考代码-18"><a href="#参考代码-18" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        代码 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    vector&lt;string&gt; ans;<br><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(n, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> lc, <span class="hljs-type">int</span> rc, string seq)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (lc == n &amp;&amp; rc == n) ans.<span class="hljs-built_in">push_back</span>(seq);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (lc &lt; n) <span class="hljs-built_in">dfs</span>(n, lc + <span class="hljs-number">1</span>, rc, seq + <span class="hljs-string">&#x27;(&#x27;</span>);<br>            <span class="hljs-keyword">if</span> (rc &lt; n &amp;&amp; lc &gt; rc) <span class="hljs-built_in">dfs</span>(n, lc, rc + <span class="hljs-number">1</span>, seq + <span class="hljs-string">&#x27;)&#x27;</span>);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        first
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; res;<br><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        string path;<br>        <span class="hljs-built_in">dfs</span>(n, <span class="hljs-number">0</span>, path);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> u, string path)</span> </span>&#123;<br>        <span class="hljs-type">static</span> <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (u == <span class="hljs-number">2</span>*n &amp;&amp; l == r) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (l &lt; n) &#123;<br>            l++;<br>            <span class="hljs-built_in">dfs</span>(n, u + <span class="hljs-number">1</span>, path + <span class="hljs-string">&#x27;(&#x27;</span>);<br>            l--;<br>        &#125;<br><br>        <br>        <span class="hljs-keyword">if</span> (r &lt; n &amp;&amp; l &gt; r) &#123;<br>            r ++;<br>            <span class="hljs-built_in">dfs</span>(n, u + <span class="hljs-number">1</span>, path + <span class="hljs-string">&#x27;)&#x27;</span>);<br>            r--;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-19"><a href="#Reference-19" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/347825/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-23-合并K个排序链表"><a href="#LeetCode-23-合并K个排序链表" class="headerlink" title="LeetCode 23. 合并K个排序链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-k-sorted-lists/">LeetCode 23. 合并K个排序链表</a></h3><hr>
<h4 id="基本思路-20"><a href="#基本思路-20" class="headerlink" title="基本思路"></a>基本思路</h4><p>多路归并，可以基于二路归并的思想来做（因为每个序列有序不需要用分治）<br>关键在于<strong>每次从k个列表的头节点里拿出最小值这个操作</strong></p>
<ol>
<li><p>直接遍历当前的k个节点，拿到最小值,这步的时间复杂度$O(k)$<br>时间复杂度：$O(nk)$ n为链表总长度<br>空间复杂度：$O(1)$</p>
</li>
<li><p>把k个节点放入小根堆中，这样拿到最小值的操作就可以优化成$O(k)$<br>用到priority_queue，注意默认是大根堆，我们重写小括号改成小根堆。<br>时间复杂度: $O(nlogk)$ n为链表总长度<br>空间复杂度：$O(k)$</p>
</li>
</ol>
<h4 id="参考代码-19"><a href="#参考代码-19" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1
    </div>
    <div class='spoiler-content'>
        <p>&#x2F;&#x2F;以后实现~</p>

    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路2 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cmp</span> &#123;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(ListNode* a, ListNode* b)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> a-&gt;val &gt; b-&gt;val;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, Cmp&gt; heap;<br>        <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>), tail = dummy;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> l : lists) <span class="hljs-keyword">if</span> (l) heap.<span class="hljs-built_in">push</span>(l);<br><br>        <span class="hljs-keyword">while</span> (heap.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> t = heap.<span class="hljs-built_in">top</span>();<br>            heap.<span class="hljs-built_in">pop</span>();<br><br>            tail = tail-&gt;next = t;<br>            <span class="hljs-keyword">if</span> (t-&gt;next) heap.<span class="hljs-built_in">push</span>(t-&gt;next);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>


<br>


<h3 id="LeetCode-24-两两交换链表中的节点"><a href="#LeetCode-24-两两交换链表中的节点" class="headerlink" title="LeetCode 24. 两两交换链表中的节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/swap-nodes-in-pairs/">LeetCode 24. 两两交换链表中的节点</a></h3><hr>
<h4 id="基本思路-21"><a href="#基本思路-21" class="headerlink" title="基本思路"></a>基本思路</h4><p>链表的题目，关键就是画图和思考流程</p>
<ol>
<li>是否需要虚拟头节点</li>
<li>需要哪些节点，怎么拿到这些节点</li>
<li>具体逻辑，注意next指针更改顺序</li>
<li>边界情况分析</li>
</ol>
<p>对于本题</p>
<ol>
<li>头节点可能会变，所以需要一个dummy虚拟头节点</li>
<li>首先交换相邻的两个节点，所以需要这两个节点，然后发现交换操作还需要用到前面的节点，一点一段的操作，外部拿到最前面的，然后循环拿到段内的</li>
<li>画画图分析，然后注意顺序</li>
<li>边界分析，要交换的两个节点必须存在才能操作</li>
</ol>
<p><img src="https://cdn.acwing.com/media/article/image/2020/10/29/29289_4cd0c9ec19-image-20201029145857313.png" srcset="/img/loading.gif" lazyload alt="示意图"></p>
<p>时间复杂度：$O(n)$，其中 n 是链表的节点数量。需要对每个节点进行更新指针的操作。<br>空间复杂度：$O(1)$<br><br></p>
<h4 id="参考代码-20"><a href="#参考代码-20" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        迭代
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        dummy-&gt;next = head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = dummy; p-&gt;next &amp;&amp; p-&gt;next-&gt;next;) &#123;<br>            <span class="hljs-keyword">auto</span> a = p-&gt;next, b = a-&gt;next;<br>            p-&gt;next = b;<br>            a-&gt;next = b-&gt;next;<br>            b-&gt;next = a;<br>            p = a;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        允许修改节点值
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>); dummy-&gt;next = head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = dummy; p-&gt;next &amp;&amp; p-&gt;next-&gt;next;) &#123;<br>            <span class="hljs-keyword">auto</span> a = p-&gt;next;<br>            <span class="hljs-keyword">auto</span> b = p-&gt;next-&gt;next;<br><br>            <span class="hljs-built_in">swap</span>(a-&gt;val, b-&gt;val);<br><br>            p = p-&gt;next-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-20"><a href="#Reference-20" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/347847/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-25-K-个一组翻转链表"><a href="#LeetCode-25-K-个一组翻转链表" class="headerlink" title="LeetCode 25. K 个一组翻转链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">LeetCode 25. K 个一组翻转链表</a></h3><hr>
<h4 id="基本思路-22"><a href="#基本思路-22" class="headerlink" title="基本思路"></a>基本思路</h4><h4 id="参考代码-21"><a href="#参考代码-21" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        迭代实现
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        dummy-&gt;next = head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = dummy; ;) &#123;<br>            <span class="hljs-comment">// 测试后面够不够k个点</span><br>            <span class="hljs-keyword">auto</span> q = p;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k &amp;&amp; q; i ++)<br>                q = q-&gt;next;<br>            <span class="hljs-keyword">if</span> (!q)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">// 至此，够k个，要两个两个一起翻转k-1次</span><br>            <span class="hljs-keyword">auto</span> a = p-&gt;next, b = a-&gt;next;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k - <span class="hljs-number">1</span>; i ++) &#123;<br>                <span class="hljs-comment">// 记录一下b后面的c，不然就找不到了</span><br>                <span class="hljs-keyword">auto</span> c = b-&gt;next;<br>                b-&gt;next = a; <span class="hljs-comment">// 反向</span><br>                a = b, b = c;<br>            &#125;<br>            <span class="hljs-comment">// 翻转完的部分连好</span><br>            <span class="hljs-keyword">auto</span> c = p-&gt;next;<br>            c-&gt;next = b, p-&gt;next = a;<br>            <span class="hljs-comment">// p往后走，做下一组</span><br>            p = c;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>


<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        递归实现
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode* head, ListNode* tail)</span>   <span class="hljs-comment">//反转链表模板，面试高频题</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode *pre = head, *cur = head-&gt;next;<br>        <span class="hljs-keyword">while</span> (cur != tail)<br>        &#123;<br>            ListNode* ne = cur-&gt;next;<br>            cur-&gt;next = pre;<br>            pre = cur, cur = ne;<br>        &#125;<br>        head-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> head;<br><br>        ListNode* tail = head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++ i)                <span class="hljs-comment">//遍历k个节点</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (tail == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> head;       <span class="hljs-comment">//不足k个节点则不反转，直接返回</span><br>            <span class="hljs-comment">//注意，如果这里面试官要求最后不足k个也要翻转，就得改成下面一行</span><br>            <span class="hljs-comment">//if (tail == nullptr) return reverse(head, tail);</span><br>            tail = tail-&gt;next;<br>        &#125;<br><br>        ListNode* newhead = <span class="hljs-built_in">reverse</span>(head, tail);    <span class="hljs-comment">//反转长度为k的链表</span><br>        head-&gt;next = <span class="hljs-built_in">reverseKGroup</span>(tail, k);        <span class="hljs-comment">//递归将下一段反转链表接到当前段的尾部</span><br><br>        <span class="hljs-keyword">return</span> newhead;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-21"><a href="#Reference-21" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/546128/">[1].  LauZyHou</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/23649/">[2].  cyb-包子</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/52340/">[3. 递归写法]</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/62619/">[4].  有心人</a></p>
<br>

<h3 id="LeetCode-26-删除排序数组中的重复项"><a href="#LeetCode-26-删除排序数组中的重复项" class="headerlink" title="LeetCode 26. 删除排序数组中的重复项"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">LeetCode 26. 删除排序数组中的重复项</a></h3><hr>
<h4 id="基本思路-23"><a href="#基本思路-23" class="headerlink" title="基本思路"></a>基本思路</h4><p>常规的<strong>数组操作题</strong><br><strong>删除重复项 &#x3D; 找到所有首次出现的数</strong>，怎么找到所有首次出现的数，这里是排序数组，所以相同的元素一定连在一起，那么如果<strong>当前的数 ！&#x3D; 前面的数，那就是首次的数</strong><br>很显然可以用双指针算法，一个指针遍历数组，一个指针记录合法的数（首次出现的数）<br>代码虽然很简单，但是要注意思维怎么来的。</p>
<p>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$<br><br></p>
<h4 id="参考代码-22"><a href="#参考代码-22" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        代码 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++ )<br>            <span class="hljs-keyword">if</span> (!i || nums[i] != nums[i - <span class="hljs-number">1</span>]) <span class="hljs-comment">//注意第一个元素会导致越界，所以先特判一下</span><br>                nums[k ++ ] = nums[i];<br>        <span class="hljs-keyword">return</span> k;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<br>

<h3 id="LeetCode-27-移除元素"><a href="#LeetCode-27-移除元素" class="headerlink" title="LeetCode 27. 移除元素"></a><a href="">LeetCode 27. 移除元素</a></h3><hr>
<h4 id="基本思路-24"><a href="#基本思路-24" class="headerlink" title="基本思路"></a>基本思路</h4><p>常规的<strong>数组操作题</strong><br><strong>移除元素，也就是找出所有不等于val的数</strong><br>很显然可以用双指针算法，一个指针遍历数组，一个指针记录合法的数（不等于val的数）<br>leetcode26 如出一辙 属于经典爽题</p>
<h4 id="参考代码-23"><a href="#参考代码-23" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        代码 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++ )<br>            <span class="hljs-keyword">if</span> (nums[i] != val)<br>                nums[k ++ ] = nums[i];<br>        <span class="hljs-keyword">return</span> k;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<BR>

<h3 id="LeetCode-31-下一个排列"><a href="#LeetCode-31-下一个排列" class="headerlink" title="LeetCode 31. 下一个排列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-permutation/">LeetCode 31. 下一个排列</a></h3><hr>
<h4 id="基本思路-25"><a href="#基本思路-25" class="headerlink" title="基本思路"></a>基本思路</h4><p><strong>数学规律题</strong> 个人认为这种题最折磨，思路很难搭上，要根据性质找到规律</p>
<p>如何找到下一个排列，首先观察下一个排列的<strong>性质</strong>：幅度最小的变大</p>
<p><strong>规律</strong>：就是<strong>不动高位，尽可能地在低位变大</strong>，然后将低位之后的数按照最小的顺序排列。按照这个思路我们数学模拟一下</p>
<ol>
<li><p>找到这个低位k<br>显然我们从低位往高位检查，<strong>不动高位的基础上，找到可以变大的第一个低位。所以第 k 位其实就是从低位到高位的第一个下降的数。</strong></p>
</li>
<li><p>低位k最小幅度变大<br>从 k 往后找，找到最小的比 k 要大的数，将两者交换。注意此时 k 以后的位置仍然是降序的</p>
</li>
<li><p>低位之后的数按照最小的顺序排列<br>直接将 k 以后的部分翻转（变为升序）</p>
</li>
</ol>
<h4 id="参考代码-24"><a href="#参考代码-24" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        代码
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> k = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span> &amp;&amp; nums[k - <span class="hljs-number">1</span>] &gt;= nums[k]) k -- ;<br>        <span class="hljs-keyword">if</span> (k &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> t = k;<br>            <span class="hljs-keyword">while</span> (t &lt; nums.<span class="hljs-built_in">size</span>() &amp;&amp; nums[t] &gt; nums[k - <span class="hljs-number">1</span>]) t ++ ;<br>            <span class="hljs-built_in">swap</span>(nums[t - <span class="hljs-number">1</span>], nums[k - <span class="hljs-number">1</span>]);<br>            <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>() + k, nums.<span class="hljs-built_in">end</span>());<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<br>

<h3 id="LeetCode-41-缺失的第一个正数"><a href="#LeetCode-41-缺失的第一个正数" class="headerlink" title="LeetCode 41. 缺失的第一个正数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/first-missing-positive/">LeetCode 41. 缺失的第一个正数</a></h3><h4 id="基本思路-26"><a href="#基本思路-26" class="headerlink" title="基本思路"></a>基本思路</h4><p>求解缺失的第一个正数，<strong>枚举题</strong>，从1开始枚举，找到缺失的第一个正数</p>
<ol>
<li><p>暴力枚举 + 哈希表<br>寻找一个数很容易联想到哈希表，从1开始枚举正整数，然后找这个数是否存在（利用哈希表），不存在就找到了这个缺失的第一个正整数。<br>时间复杂度：$O(n)$<br>空间复杂度$O(n)$</p>
</li>
<li><p>桶排序</p>
</li>
</ol>
<br>

<h4 id="参考代码-25"><a href="#参考代码-25" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x: nums) hash.<span class="hljs-built_in">insert</span>(x);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; ; i ++ ) <span class="hljs-keyword">if</span> (!hash.<span class="hljs-built_in">count</span>(i)) <span class="hljs-keyword">return</span> i;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<br>

<h3 id="LeetCode-53-最大子序和"><a href="#LeetCode-53-最大子序和" class="headerlink" title="LeetCode 53. 最大子序和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/">LeetCode 53. 最大子序和</a></h3><hr>
<h4 id="基本思路-27"><a href="#基本思路-27" class="headerlink" title="基本思路"></a>基本思路</h4><p>首先读题，我们知道就是要从所有的区间里，选出最大和的区间。暴力做法就是枚举区间的左右端点，结合数据范围大概率会超时。<br>所以要优化，这里从集合里选出最优解，很容易联想到动态规划来求解。</p>
<p>动态规划两步走</p>
<ol>
<li>状态表示：f[i]定义是所有以nums[i]结尾的区间中的最大和</li>
<li>状态计算：以区间长度为1区间只有nums[i]和区间长度&gt;&#x3D;2来划分，<br>得到状态转移方程 <code>f[i] max&#123;nums[i], nums[i] + f[i - 1]&#125;</code></li>
</ol>
<p>时间复杂度：$O(n)$</p>
<h4 id="参考代码-26"><a href="#参考代码-26" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1 - 动态规划
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = INT_MIN;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, fi = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            fi = <span class="hljs-built_in">max</span>(nums[i], nums[i] + fi);<br>            res = <span class="hljs-built_in">max</span>(res, fi);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1 - 分治
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">后续补坑<br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-22"><a href="#Reference-22" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/550058/">[1].  LauZyHou</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/95749/">[2].  Cloudddddd</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/60882/">[3]. 有心人</a></p>
<h3 id="LeetCode-54-螺旋矩阵"><a href="#LeetCode-54-螺旋矩阵" class="headerlink" title="LeetCode 54. 螺旋矩阵"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix/">LeetCode 54. 螺旋矩阵</a></h3><hr>
<h4 id="基本思路-28"><a href="#基本思路-28" class="headerlink" title="基本思路"></a>基本思路</h4><ol>
<li><p>按照<strong>方向</strong>进行模拟，定义方向（也就是坐标偏移量），然后遍历这个矩阵，合法变向（每次碰到边界或已经访问过的数就改变方向）<br>时间复杂度：$O(mn)$<br>空间复杂度：$O(mn)$ 开了额外的数组记录是否被走过</p>
</li>
<li><p>按照<strong>层</strong>遍历，4个while遍历当前层，然后往里收，直到遍历完所有元素</p>
</li>
</ol>
<br>

<h4 id="参考代码-27"><a href="#参考代码-27" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (!m) <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-type">int</span> n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, dy[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">st</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n));<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>, d = <span class="hljs-number">0</span>; i &lt; m * n; i ++ ) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(matrix[x][y]);<br>            st[x][y] = <span class="hljs-literal">true</span>;<br><br>            <span class="hljs-type">int</span> a = x + dx[d], b = y + dy[d];<br>            <span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span> || a &gt;= m || b &lt; <span class="hljs-number">0</span> || b &gt;= n || st[a][b]) &#123;<br>                d = (d + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;<br>                a = x + dx[d], b = y + dy[d];<br>            &#125;<br><br>            x = a, y = b;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<br>

<h3 id="LeetCode-55-跳跃游戏"><a href="#LeetCode-55-跳跃游戏" class="headerlink" title="LeetCode 55. 跳跃游戏"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game/">LeetCode 55. 跳跃游戏</a></h3><hr>
<h4 id="基本思路-29"><a href="#基本思路-29" class="headerlink" title="基本思路"></a>基本思路</h4><p>贪心，尽可能到达最远位置<br>为什么用贪心，因为如果能到达某个位置，那一定能到达它前面的所有位置<br>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p>
<h4 id="参考代码-28"><a href="#参考代码-28" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        代码 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canJump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++ ) &#123;<br>            <span class="hljs-keyword">if</span> (j &lt; i) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            j = <span class="hljs-built_in">max</span>(j, i + nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<br>

<h3 id="LeetCode-56-合并区间"><a href="#LeetCode-56-合并区间" class="headerlink" title="LeetCode 56. 合并区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-intervals/">LeetCode 56. 合并区间</a></h3><hr>
<h4 id="基本思路-30"><a href="#基本思路-30" class="headerlink" title="基本思路"></a>基本思路</h4><p>模板题，直接上手</p>
<ol>
<li>按区间左端点排序</li>
<li>如果有交集，更新右端点；没交集就保存当前区间<br>时间复杂度：$O(nlogn)$ 排序 + 扫描<br>空间复杂度：$O(n)$  保存答案</li>
</ol>
<h4 id="参考代码-29"><a href="#参考代码-29" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        代码 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">merge</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; a) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> res;<br><br>        <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> l = a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], r = a[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; a.<span class="hljs-built_in">size</span>(); i ++ ) &#123;<br>            <span class="hljs-keyword">if</span> (a[i][<span class="hljs-number">0</span>] &gt; r) &#123;<br>                res.<span class="hljs-built_in">push_back</span>(&#123;l, r&#125;);<br>                l = a[i][<span class="hljs-number">0</span>], r = a[i][<span class="hljs-number">1</span>];<br>            &#125; <span class="hljs-keyword">else</span> r = <span class="hljs-built_in">max</span>(r, a[i][<span class="hljs-number">1</span>]);<br>        &#125;<br><br>        res.<span class="hljs-built_in">push_back</span>(&#123;l, r&#125;);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<br>



<h3 id="LeetCode-57-插入区间"><a href="#LeetCode-57-插入区间" class="headerlink" title="LeetCode 57. 插入区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-interval/">LeetCode 57. 插入区间</a></h3><hr>
<h4 id="基本思路-31"><a href="#基本思路-31" class="headerlink" title="基本思路"></a>基本思路</h4><p>模拟即可</p>
<ol>
<li>结果中加上左边无交集部分</li>
<li>中间有交集部分，区间合并，加入结果</li>
<li>结果中加上右边无交集部分</li>
</ol>
<p>时间复杂度：$O(n)$ n是数组 intervals的长度，即给定的区间个数<br>空间复杂度：$O(1)$</p>
<br>

<h4 id="参考代码-30"><a href="#参考代码-30" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        代码 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">insert</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; a, vector&lt;<span class="hljs-type">int</span>&gt;&amp; b) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (k &lt; a.<span class="hljs-built_in">size</span>() &amp;&amp; a[k][<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">0</span>]) res.<span class="hljs-built_in">push_back</span>(a[k ++ ]); <span class="hljs-comment">// 左边完全没交集的部分</span><br><br><br>        <span class="hljs-keyword">while</span> (k &lt; a.<span class="hljs-built_in">size</span>() &amp;&amp; a[k][<span class="hljs-number">0</span>] &lt;= b[<span class="hljs-number">1</span>]) &#123;<br>            b[<span class="hljs-number">0</span>] = <span class="hljs-built_in">min</span>(b[<span class="hljs-number">0</span>], a[k][<span class="hljs-number">0</span>]);<br>            b[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(b[<span class="hljs-number">1</span>], a[k ++ ][<span class="hljs-number">1</span>]);<br>        &#125;<br>        res.<span class="hljs-built_in">push_back</span>(b);<br><br>        <span class="hljs-keyword">while</span> (k &lt; a.<span class="hljs-built_in">size</span>()) res.<span class="hljs-built_in">push_back</span>(a[k ++ ]);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<br>

<h3 id="LeetCode-58-最后一个单词的长度"><a href="#LeetCode-58-最后一个单词的长度" class="headerlink" title="LeetCode 58. 最后一个单词的长度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/length-of-last-word/">LeetCode 58. 最后一个单词的长度</a></h3><hr>
<h4 id="基本思路-32"><a href="#基本思路-32" class="headerlink" title="基本思路"></a>基本思路</h4><p><strong>模拟</strong><br>两个指针，<strong>反向遍历</strong>，一个记录末尾单词的尾部，一个记录末尾单词的头部。<br>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$<br><br></p>
<h4 id="参考代码-31"><a href="#参考代码-31" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        代码 - sanye
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLastWord</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; s[i] == <span class="hljs-string">&#x27; &#x27;</span>) i--;<br>        <span class="hljs-type">int</span> j = i;<br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; s[j] != <span class="hljs-string">&#x27; &#x27;</span>) j -- ;<br>        <span class="hljs-keyword">return</span> i - j;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>
<br>


<h3 id="LeetCode-59-螺旋矩阵-II"><a href="#LeetCode-59-螺旋矩阵-II" class="headerlink" title="LeetCode 59. 螺旋矩阵 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix-ii/">LeetCode 59. 螺旋矩阵 II</a></h3><hr>
<h4 id="基本思路-33"><a href="#基本思路-33" class="headerlink" title="基本思路"></a>基本思路</h4><p><strong>模拟</strong> 与螺旋矩阵思路完全一样，无非就是一个拿出来，一个放进去</p>
<ol>
<li><p>按方向模拟<br>时间复杂度：$O(n^2)$，其中 n是给定的正整数。矩阵的大小是 n×n，需要填入矩阵中的每个元素。<br>空间复杂度：$O(1)$ </p>
</li>
<li><p>按层模拟<br>时间复杂度：$O(n^2)$，其中 n是给定的正整数。矩阵的大小是 n×n，需要填入矩阵中的每个元素。<br>空间复杂度：$O(1)$ </p>
<br></li>
</ol>
<h4 id="参考代码-32"><a href="#参考代码-32" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">generateMatrix</span>(<span class="hljs-type">int</span> n) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">res</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br><br>        <span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, dy[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>, d = <span class="hljs-number">0</span>; i &lt;= n * n; i ++ ) &#123;<br>            res[x][y] = i;<br>            <span class="hljs-type">int</span> a = x + dx[d], b = y + dy[d];<br>            <span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span> || a &gt;= n || b &lt; <span class="hljs-number">0</span> || b &gt;= n || res[a][b]) &#123;<br>                d = (d + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;<br>                a = x + dx[d], b = y + dy[d];<br>            &#125;<br>            x = a, y = b;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>



<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路2 - k
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">generateMatrix</span>(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, top = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>, bottom = n - <span class="hljs-number">1</span>;<br><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">res</span>(n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>        <span class="hljs-keyword">while</span> (num &lt;= n*n ) &#123;<br><br>            <span class="hljs-comment">//left to right</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = left; i &lt;= right; ++i) res[top][i] = num++;<br>            ++top;<br><br>            <span class="hljs-comment">//top to bottom</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = top; i &lt;= bottom; ++i) res[i][right] = num++;<br>            --right;<br><br>            <span class="hljs-comment">//right to left</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = right; i &gt;= left; --i) res[bottom][i] = num++;<br>            --bottom;<br><br>            <span class="hljs-comment">//bottom to top</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = bottom; i &gt;= top; --i) res[i][left] = num++;<br>            ++left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<br>

<h3 id="LeetCode-61-旋转链表"><a href="#LeetCode-61-旋转链表" class="headerlink" title="LeetCode 61. 旋转链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-list/">LeetCode 61. 旋转链表</a></h3><hr>
<h4 id="基本思路-34"><a href="#基本思路-34" class="headerlink" title="基本思路"></a>基本思路</h4><p>旋转k次的意思就是把后面k个节点移到前面，所以k &#x3D; n的时候其实就是原链表没有变化，所以先把k%n得到一个小于n的数，然后进行旋转操作。<br>所以先求出链表长度</p>
<p>然后就是常规思路</p>
<ol>
<li>头节点会变，所以需要一个dummy</li>
<li>需要哪些节点，需要原来的尾节点，新的头节点和尾节点，通过遍历，用指针拿到它们</li>
<li>然后具体逻辑，注意顺序 尾节点指向头节点 倒数第k个点更新为头节点 倒数第k个点变成尾节点（指向空）</li>
</ol>
<p>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p>
<h4 id="参考代码-33"><a href="#参考代码-33" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        代码 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">rotateRight</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>        ListNode* tail;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = head; p; p = p-&gt;next) &#123;<br>            tail = p;<br>            n ++ ;<br>        &#125;<br>        k %= n;<br>        <span class="hljs-keyword">if</span> (!k) <span class="hljs-keyword">return</span> head;<br><br>        <span class="hljs-keyword">auto</span> p = head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - k - <span class="hljs-number">1</span>; i ++ ) p = p-&gt;next;<br>        tail-&gt;next = head;<br>        head = p-&gt;next;<br>        p-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<BR>


<h3 id="LeetCode-74-搜索二维矩阵"><a href="#LeetCode-74-搜索二维矩阵" class="headerlink" title="LeetCode 74. 搜索二维矩阵"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-a-2d-matrix/">LeetCode 74. 搜索二维矩阵</a></h3><hr>
<h4 id="基本思路-35"><a href="#基本思路-35" class="headerlink" title="基本思路"></a>基本思路</h4><p>有序数组寻找一个数，果断<strong>二分</strong><br>然后将二维数组转化成一维数组，注意下标变换<code>row = r / m, col = r % m</code><br>时间复杂度：$O(logmn)$，其中m和n分别是矩阵的行数和列数。<br>空间复杂度：$O(1)$。</p>
<br>

<h4 id="参考代码-34"><a href="#参考代码-34" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        代码 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (matrix.<span class="hljs-built_in">empty</span>() || matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>(), m = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n * m - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (matrix[mid / m][mid % m] &gt;= target) r = mid;<br>            <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> matrix[r / m][r % m] == target;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<BR>

<h3 id="LeetCode-75-颜色分类"><a href="#LeetCode-75-颜色分类" class="headerlink" title="LeetCode 75. 颜色分类"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-colors/">LeetCode 75. 颜色分类</a></h3><hr>
<h4 id="基本思路-36"><a href="#基本思路-36" class="headerlink" title="基本思路"></a>基本思路</h4><p>因为这个题必须O(n)级别，所以普通快排肯定是不行的</p>
<ol>
<li><p>桶排序<br>扫描一遍记录012出现的次数，然后再扫描一遍按照顺序重写数组<br>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p>
</li>
<li><p>多路快排<br>可以只扫描一遍，但是很难想，荷兰国旗问题<br>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p>
</li>
</ol>
<h4 id="参考代码-35"><a href="#参考代码-35" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> count[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)<br>            ++count[nums[i]];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, t = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">3</span>; ++i)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; count[i]; ++j)<br>                nums[t++] = i;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路2 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, k = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &lt;= k;) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">0</span>) <span class="hljs-built_in">swap</span>(nums[i ++ ], nums[j ++ ]);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">2</span>) <span class="hljs-built_in">swap</span>(nums[i], nums[k -- ]);<br>            <span class="hljs-keyword">else</span> i ++ ;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<br>

<h3 id="LeetCode-77-组合"><a href="#LeetCode-77-组合" class="headerlink" title="LeetCode 77. 组合"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combinations/">LeetCode 77. 组合</a></h3><hr>
<h4 id="基本思路-37"><a href="#基本思路-37" class="headerlink" title="基本思路"></a>基本思路</h4><p><strong>搜索题</strong><br>枚举出所有情况，很明显爆搜DFS，然后注意去重<br>时间复杂度：$O((_n^k)×k)$ 组合枚举数$O((_n^k)×k)$，每次记录答案的复杂度为$O(k)$<br>空间复杂度：$O(n+k)&#x3D;O(n)$，即递归使用栈空间的空间代价和临时数组temp的空间代价</p>
<br>

<h4 id="参考代码-36"><a href="#参考代码-36" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        代码 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-built_in">dfs</span>(n, k, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> start)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!k) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt;= n; i ++ ) &#123;<br>            path.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">dfs</span>(n, k - <span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<br>


<h3 id="LeetCode-78-子集"><a href="#LeetCode-78-子集" class="headerlink" title="LeetCode 78. 子集"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/">LeetCode 78. 子集</a></h3><hr>
<h4 id="基本思路-38"><a href="#基本思路-38" class="headerlink" title="基本思路"></a>基本思路</h4><ol>
<li><p>DFS<br>爆搜和上一题差不多</p>
</li>
<li><p>二进制<br>集合的子集有$2^n$种，所以利用二进制位数0或者1表示当前位的数字存不存在<br>时间复杂度：一共枚举$2^n$个数，每个数枚举n位，所以总时间复杂度是 $O(2^nn)$</p>
</li>
</ol>
<h4 id="参考代码-37"><a href="#参考代码-37" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路2
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1</span> &lt;&lt; n; i ++ ) &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; path;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++ )<br>                <span class="hljs-keyword">if</span> (i &gt;&gt; j &amp; <span class="hljs-number">1</span>)<br>                    path.<span class="hljs-built_in">push_back</span>(nums[j]);<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>
<br>

<h3 id="LeetCode-79-单词搜索"><a href="#LeetCode-79-单词搜索" class="headerlink" title="LeetCode 79. 单词搜索"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-search/">LeetCode 79. 单词搜索</a></h3><hr>
<h4 id="基本思路-39"><a href="#基本思路-39" class="headerlink" title="基本思路"></a>基本思路</h4><p>搜索所有路径，显然爆搜DFS<br><br></p>
<h4 id="参考代码-38"><a href="#参考代码-38" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        代码
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">exist</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; board.<span class="hljs-built_in">size</span>(); i ++ ) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; board[i].<span class="hljs-built_in">size</span>(); j ++ ) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(board, word, <span class="hljs-number">0</span>, i, j)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board, string&amp; word, <span class="hljs-type">int</span> u, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (board[x][y] != word[u]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (u == word.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-type">char</span> t = board[x][y];<br>        board[x][y] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++ ) &#123;<br>            <span class="hljs-type">int</span> a = x + dx[i], b = y + dy[i];<br>            <span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span> || a &gt;= board.<span class="hljs-built_in">size</span>() || b &lt; <span class="hljs-number">0</span> || b &gt;= board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() || board[a][b] == <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(board, word, u + <span class="hljs-number">1</span>, a, b)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        board[x][y] = t;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<br>


<h3 id="LeetCode-80-删除排序数组中的重复项-II"><a href="#LeetCode-80-删除排序数组中的重复项-II" class="headerlink" title="LeetCode 80. 删除排序数组中的重复项 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/">LeetCode 80. 删除排序数组中的重复项 II</a></h3><hr>
<h4 id="基本思路-40"><a href="#基本思路-40" class="headerlink" title="基本思路"></a>基本思路</h4><p>leetcode26删除排序数组中的重复项的变形<br><strong>双指针算法</strong><br>很显然可以用双指针算法，一个指针遍历数组，一个指针记录合法的数,<strong>关键在于怎么判断合法的数</strong><br>当前数x等于前两个数字，那么就跳过，所以当前数不等于前两个数字，就是合法的数<code>nums[k - 1] != x || nums[k - 2] != x</code>,其中因为数组有序，所以<code>nums[k - 2] != x</code>的话，<code>nums[k - 1]</code>肯定是不等于x的，所以可以舍去。<br>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$<br><br></p>
<h4 id="参考代码-39"><a href="#参考代码-39" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        代码 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x: nums)<br>            <span class="hljs-keyword">if</span> (k &lt; <span class="hljs-number">2</span> || nums[k - <span class="hljs-number">2</span>] != x)<br>                nums[k ++ ] = x;<br>        <span class="hljs-keyword">return</span> k;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<br>

<h3 id="LeetCode-82-删除排序链表中的重复元素-II"><a href="#LeetCode-82-删除排序链表中的重复元素-II" class="headerlink" title="LeetCode 82. 删除排序链表中的重复元素 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">LeetCode 82. 删除排序链表中的重复元素 II</a></h3><hr>
<h4 id="基本思路-41"><a href="#基本思路-41" class="headerlink" title="基本思路"></a>基本思路</h4><p>还是常规分析</p>
<ol>
<li>需要一个dummy节点，因为头节点可能被删除</li>
<li>需要拿到哪些节点，我们需要删除一段，所以需要这段的头节点和尾节点的最后一个节点，然后要删除他们，所以前一个节点也要知道。一点一段，外部拿到最前面的节点，循环内部拿到段内的节点</li>
<li>然后如果这两个节点之间只有一个数，代表不重复，否则就是重复的</li>
</ol>
<p>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p>
<br>

<h4 id="参考代码-40"><a href="#参考代码-40" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        代码 - yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-101</span>); dummy-&gt;next = head;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = dummy; p-&gt;next;) &#123;<br>            <span class="hljs-keyword">auto</span> a = p-&gt;next;<br>            <span class="hljs-keyword">auto</span> b = a-&gt;next;<br>            <span class="hljs-keyword">while</span> (b &amp;&amp; b-&gt;val == a-&gt;val) b = b-&gt;next;<br>            <span class="hljs-keyword">if</span> (a-&gt;next == b) p = a;<br>            <span class="hljs-keyword">else</span> p-&gt;next = b;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-23"><a href="#Reference-23" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/375392/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-83-删除排序链表中的重复元素"><a href="#LeetCode-83-删除排序链表中的重复元素" class="headerlink" title="LeetCode 83. 删除排序链表中的重复元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">LeetCode 83. 删除排序链表中的重复元素</a></h3><hr>
<h4 id="基本思路-42"><a href="#基本思路-42" class="headerlink" title="基本思路"></a>基本思路</h4><p>思维跟数组一样，一个新的列表，然后存的是原列表里所有第一次出现的数<br>新的列表需要插入头节点，所以新建一个dummy节点方便操作<br>然后如何找到原列表里第一次出现的数呢，就是和新链表的tail比较，不同的话就是第一次出现，加到新链表里<br>然后注意最后新链表的tail后可能接上了原列表最后一段，所以需要tail后指向空</p>
<p>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p>
<br>

<h4 id="参考代码-41"><a href="#参考代码-41" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-101</span>), tail = dummy;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = head; p; p = p-&gt;next) &#123;<br>            <span class="hljs-keyword">if</span> (p-&gt;val != tail-&gt;val) tail = tail-&gt;next = p; <br>        &#125;<br>        tail-&gt;next = <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-24"><a href="#Reference-24" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/375390/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-86-分隔链表"><a href="#LeetCode-86-分隔链表" class="headerlink" title="LeetCode 86. 分隔链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-list/">LeetCode 86. 分隔链表</a></h3><hr>
<h4 id="基本思路-43"><a href="#基本思路-43" class="headerlink" title="基本思路"></a>基本思路</h4><p>其实就是枚举出小于等于x的点，以及大于x的点，然后存入两个链表里，之后合并到一起<br>枚举出一些点，所以遍历的写法</p>
<h4 id="参考代码-42"><a href="#参考代码-42" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">partition</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> lh = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>), lt = lh;<br>        <span class="hljs-keyword">auto</span> rh = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>), rt = rh;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = head; p; p = p-&gt;next) &#123;<br>            <span class="hljs-keyword">if</span> (p-&gt;val &lt; x) lt = lt-&gt;next = p;<br>            <span class="hljs-keyword">else</span> rt = rt-&gt;next = p;<br>        &#125;<br><br>        lt-&gt;next = rh-&gt;next;<br>        rt-&gt;next = <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-keyword">return</span> lh-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-25"><a href="#Reference-25" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/375439/">[1]. yxc</a></p>
<br>


<h3 id="LeetCode-91-解码方法"><a href="#LeetCode-91-解码方法" class="headerlink" title="LeetCode 91. 解码方法"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/decode-ways/">LeetCode 91. 解码方法</a></h3><hr>
<h4 id="基本思路-44"><a href="#基本思路-44" class="headerlink" title="基本思路"></a>基本思路</h4><p>本题寻找总方案数 考虑用DFS或者是DP，这里的数据范围DFS会超时<br>所以选择DP的方法</p>
<p>DP问题两步走</p>
<ol>
<li><p>状态表示：f(i)表示<code>s[1,i]</code>解码的方案书（前i个数字解码的方案数）</p>
</li>
<li><p>状态计算：集合划分为两块，最后一个字符对应一位数字，或者最后一个字符对应两位数字<br>所以得到状态转移方程<code>f[i] = f[i-1] + f[i-2]</code></p>
</li>
</ol>
<p>时间复杂度：状态数是$n$个，状态转移的时间复杂度是$O(1)$，所以总时间复杂度是$O(n)$<br>空间复杂度：$O(n)$</p>
<br>

<h4 id="参考代码-43"><a href="#参考代码-43" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numDecodings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        s = <span class="hljs-string">&#x27; &#x27;</span> + s;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] &gt;= <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) f[i] += f[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-type">int</span> t = (s[i - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-number">10</span> + s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                <span class="hljs-keyword">if</span> (t &gt;= <span class="hljs-number">10</span> &amp;&amp; t &lt;= <span class="hljs-number">26</span>) f[i] += f[i - <span class="hljs-number">2</span>];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> f[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>
<br>

<h4 id="Reference-26"><a href="#Reference-26" class="headerlink" title="Reference:"></a>Reference:</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/decode-ways/solution/gong-shui-san-xie-gen-ju-shu-ju-fan-wei-ug3dd/">[1]. 【宫水三叶】根据数据范围切换「递归」与「递推」</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/4396/">[2]. DP: Decode Ways</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/15235/">[3]. 解码方法</a></p>
<br>

<h3 id="LeetCode-92-反转链表-II"><a href="#LeetCode-92-反转链表-II" class="headerlink" title="LeetCode 92. 反转链表 II"></a><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/problem/content/2445/">LeetCode 92. 反转链表 II</a></h3><hr>
<h4 id="基本思路-45"><a href="#基本思路-45" class="headerlink" title="基本思路"></a>基本思路</h4><p>还是常规思路分析</p>
<ol>
<li>首先需要dummy头节点，因为头节点可能会变</li>
<li>反转这一段，所以需要拿到这一段的首尾节点，然后也要拿到这一段的前后节点</li>
<li>然后这一段的节点做反转链表的操作，之后改变其他的节点指向关系</li>
</ol>
<p>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p>
<h4 id="参考代码-44"><a href="#参考代码-44" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        dummy-&gt;next = head;<br><br>        <span class="hljs-keyword">auto</span> a = dummy;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; left - <span class="hljs-number">1</span>; i++) a = a-&gt;next; <span class="hljs-comment">// 注意走 left-1 步</span><br><br>        <span class="hljs-keyword">auto</span> b = a-&gt;next, c = b-&gt;next;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; right - left; i++)&#123;<br>            <span class="hljs-keyword">auto</span> d = c-&gt;next;<br>            c-&gt;next = b;<br>            b = c, c = d;<br>        &#125;<br><br>        a-&gt;next-&gt;next = c;<br>        a-&gt;next = b;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-27"><a href="#Reference-27" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/54214/">[1]. 有心人</a></p>
<br>

<h3 id="LeetCode-93-复原IP地址"><a href="#LeetCode-93-复原IP地址" class="headerlink" title="LeetCode 93. 复原IP地址"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/restore-ip-addresses/">LeetCode 93. 复原IP地址</a></h3><hr>
<h4 id="基本思路-46"><a href="#基本思路-46" class="headerlink" title="基本思路"></a>基本思路</h4><p>题目要求得到所有方案，所以很明显先考虑DFS爆搜，数据范围很明确不会超时，所以DFS来做<br>DFS主要就是注意搜索的顺序，这里是一段IP一段IP的搜</p>
<p>时间复杂度：$O(3^{n-1}n)$ $O(n)$记录方案<br>空间复杂度：$O(n)$ 存答案</p>
<h4 id="参考代码-45"><a href="#参考代码-45" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; ans;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string&amp; s, <span class="hljs-type">int</span> u, <span class="hljs-type">int</span> k, string path)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (u == s.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (k == <span class="hljs-number">4</span>) &#123;<br>                path.<span class="hljs-built_in">pop_back</span>();<br>                ans.<span class="hljs-built_in">push_back</span>(path);<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = u, t = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i ++ ) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; u &amp;&amp; s[u] == <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 有前导0</span><br>            t = t * <span class="hljs-number">10</span> + s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (t &lt;= <span class="hljs-number">255</span>) <span class="hljs-built_in">dfs</span>(s, i + <span class="hljs-number">1</span>, k + <span class="hljs-number">1</span>, path + <span class="hljs-built_in">to_string</span>(t) + <span class="hljs-string">&#x27;.&#x27;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-28"><a href="#Reference-28" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/554219/">[1]. LauZyHou </a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/98993/">[2]. Cloudddddd</a></p>
<br>

<h3 id="LeetCode-94-二叉树的中序遍历"><a href="#LeetCode-94-二叉树的中序遍历" class="headerlink" title="LeetCode 94. 二叉树的中序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">LeetCode 94. 二叉树的中序遍历</a></h3><hr>
<h4 id="基本思路-47"><a href="#基本思路-47" class="headerlink" title="基本思路"></a>基本思路</h4><p>二叉树的中序遍历，代码很简单，但是内部蕴含的思想需要深究，一下给出许多版本的代码，供思考</p>
<p>思路1：递归<br>构建递推式：f是中序遍历，f(二叉树) &#x3D; f(左子树)，遍历根节点，f(右子树)<br>所以可以用递归写法</p>
<p>思路2: 迭代 + 不加标记<br>以DFS角度出发，将DFS的系统栈用自己的辅助栈“模拟”一遍，这里是回溯到某个点的时候，如果已经遍历或者要遍历就pop出去，而不是实际DFS的出栈方式（只适用于二叉树问题）</p>
<p>思路3：迭代 + 标记<br>以DFS角度出发，也是用辅助栈自己模拟，但是这个出栈的顺序和DFS是一致的，是回溯到某个点的时候，如果分支都探索完了，就pop，和DFS实际的出栈方式一致（适用于所有DFS问题）</p>
<p>思路4：迭代 + 标记 + 空节点入栈<br>以DFS角度出发，这个就是完完全全把函数栈进出的过程模拟出来了（适用于所有DFS问题）</p>
<p>思路3，4在写代码的时候，都先处理标记，第四种比较容易写错！</p>
<h4 id="参考代码-46"><a href="#参考代码-46" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        递归
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> &#123;&#125;;<br>        <span class="hljs-built_in">traversal</span>(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">traversal</span>(root-&gt;left);<br>        res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">traversal</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        迭代 不加标记
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        stack&lt;TreeNode*&gt; stk;<br><br>        <span class="hljs-keyword">while</span> (root || stk.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">while</span> (root) &#123;<br>                stk.<span class="hljs-built_in">push</span>(root);<br>                root = root-&gt;left;<br>            &#125;<br><br>            root = stk.<span class="hljs-built_in">top</span>();<br>            stk.<span class="hljs-built_in">pop</span>();<br>            res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>            root = root-&gt;right;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        迭代 + 标记 + 空节点不入栈
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br><br>        unordered_map&lt;TreeNode*, <span class="hljs-type">int</span>&gt; vis;<br>        stack&lt;TreeNode*&gt; stk;<br><br>        <span class="hljs-keyword">while</span> (root || stk.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">while</span> (root) &#123;<br>                vis[root] = <span class="hljs-number">1</span>;<br>                stk.<span class="hljs-built_in">push</span>(root);<br>                root = root-&gt;left;<br>            &#125;<br><br>            root = stk.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span> (vis[root] == <span class="hljs-number">1</span>) &#123;<br>                vis[root] = <span class="hljs-number">2</span>;<br>                res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>                root = root-&gt;right;<br>            &#125;<br><br>            <span class="hljs-keyword">else</span> &#123;<br>                stk.<span class="hljs-built_in">pop</span>();<br>                root = <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        迭代 + 标记 + 空节点入栈
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        stack&lt;pair&lt;TreeNode*, <span class="hljs-type">int</span>&gt;&gt;stk;<br>        stk.<span class="hljs-built_in">push</span>(&#123;root, <span class="hljs-number">0</span>&#125;);<br>        <span class="hljs-keyword">while</span> (stk.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span> (stk.<span class="hljs-built_in">top</span>().first == <span class="hljs-literal">NULL</span>)<br>            &#123;<br>                stk.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> t = stk.<span class="hljs-built_in">top</span>().second;<br>            <span class="hljs-keyword">if</span> (t == <span class="hljs-number">0</span>)<br>            &#123;<br>                stk.<span class="hljs-built_in">top</span>().second = <span class="hljs-number">1</span>;<br>                stk.<span class="hljs-built_in">push</span>(&#123;stk.<span class="hljs-built_in">top</span>().first-&gt;left, <span class="hljs-number">0</span>&#125;);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t == <span class="hljs-number">1</span>)<br>            &#123;<br>                res.<span class="hljs-built_in">push_back</span>(stk.<span class="hljs-built_in">top</span>().first-&gt;val);<br>                stk.<span class="hljs-built_in">top</span>().second = <span class="hljs-number">2</span>;<br>                stk.<span class="hljs-built_in">push</span>(&#123;stk.<span class="hljs-built_in">top</span>().first-&gt;right, <span class="hljs-number">0</span>&#125;);<br>            &#125;<br>            <span class="hljs-keyword">else</span> stk.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<br>

<h4 id="Reference-29"><a href="#Reference-29" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/379732/">[1]. yxc</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/176/">[2]. 递归改迭代机械做法</a><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/shou-hua-tu-jie-yong-zhan-mo-ni-zhong-xu-bian-li-z/">[3]. 二叉树遍历本质</a></p>
<br>

<h3 id="LeetCode-95-不同的二叉搜索树-II"><a href="#LeetCode-95-不同的二叉搜索树-II" class="headerlink" title="LeetCode 95. 不同的二叉搜索树 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees-ii/">LeetCode 95. 不同的二叉搜索树 II</a></h3><hr>
<h4 id="基本思路-48"><a href="#基本思路-48" class="headerlink" title="基本思路"></a>基本思路</h4><p>构建二叉搜索树，一般都是通过它的中序遍历构建，也就是通过一段区间，就可以构建二叉搜索树<br>构建一棵二叉搜索树，有固定的递归写法</p>
<p>这里要得到所有的BST，显然DFS<br>二叉树的DFS返回值一般就是根据递推式分析，返回值可以理解成搜索当前层的xxx，xxx就是我们设置的返回值<br>然后注意关于二叉树问题的DFS，搜索顺序一般是按树搜索（当前树，下一步就是左子树，右子树），所以<strong>DFS的当前层这里就是当前树，而不是当前二叉树的某一层</strong><br>所以DFS 当前树，我们先要枚举所有的中点，然后对于每个中点，构建二叉树</p>
<h4 id="参考代码-47"><a href="#参考代码-47" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        DFS + 递归
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;TreeNode*&gt; <span class="hljs-title">generateTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!n) <span class="hljs-keyword">return</span> &#123;&#125;;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, n); <br>    &#125;<br><br>    <span class="hljs-function">vector&lt;TreeNode*&gt; <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> <span class="hljs-comment">//返回在区间[l, r]中所有合法方案</span></span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;TreeNode*&gt; res;<br>        <span class="hljs-keyword">if</span> (l &gt; r) <br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">nullptr</span>); 结点为空，是一种子树的方案，需要加入方案集中<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= r; i ++) <span class="hljs-comment">//枚举根节点位置</span><br>        &#123;<br>            <span class="hljs-keyword">auto</span> left = <span class="hljs-built_in">dfs</span>(l, i - <span class="hljs-number">1</span>); <span class="hljs-comment">//返回左子树所有合法方案</span><br>            <span class="hljs-keyword">auto</span> right = <span class="hljs-built_in">dfs</span>(i + <span class="hljs-number">1</span>, r); <span class="hljs-comment">//返回右子树所有合法方案</span><br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;lt : left) <span class="hljs-comment">//一个左子树</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;rt : right) <span class="hljs-comment">//一个右子树</span><br>                &#123;<br>                    TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(i); <span class="hljs-comment">//创建根节点</span><br>                    root -&gt; left = lt;<br>                    root -&gt; right = rt;<br>                    res.<span class="hljs-built_in">push_back</span>(root); <span class="hljs-comment">//加入以该结点为根的合法方案</span><br>                &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-30"><a href="#Reference-30" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/379795/">[1]. yxc</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/14308/">[2]. 注释详细</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/35054/">[3]. 记忆化搜索</a></p>
<br>

<h3 id="LeetCode-96-不同的二叉搜索树"><a href="#LeetCode-96-不同的二叉搜索树" class="headerlink" title="LeetCode 96. 不同的二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees/">LeetCode 96. 不同的二叉搜索树</a></h3><hr>
<h4 id="基本思路-49"><a href="#基本思路-49" class="headerlink" title="基本思路"></a>基本思路</h4><p>和上题类似，这题我们不需要求所有解（路径），只需要求次数，递推公式 + 值落实到次数，所以很明显我们可以用DP</p>
<ol>
<li>top down dp 其实就是DFS加打表</li>
<li>自底向上dp，就是紧扣递推公式（状态转移方程），从底层向上状态转移</li>
</ol>
<h4 id="参考代码-48"><a href="#参考代码-48" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        top-down dp
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; f;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        f = vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,n);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">if</span>(f[l][r]) <span class="hljs-keyword">return</span> f[l][r];<br><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = l; i &lt;= r; i ++)&#123;<br>            <span class="hljs-type">int</span> left = <span class="hljs-built_in">dfs</span>(l, i<span class="hljs-number">-1</span>);<br>            <span class="hljs-type">int</span> right = <span class="hljs-built_in">dfs</span>(i+<span class="hljs-number">1</span>, r);<br>            res+=left * right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[l][r] = res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        自底向上dp
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j ++ )<br>                f[i] += f[j - <span class="hljs-number">1</span>] * f[i - j];<br>        <span class="hljs-keyword">return</span> f[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<p>其实还可以直接卡特兰函数求解</p>
<h4 id="Reference-31"><a href="#Reference-31" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/379808/">[1]. yxc</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/98740/">[2]. 闫式dp分析</a></p>
<Br>

<h3 id="LeetCode-98-验证二叉搜索树"><a href="#LeetCode-98-验证二叉搜索树" class="headerlink" title="LeetCode 98. 验证二叉搜索树"></a><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/problem/content/2451/">LeetCode 98. 验证二叉搜索树</a></h3><hr>
<h4 id="基本思路-50"><a href="#基本思路-50" class="headerlink" title="基本思路"></a>基本思路</h4><p>思路1：递归<br>BST的问题，可以先试着从定义递推，左子树是BST + 右子树是BST + 根节点满足上下限关系 &#x3D; 该树是BST。所以递归函数返回值bool值，然后参数就是树 + 上下限<br>然后注意，我们说root节点的值从定义推都是严格大于和严格小于，所以上下限是开区间</p>
<p>思路2：中序遍历 递归<br>二叉搜索树 &lt;&#x3D;&#x3D;&gt; 中序遍历是升序<br>所以我们可以中序遍历的时候，检查每一个点是否严格大于前一个节点</p>
<p>思路3：中序遍历 迭代<br>其实就是上一个思路的迭代写法</p>
<h4 id="参考代码-49"><a href="#参考代码-49" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1：递归
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isvalid</span>(root, LONG_MIN, LONG_MAX);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isvalid</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">long</span> <span class="hljs-type">long</span> down, <span class="hljs-type">long</span> <span class="hljs-type">long</span> up)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">if</span> (root-&gt;val &lt;= down || root-&gt;val &gt;= up) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isvalid</span>(root-&gt;left, down, root-&gt;val) &amp;&amp; <span class="hljs-built_in">isvalid</span>(root-&gt;right, root-&gt;val, up);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路2：中序遍历 迭代
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">bool</span> res = <span class="hljs-literal">true</span>;<br>    TreeNode* pre;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>        <br>        <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>        <span class="hljs-keyword">if</span> (pre &amp;&amp; pre-&gt;val &gt;= root-&gt;val) &#123;<br>            res = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        pre = root;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路3：中序遍历 递归
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        TreeNode *prev = <span class="hljs-literal">NULL</span>;<br>        stack&lt;TreeNode *&gt; stk;<br>        <span class="hljs-keyword">while</span> (root || stk.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">while</span> (root) &#123;<br>                stk.<span class="hljs-built_in">push</span>(root);<br>                root = root-&gt;left;<br>            &#125;<br>            root = stk.<span class="hljs-built_in">top</span>();<br>            stk.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (prev &amp;&amp; prev-&gt;val &gt;= root-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            prev = root;<br>            root = root-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<br>

<h4 id="Reference-32"><a href="#Reference-32" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/15875/">[1]. adnil8130</a></p>
<br>

<h3 id="LeetCode-99-恢复二叉搜索树"><a href="#LeetCode-99-恢复二叉搜索树" class="headerlink" title="LeetCode 99. 恢复二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/recover-binary-search-tree/">LeetCode 99. 恢复二叉搜索树</a></h3><hr>
<h4 id="基本思路-51"><a href="#基本思路-51" class="headerlink" title="基本思路"></a>基本思路</h4><p>思路1：递归<br>二叉搜索树 &#x3D; 中序遍历有序<br>所以还是紧扣这个定义，中序遍历找到逆序对，注意位置相邻是一个逆序对，位置不相邻就是两个逆序对，但是我们就是记录第一个逆序对的第一个数，和最后一个逆序对的第二个数<br>然后swap就行</p>
<p>思路2：迭代<br>其实就是思路1的迭代写法</p>
<h4 id="参考代码-50"><a href="#参考代码-50" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    TreeNode* pre, *first, *second;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recoverTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-built_in">swap</span>(first-&gt;val, second-&gt;val);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>        <span class="hljs-keyword">if</span> (pre &amp;&amp; pre-&gt;val &gt;= root-&gt;val) &#123;<br>            <span class="hljs-keyword">if</span> (!first) first = pre, second = root;<br>            <span class="hljs-keyword">else</span> second = root;<br>        &#125;<br>        pre = root;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>


<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路2
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recoverTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        stack&lt;TreeNode*&gt; stk;<br>        TreeNode* pre = <span class="hljs-literal">nullptr</span>, *first = <span class="hljs-literal">nullptr</span>, *second = <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-keyword">while</span> (root || stk.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">while</span> (root) &#123;<br>                stk.<span class="hljs-built_in">push</span>(root);<br>                root = root-&gt;left;<br>            &#125;<br><br>            root = stk.<span class="hljs-built_in">top</span>();<br>            stk.<span class="hljs-built_in">pop</span>();<br><br>            <span class="hljs-keyword">if</span> (pre &amp;&amp; pre-&gt;val &gt;= root-&gt;val) &#123;<br>                <span class="hljs-keyword">if</span> (!first) first = pre, second = root;<br>                <span class="hljs-keyword">else</span> second = root;<br>            &#125;<br>            pre = root;<br>            root = root-&gt;right;<br>        &#125;<br><br>        <span class="hljs-built_in">swap</span>(first-&gt;val, second-&gt;val);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>


<h4 id="Reference-33"><a href="#Reference-33" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/35181/">[1]. 张小白</a></p>
<br>

<h3 id="LeetCode-100-相同的树"><a href="#LeetCode-100-相同的树" class="headerlink" title="LeetCode 100. 相同的树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/same-tree/">LeetCode 100. 相同的树</a></h3><hr>
<h4 id="基本思路-52"><a href="#基本思路-52" class="headerlink" title="基本思路"></a>基本思路</h4><p>思路1 递归<br>直接尝试递推式，两个树相等 &#x3D; 两个数左子树相等 + 两个数右子树相等 + root相等<br>参数直接就是树即可<br>然后注意递归边界</p>
<p>思路2 BFS<br>可以BFS搜索，如果每次遍历的点一样，那么就是相等的</p>
<h4 id="参考代码-51"><a href="#参考代码-51" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSameTree</span><span class="hljs-params">(TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!p &amp;&amp; !q) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (!p || !q || p-&gt;val != q-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSameTree</span>(p-&gt;left, q-&gt;left) &amp;&amp; <span class="hljs-built_in">isSameTree</span>(p-&gt;right, q-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路2
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSameTree</span><span class="hljs-params">(TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        queue&lt;TreeNode *&gt; Q; Q.<span class="hljs-built_in">push</span>(p); Q.<span class="hljs-built_in">push</span>(q);<br>        <span class="hljs-keyword">while</span>(Q.<span class="hljs-built_in">size</span>()) &#123;<br>            p = Q.<span class="hljs-built_in">front</span>(); Q.<span class="hljs-built_in">pop</span>();<br>            q = Q.<span class="hljs-built_in">front</span>(); Q.<span class="hljs-built_in">pop</span>();<br><br>            <span class="hljs-keyword">if</span>(!p &amp;&amp; !q) <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-keyword">if</span>(!p || !q || p-&gt;val != q-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>            Q.<span class="hljs-built_in">push</span>(p-&gt;left);Q.<span class="hljs-built_in">push</span>(q-&gt;left);<br>            Q.<span class="hljs-built_in">push</span>(p-&gt;right);Q.<span class="hljs-built_in">push</span>(q-&gt;right);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-34"><a href="#Reference-34" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/15871/">[1]. adnil8130</a></p>
<br>


<h2 id="LeetCode-101-200"><a href="#LeetCode-101-200" class="headerlink" title="LeetCode 101 - 200"></a>LeetCode 101 - 200</h2><h3 id="LeetCode-101-对称二叉树"><a href="#LeetCode-101-对称二叉树" class="headerlink" title="LeetCode 101. 对称二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">LeetCode 101. 对称二叉树</a></h3><hr>
<h4 id="基本思路-53"><a href="#基本思路-53" class="headerlink" title="基本思路"></a>基本思路</h4><p>思路1 递归<br>从定义入手找递推式 一个树是对称的 &#x3D; 左右子树互为镜像 &#x3D; 左子树和右子树的root相等 + 左子树的右边和右子树的左边互为镜像 + 左子树的左边和右子树的右边互为镜像<br>所以我们得到了递推式，然后注意递归边界</p>
<p>思路2 BFS<br>BFS当然也是可以做的，每层先后入队应该相等的点，然后比较</p>
<h4 id="参考代码-52"><a href="#参考代码-52" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">issym</span>(root-&gt;left, root-&gt;right);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">issym</span><span class="hljs-params">(TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!p &amp;&amp; !q) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (!p || !q || p-&gt;val != q-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">issym</span>(p-&gt;left, q-&gt;right) &amp;&amp; <span class="hljs-built_in">issym</span>(p-&gt;right, q-&gt;left);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>


<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路2
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(TreeNode *u, TreeNode *v)</span> </span>&#123;<br>        queue &lt;TreeNode*&gt; q;<br>        q.<span class="hljs-built_in">push</span>(u); q.<span class="hljs-built_in">push</span>(v);<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            u = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>            v = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (!u &amp;&amp; !v) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> ((!u || !v) || (u-&gt;val != v-&gt;val)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>            q.<span class="hljs-built_in">push</span>(u-&gt;left); <br>            q.<span class="hljs-built_in">push</span>(v-&gt;right);<br><br>            q.<span class="hljs-built_in">push</span>(u-&gt;right); <br>            q.<span class="hljs-built_in">push</span>(v-&gt;left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">check</span>(root, root);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-35"><a href="#Reference-35" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/solution/dui-cheng-er-cha-shu-by-leetcode-solution/">[1]. Leetcode</a></p>
<h3 id="LeetCode-102-二叉树的层序遍历"><a href="#LeetCode-102-二叉树的层序遍历" class="headerlink" title="LeetCode 102. 二叉树的层序遍历 "></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">LeetCode 102. 二叉树的层序遍历 </a></h3><hr>
<h4 id="基本思路-54"><a href="#基本思路-54" class="headerlink" title="基本思路"></a>基本思路</h4><p>BFS模板，注意记录每层的节点</p>
<h4 id="参考代码-53"><a href="#参考代码-53" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        BFS
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        queue&lt;TreeNode*&gt; q;<br>        <span class="hljs-keyword">if</span> (root) q.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; level;<br>            <span class="hljs-type">int</span> len = q.<span class="hljs-built_in">size</span>();<br><br>            <span class="hljs-keyword">while</span> (len -- ) &#123;<br>                <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                level.<span class="hljs-built_in">push_back</span>(t-&gt;val);<br>                <span class="hljs-keyword">if</span> (t-&gt;left) q.<span class="hljs-built_in">push</span>(t-&gt;left);<br>                <span class="hljs-keyword">if</span> (t-&gt;right) q.<span class="hljs-built_in">push</span>(t-&gt;right);<br>            &#125;<br><br>            res.<span class="hljs-built_in">push_back</span>(level);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-36"><a href="#Reference-36" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/554636/">[1]. LauZyHou</a></p>
<br>


<h3 id="LeetCode-103-二叉树的锯齿形层次遍历"><a href="#LeetCode-103-二叉树的锯齿形层次遍历" class="headerlink" title="LeetCode 103. 二叉树的锯齿形层次遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">LeetCode 103. 二叉树的锯齿形层次遍历</a></h3><hr>
<h4 id="基本思路-55"><a href="#基本思路-55" class="headerlink" title="基本思路"></a>基本思路</h4><p>层序遍历模板 + 奇数行不需要反向，偶数行需要反向</p>
<h4 id="参考代码-54"><a href="#参考代码-54" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        BFS
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        queue&lt;TreeNode*&gt; q;<br>        <span class="hljs-keyword">if</span> (root) q.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; level;<br>            <span class="hljs-type">int</span> len = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span> (len -- ) &#123;<br>                <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                level.<span class="hljs-built_in">push_back</span>(t-&gt;val);<br>                <span class="hljs-keyword">if</span> (t-&gt;left) q.<span class="hljs-built_in">push</span>(t-&gt;left);<br>                <span class="hljs-keyword">if</span> (t-&gt;right) q.<span class="hljs-built_in">push</span>(t-&gt;right);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> ( ++ cnt % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) <span class="hljs-built_in">reverse</span>(level.<span class="hljs-built_in">begin</span>(), level.<span class="hljs-built_in">end</span>());<br>            res.<span class="hljs-built_in">push_back</span>(level);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-37"><a href="#Reference-37" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/14337/">[1]. Coderoger</a></p>
<br>

<h3 id="LeetCode-104-二叉树的最大深度"><a href="#LeetCode-104-二叉树的最大深度" class="headerlink" title="LeetCode 104. 二叉树的最大深度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">LeetCode 104. 二叉树的最大深度</a></h3><hr>
<h4 id="基本思路-56"><a href="#基本思路-56" class="headerlink" title="基本思路"></a>基本思路</h4><p>思路1 递归<br>还是扣住定义找递推式，该树的最大深度 &#x3D; max（左子树的最大深度， 右子树的最大深度） + 1<br>注意递归边界</p>
<p>思路2 BFS<br>层序遍历，每遍历一层深度 + 1</p>
<h4 id="参考代码-55"><a href="#参考代码-55" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1： 递归
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">maxDepth</span>(root-&gt;left), <span class="hljs-built_in">maxDepth</span>(root-&gt;right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路2：BFS
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-comment">// 解法三：BFS（队列实现）</span><br>        <span class="hljs-type">int</span> max_depth = <span class="hljs-number">0</span>;<br>        queue&lt;TreeNode*&gt; q;<br><br>        <span class="hljs-keyword">if</span> (root) q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-comment">// 每次循环遍历一层</span><br>            <span class="hljs-type">int</span> len = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span> (len--) &#123;<br>                TreeNode* e = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (e-&gt;left) q.<span class="hljs-built_in">push</span>(e-&gt;left);<br>                <span class="hljs-keyword">if</span> (e-&gt;right) q.<span class="hljs-built_in">push</span>(e-&gt;right);<br>            &#125;<br>            max_depth++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max_depth;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>


<h4 id="Reference-38"><a href="#Reference-38" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/134682/">[1]. Zzay</a></p>
<br>


<h3 id="LeetCode-105-从前序与中序遍历序列构造二叉树"><a href="#LeetCode-105-从前序与中序遍历序列构造二叉树" class="headerlink" title="LeetCode 105. 从前序与中序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">LeetCode 105. 从前序与中序遍历序列构造二叉树</a></h3><hr>
<h4 id="基本思路-57"><a href="#基本思路-57" class="headerlink" title="基本思路"></a>基本思路</h4><p>还是递归构造二叉树的思路，需要知道根节点，左子树和右子树的信息</p>
<p>所以难点就在于，如何在前序遍历和中序遍历的数组里，找到根节点，左子树和右子树的范围。对于前序遍历，我们可以很轻松找到根节点，就是左端点，但是找到根节点后，我们不好求出左右子树范围<br>但是对于中序遍历，如果找到根节点，我们可以很轻松找到左右子树范围</p>
<p>所以思路就是通过前序遍历找到根节点，然后再利用hash表找到中序遍历里的根节点，最后就可以得到左右子树范围了，然后就可以递归构建二叉树了</p>
<h4 id="参考代码-56"><a href="#参考代码-56" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        递归
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash; <br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; inorder.<span class="hljs-built_in">size</span>(); i ++ ) hash[inorder[i]] = i;<br>        <span class="hljs-type">int</span> pl = <span class="hljs-number">0</span>, pr = preorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, il = <span class="hljs-number">0</span>, ir = inorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">build</span>(preorder, inorder, pl, pr, il, ir);<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">build</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, <span class="hljs-type">int</span> pl, <span class="hljs-type">int</span> pr, <span class="hljs-type">int</span> il, <span class="hljs-type">int</span> ir)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (pl &gt; pr) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-keyword">auto</span> root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorder[pl]);<br>        <span class="hljs-keyword">auto</span> k = hash[root-&gt;val];<br>        root-&gt;left = <span class="hljs-built_in">build</span>(preorder, inorder, pl + <span class="hljs-number">1</span>, pl + <span class="hljs-number">1</span> + k - <span class="hljs-number">1</span> - il, il, k - <span class="hljs-number">1</span>);<br>        root-&gt;right = <span class="hljs-built_in">build</span>(preorder, inorder, pl + k - il + <span class="hljs-number">1</span>, pr, k + <span class="hljs-number">1</span>, ir);<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-39"><a href="#Reference-39" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/384035/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-106-从中序与后序遍历序列构造二叉树"><a href="#LeetCode-106-从中序与后序遍历序列构造二叉树" class="headerlink" title="LeetCode 106. 从中序与后序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">LeetCode 106. 从中序与后序遍历序列构造二叉树</a></h3><hr>
<h4 id="基本思路-58"><a href="#基本思路-58" class="headerlink" title="基本思路"></a>基本思路</h4><p>和上一题思路差不多，只是现在我们从后序遍历中找到根节点，然后通过哈希表在中序遍历里找到根节点的位置，然后就可以得到左右子树的范围了</p>
<h4 id="参考代码-57"><a href="#参考代码-57" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        递归
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>&#123;    <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; inorder.<span class="hljs-built_in">size</span>(); i ++ ) hash[inorder[i]] = i;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">build</span>(inorder, postorder, <span class="hljs-number">0</span>, inorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, postorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">build</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder, <span class="hljs-type">int</span> il, <span class="hljs-type">int</span> ir, <span class="hljs-type">int</span> pl, <span class="hljs-type">int</span> pr)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (il &gt; ir) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-keyword">auto</span> root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(postorder[pr]);<br>        <span class="hljs-type">int</span> k = hash[root-&gt;val];<br>        root-&gt;left = <span class="hljs-built_in">build</span>(inorder, postorder, il, k - <span class="hljs-number">1</span>, pl, pl + k - <span class="hljs-number">1</span> - il);<br>        root-&gt;right = <span class="hljs-built_in">build</span>(inorder, postorder, k + <span class="hljs-number">1</span>, ir, pl + k - il, pr - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-40"><a href="#Reference-40" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/384041/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-107-二叉树的层次遍历-II"><a href="#LeetCode-107-二叉树的层次遍历-II" class="headerlink" title="LeetCode 107. 二叉树的层次遍历 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">LeetCode 107. 二叉树的层次遍历 II</a></h3><hr>
<h4 id="基本思路-59"><a href="#基本思路-59" class="headerlink" title="基本思路"></a>基本思路</h4><p>基本的层序遍历，然后最后把结果reverse一下就行</p>
<h4 id="参考代码-58"><a href="#参考代码-58" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        BFS
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrderBottom</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        queue&lt;TreeNode*&gt; q;<br>        <span class="hljs-keyword">if</span> (root) q.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; level;<br>            <span class="hljs-type">int</span> len = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span> (len -- ) &#123;<br>                <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                level.<span class="hljs-built_in">push_back</span>(t-&gt;val);<br>                <span class="hljs-keyword">if</span> (t-&gt;left) q.<span class="hljs-built_in">push</span>(t-&gt;left);<br>                <span class="hljs-keyword">if</span> (t-&gt;right) q.<span class="hljs-built_in">push</span>(t-&gt;right);<br>            &#125;<br>            res.<span class="hljs-built_in">push_back</span>(level);<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-41"><a href="#Reference-41" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/384046/">[1]. yxc</a></p>
<br>


<h3 id="LeetCode-108-将有序数组转换为二叉搜索树"><a href="#LeetCode-108-将有序数组转换为二叉搜索树" class="headerlink" title="LeetCode 108. 将有序数组转换为二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">LeetCode 108. 将有序数组转换为二叉搜索树</a></h3><hr>
<h4 id="基本思路-60"><a href="#基本思路-60" class="headerlink" title="基本思路"></a>基本思路</h4><p>构建二叉树还是根据定义找递推式 构建二叉树 &#x3D; 构建左子树 + 构建右子树 + new出根节点连接左右子树<br>构建二叉树的参数需要数据范围，然后这里平衡二叉树是要根节点取中点<br>注意递归边界</p>
<p>难是难在证明为什么取中点作为根节点</p>
<h4 id="参考代码-59"><a href="#参考代码-59" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        递归
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">build</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">build</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt; r) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">auto</span> root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[mid]);<br>        root-&gt;left = <span class="hljs-built_in">build</span>(nums, l, mid - <span class="hljs-number">1</span>);<br>        root-&gt;right = <span class="hljs-built_in">build</span>(nums, mid + <span class="hljs-number">1</span>, r);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>


<h4 id="Reference-42"><a href="#Reference-42" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/196/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-109-有序链表转换二叉搜索树"><a href="#LeetCode-109-有序链表转换二叉搜索树" class="headerlink" title="LeetCode 109. 有序链表转换二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/">LeetCode 109. 有序链表转换二叉搜索树</a></h3><hr>
<h4 id="基本思路-61"><a href="#基本思路-61" class="headerlink" title="基本思路"></a>基本思路</h4><p>和上一题本质一样，只是说把数组换成了链表<br>所以本题的考点，就是如何拿到链表的中点</p>
<p>思路1 转换成数组<br>直接存入数组</p>
<p>思路2 快慢指针拿中点</p>
<h4 id="参考代码-60"><a href="#参考代码-60" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">sortedListToBST</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; nums;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = head; p; p = p-&gt;next) &#123;<br>            nums.<span class="hljs-built_in">emplace_back</span>(p-&gt;val);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">build</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">build</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt; r) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">auto</span> root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[mid]);<br>        root-&gt;left = <span class="hljs-built_in">build</span>(nums, l, mid - <span class="hljs-number">1</span>);<br>        root-&gt;right = <span class="hljs-built_in">build</span>(nums, mid + <span class="hljs-number">1</span>, r);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路2
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">getMedian</span><span class="hljs-params">(ListNode* left, ListNode* right)</span> </span>&#123;<br>        ListNode* fast = left;<br>        ListNode* slow = left;<br>        <span class="hljs-keyword">while</span> (fast != right &amp;&amp; fast-&gt;next != right) &#123;<br>            fast = fast-&gt;next-&gt;next;<br>            slow = slow-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(ListNode* left, ListNode* right)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (left == right) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        ListNode* mid = <span class="hljs-built_in">getMedian</span>(left, right);<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(mid-&gt;val);<br>        root-&gt;left = <span class="hljs-built_in">buildTree</span>(left, mid);<br>        root-&gt;right = <span class="hljs-built_in">buildTree</span>(mid-&gt;next, right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">sortedListToBST</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">buildTree</span>(head, <span class="hljs-literal">nullptr</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>


<h4 id="Reference-43"><a href="#Reference-43" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/35664/">[1]. 张小白</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/554765/">[2]. LauZyHou</a></p>
<br>

<h3 id="LeetCode-110-平衡二叉树"><a href="#LeetCode-110-平衡二叉树" class="headerlink" title="LeetCode 110. 平衡二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/balanced-binary-tree/">LeetCode 110. 平衡二叉树</a></h3><hr>
<h4 id="基本思路-62"><a href="#基本思路-62" class="headerlink" title="基本思路"></a>基本思路</h4><p>首先还是尝试找递推式，发现没有办法找到关于平衡二叉树的一个递推式。<br>所以我们只能DFS遍历每一个节点的高度，然后对于每个节点去判断是否平衡。那么很显然，DFS返回值是高度，DFS参数只是遍历的话那就只需要树节点就行</p>
<h4 id="参考代码-61"><a href="#参考代码-61" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        DFS
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">bool</span> ans = <span class="hljs-literal">true</span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> lt = <span class="hljs-built_in">dfs</span>(root-&gt;left), rt = <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(lt - rt) &gt; <span class="hljs-number">1</span>) ans = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(lt, rt) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-44"><a href="#Reference-44" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/384117/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-111-二叉树的最小深度"><a href="#LeetCode-111-二叉树的最小深度" class="headerlink" title="LeetCode 111. 二叉树的最小深度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">LeetCode 111. 二叉树的最小深度</a></h3><hr>
<h4 id="基本思路-63"><a href="#基本思路-63" class="headerlink" title="基本思路"></a>基本思路</h4><p>思路1： 递归<br>和之前的最大深度类似，还是找到递推式 树的最大深度 &#x3D; max(左子树的深度，右子树的深度) + 1;<br>这里的递归边界要注意，之前最小深度，null节点深度是0，不会影响最大值，但是这里是最小值，所以null会影响，所以应该边界更细化<br>难点就是注意递归的边界</p>
<p>思路2：BFS<br>深度，很明显我们可以用层序遍历的方式来做</p>
<h4 id="参考代码-62"><a href="#参考代码-62" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        递归
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (!root-&gt;left) <span class="hljs-keyword">return</span> <span class="hljs-built_in">minDepth</span>(root-&gt;right) + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (!root-&gt;right) <span class="hljs-keyword">return</span> <span class="hljs-built_in">minDepth</span>(root-&gt;left) + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(<span class="hljs-built_in">minDepth</span>(root-&gt;left), <span class="hljs-built_in">minDepth</span>(root-&gt;right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        BFS
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> depth = <span class="hljs-number">1</span>;<br>        queue&lt;TreeNode *&gt; Q; Q.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span> (Q.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-type">int</span> len = Q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span> (len--)&#123;<br>                TreeNode *node = Q.<span class="hljs-built_in">front</span>(); Q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (!node-&gt;left &amp;&amp; !node-&gt;right) <span class="hljs-keyword">return</span> depth;<br>                <span class="hljs-keyword">if</span> (node-&gt;left) Q.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) Q.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>            ++depth;<br>        &#125;<br>        <span class="hljs-keyword">return</span> depth;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-45"><a href="#Reference-45" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/390296/">[1]. yxc</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/15899/">[2]. adnil8130</a></p>
<br>

<h3 id="LeetCode-112-路径总和"><a href="#LeetCode-112-路径总和" class="headerlink" title="LeetCode 112. 路径总和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum/">LeetCode 112. 路径总和</a></h3><hr>
<h4 id="基本思路-64"><a href="#基本思路-64" class="headerlink" title="基本思路"></a>基本思路</h4><p>思路1：DFS + 回溯<br>直接思路就是搜索所有的路径，所以是回溯角度的DFS<br>回溯角度DFS一般有很多种写法，为了速度更快，我们把写法尽量统一，输入和全局变量，都当作引用传进DFS函数，其余的就是局部变量，自动回溯<br>然后判断还是否需要手动回溯，就是看当前层是不是我们想要的结果，如果不是就手动回溯一下</p>
<p>思路2：递归<br>还是根据定义去找递推式，树存在sum路径 &#x3D; 左子树 + 根节点 存在sum || 右子树 + 根节点 存在sum || 根节点存在sum<br>然后注意上述的递推式是存在分情况讨论的</p>
<h4 id="参考代码-63"><a href="#参考代码-63" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1：DFS - 回溯
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> sum;<br>    <span class="hljs-type">bool</span> ans;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> targetSum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">dfs</span>(root, targetSum, sum);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span>&amp; targetSum, <span class="hljs-type">int</span> sum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br><br>        sum += root-&gt;val;<br>        <span class="hljs-keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;<br>            <span class="hljs-keyword">if</span> (sum == targetSum) ans = <span class="hljs-literal">true</span>; <br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">dfs</span>(root-&gt;left, targetSum, sum);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right, targetSum, sum);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路2：递归
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> sum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        sum -= root-&gt;val;<br>        <span class="hljs-keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) <span class="hljs-keyword">return</span> !sum;<br>        <span class="hljs-keyword">return</span> root-&gt;left &amp;&amp; <span class="hljs-built_in">hasPathSum</span>(root-&gt;left, sum) || root-&gt;right &amp;&amp; <span class="hljs-built_in">hasPathSum</span>(root-&gt;right, sum);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<br>

<h4 id="Reference-46"><a href="#Reference-46" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/390306/">[1]. yxc</a><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum/solution/yi-pian-wen-zhang-jie-jue-suo-you-er-cha-pqum/">[2]. 路径模板总结</a></p>
<br>

<h3 id="LeetCode-113-路径总和-II"><a href="#LeetCode-113-路径总和-II" class="headerlink" title="LeetCode 113. 路径总和 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-ii/">LeetCode 113. 路径总和 II</a></h3><hr>
<h4 id="基本思路-65"><a href="#基本思路-65" class="headerlink" title="基本思路"></a>基本思路</h4><p>跟上题思路一样，只是这里需要记录路径，回溯有很多种写法，我们这里采用我自己总结的一套写法</p>
<h4 id="参考代码-64"><a href="#参考代码-64" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        DFS + 回溯
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pathSum</span>(TreeNode* root, <span class="hljs-type">int</span> targetSum) &#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> &#123;&#125;;<br>        <span class="hljs-built_in">dfs</span>(root, targetSum, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span>&amp; targetSum, <span class="hljs-type">int</span> sum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br><br>        path.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        sum += root-&gt;val;<br>        <span class="hljs-keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;<br>            <span class="hljs-keyword">if</span> (sum == targetSum) res.<span class="hljs-built_in">push_back</span>(path);<br>        &#125;<br><br>        <span class="hljs-built_in">dfs</span>(root-&gt;left, targetSum, sum);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right, targetSum, sum);<br>        path.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-47"><a href="#Reference-47" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/390314/">[1]. yxc</a></p>
<br>


<h3 id="LeetCode-141-环形链表"><a href="#LeetCode-141-环形链表" class="headerlink" title="LeetCode 141. 环形链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle/">LeetCode 141. 环形链表</a></h3><hr>
<h4 id="基本思路-66"><a href="#基本思路-66" class="headerlink" title="基本思路"></a>基本思路</h4><p>思路1<br>直接开一个哈希表，然后存入每一个节点，如果一个节点重复出现，那么就有环</p>
<p>思路2<br>快慢指针，慢指针一次一步，快指针一次两步，如果有环快慢指针会重合，否则快指针先到空的位置</p>
<h4 id="参考代码-65"><a href="#参考代码-65" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        unordered_map&lt;ListNode*, <span class="hljs-type">int</span>&gt; s;<br>        <span class="hljs-keyword">while</span> (head) &#123;<br>            s[head] += <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (s[head] &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            head = head-&gt;next; <br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路2
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head || !head-&gt;next) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">auto</span> p = head, q = head-&gt;next;<br>        <span class="hljs-keyword">while</span> (p != q &amp;&amp; p &amp;&amp; q &amp;&amp; q-&gt;next) &#123;<br>            p = p-&gt;next;<br>            q = q-&gt;next-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p == q; <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-48"><a href="#Reference-48" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/404934/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-142-环形链表-II"><a href="#LeetCode-142-环形链表-II" class="headerlink" title="LeetCode 142. 环形链表 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/">LeetCode 142. 环形链表 II</a></h3><hr>
<h4 id="基本思路-67"><a href="#基本思路-67" class="headerlink" title="基本思路"></a>基本思路</h4><p>在环形链表1的基础上，还需要找到入口的位置，这里我们通过数学证明知道，相遇的时候，慢指针不会超过一圈，所以可以知道起点到入口的距离，等于相遇点到入口的距离<br>所以还是双指针，同时移动一格，相遇的时候就是入口</p>
<h4 id="参考代码-66"><a href="#参考代码-66" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head || !head-&gt;next) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-keyword">auto</span> slow = head, fast = head-&gt;next;<br>        <br>        <span class="hljs-keyword">while</span> (slow != fast &amp;&amp; slow &amp;&amp; fast &amp;&amp; fast-&gt;next) &#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (slow != fast) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">auto</span> a = head, b = fast-&gt;next;<br>            <span class="hljs-keyword">while</span> (a != b) &#123;<br>                a = a-&gt;next, b = b-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">return</span> a;<br>            &#125;<br>        &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-49"><a href="#Reference-49" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/404952/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-143-重排链表"><a href="#LeetCode-143-重排链表" class="headerlink" title="LeetCode 143. 重排链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reorder-list/">LeetCode 143. 重排链表</a></h3><hr>
<h4 id="基本思路-68"><a href="#基本思路-68" class="headerlink" title="基本思路"></a>基本思路</h4><p>思路1<br>如果是线性表这题直接双指针指向头尾，然后依次处理就行，但是需要额外的空间</p>
<p>思路2<br>最直接的思路，就是需要枚举出中点前的所有节点，和中点后的所有节点，枚举一些点所以很明显就是遍历然后放入新链表，然后这两个链表合并<br>所以几个步骤 1.找到中点 2.反转中点后面的列表 3.中点前的节点和中点后的节点分别放入两个新链表 4.合并这两个链表</p>
<h4 id="参考代码-67"><a href="#参考代码-67" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        vector&lt;ListNode *&gt; vec;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = head; p; p = p-&gt;next) &#123;<br>            vec.<span class="hljs-built_in">push_back</span>(p);<br>        &#125;<br><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = vec.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            vec[i++]-&gt;next = vec[j];<br>            <span class="hljs-keyword">if</span> (i == j) <span class="hljs-keyword">break</span>;<br>            vec[j--]-&gt;next = vec[i];<br>        &#125;<br>        vec[i]-&gt;next = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路2
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> mid = <span class="hljs-built_in">getMiddle</span>(head);<br>        <span class="hljs-keyword">auto</span> rHead = <span class="hljs-built_in">reverseList</span>(mid);<br>        <span class="hljs-keyword">auto</span> lHead = head;<br>        <span class="hljs-keyword">while</span> (lHead-&gt;next != rHead &amp;&amp; lHead != rHead)&#123;<br>            <span class="hljs-keyword">auto</span> rNext = rHead-&gt;next;<br>            rHead-&gt;next = lHead-&gt;next;<br>            lHead-&gt;next = rHead;<br>            rHead = rNext;<br>            lHead = lHead-&gt;next-&gt;next;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">getMiddle</span><span class="hljs-params">(ListNode* head)</span></span>&#123;<br>        <span class="hljs-keyword">auto</span> slow = head, fast = head;<br>        <span class="hljs-keyword">while</span> (fast &amp;&amp; fast-&gt;next)&#123;<br>            slow = slow-&gt;next, fast = fast-&gt;next-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span></span>&#123;<br>        <span class="hljs-keyword">auto</span> a = head, b = head-&gt;next;<br>        <span class="hljs-keyword">while</span> (b)&#123;<br>            <span class="hljs-keyword">auto</span> tmp = b-&gt;next;<br>            b-&gt;next = a;<br>            a = b, b = tmp;<br>        &#125;<br>        head-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>


<h4 id="Reference-50"><a href="#Reference-50" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/2947/">[1]. LeetCode 143. Reorder List</a></p>
<br>

<h3 id="LeetCode-144-二叉树的前序遍历"><a href="#LeetCode-144-二叉树的前序遍历" class="headerlink" title="LeetCode 144. 二叉树的前序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">LeetCode 144. 二叉树的前序遍历</a></h3><hr>
<h4 id="基本思路-69"><a href="#基本思路-69" class="headerlink" title="基本思路"></a>基本思路</h4><p>二叉树的前序遍历，代码很简单，但是内部蕴含的思想需要深究，一下给出许多版本的代码，供思考</p>
<p>参照中序遍历</p>
<h4 id="参考代码-68"><a href="#参考代码-68" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        递归
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> &#123;&#125;;<br>        <span class="hljs-built_in">traversal</span>(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>        res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">traversal</span>(root-&gt;left);<br>        <span class="hljs-built_in">traversal</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        迭代 不加标记
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        stack&lt;TreeNode*&gt; stk;<br><br>        <span class="hljs-keyword">while</span> (root || stk.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">while</span> (root) &#123;<br>                res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>                stk.<span class="hljs-built_in">push</span>(root);<br>                root = root-&gt;left;<br>            &#125;<br><br>            root = stk.<span class="hljs-built_in">top</span>();<br>            stk.<span class="hljs-built_in">pop</span>();<br>            root = root-&gt;right;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        迭代 + 标记 + 空节点不入栈
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br><br>        unordered_map&lt;TreeNode*, <span class="hljs-type">int</span>&gt; vis;<br>        stack&lt;TreeNode*&gt; stk;<br><br>        <span class="hljs-keyword">while</span> (root || stk.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">while</span> (root) &#123;<br>                vis[root] = <span class="hljs-number">1</span>;<br>                res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>                stk.<span class="hljs-built_in">push</span>(root);<br>                root = root-&gt;left;<br>            &#125;<br><br>            root = stk.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span> (vis[root] == <span class="hljs-number">1</span>) &#123;<br>                vis[root] = <span class="hljs-number">2</span>;<br>                root = root-&gt;right;<br>            &#125;<br><br>            <span class="hljs-keyword">else</span> &#123;<br>                stk.<span class="hljs-built_in">pop</span>();<br>                root = <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        迭代 + 标记 + 空节点入栈
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        stack&lt;pair&lt;TreeNode*, <span class="hljs-type">int</span>&gt;&gt;stk;<br>        stk.<span class="hljs-built_in">push</span>(&#123;root, <span class="hljs-number">0</span>&#125;);<br>        <span class="hljs-keyword">while</span> (stk.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span> (stk.<span class="hljs-built_in">top</span>().first == <span class="hljs-literal">NULL</span>)<br>            &#123;<br>                stk.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> t = stk.<span class="hljs-built_in">top</span>().second;<br>            <span class="hljs-keyword">if</span> (t == <span class="hljs-number">0</span>)<br>            &#123;<br>                res.<span class="hljs-built_in">push_back</span>(stk.<span class="hljs-built_in">top</span>().first-&gt;val);<br>                stk.<span class="hljs-built_in">top</span>().second = <span class="hljs-number">1</span>;<br>                stk.<span class="hljs-built_in">push</span>(&#123;stk.<span class="hljs-built_in">top</span>().first-&gt;left, <span class="hljs-number">0</span>&#125;);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t == <span class="hljs-number">1</span>)<br>            &#123;<br>                stk.<span class="hljs-built_in">top</span>().second = <span class="hljs-number">2</span>;<br>                stk.<span class="hljs-built_in">push</span>(&#123;stk.<span class="hljs-built_in">top</span>().first-&gt;right, <span class="hljs-number">0</span>&#125;);<br>            &#125;<br>            <span class="hljs-keyword">else</span> stk.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<br>

<h4 id="Reference-51"><a href="#Reference-51" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/404978/">[1]. yxc</a></p>
<br>


<h3 id="LeetCode-145-二叉树的后序遍历"><a href="#LeetCode-145-二叉树的后序遍历" class="headerlink" title="LeetCode 145. 二叉树的后序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">LeetCode 145. 二叉树的后序遍历</a></h3><hr>
<h4 id="基本思路-70"><a href="#基本思路-70" class="headerlink" title="基本思路"></a>基本思路</h4><p>二叉树的后序遍历，代码很简单，但是内部蕴含的思想需要深究，一下给出许多版本的代码，供思考</p>
<p>参照中序遍历，这里不加标记的迭代法，有两种做法</p>
<h4 id="参考代码-69"><a href="#参考代码-69" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        递归
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> &#123;&#125;;<br>        <span class="hljs-built_in">traversal</span>(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">traversal</span>(root-&gt;left);<br>        <span class="hljs-built_in">traversal</span>(root-&gt;right);<br>        res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        迭代 + 不加标记 + prev
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        stack&lt;TreeNode*&gt; stk;<br>        TreeNode* prev = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span> (root || stk.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">while</span> (root) &#123;<br>                stk.<span class="hljs-built_in">push</span>(root);<br>                root = root-&gt;left;<br>            &#125;<br><br>            root = stk.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span> (root-&gt;right == <span class="hljs-literal">nullptr</span> || prev == root-&gt;right) &#123;<br>                stk.<span class="hljs-built_in">pop</span>();<br>                res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>                prev = root;<br>                root = <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> root = root-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        迭代 + 不加标记 + trick做法
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        stack&lt;TreeNode*&gt; stk;<br>        <span class="hljs-keyword">while</span> (root || stk.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">while</span> (root) &#123;<br>                res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>                stk.<span class="hljs-built_in">push</span>(root);<br>                root = root-&gt;right;<br>            &#125;<br><br>            root = stk.<span class="hljs-built_in">top</span>();<br>            stk.<span class="hljs-built_in">pop</span>();<br>            root = root-&gt;left;<br>        &#125;<br><br>        <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>



<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        迭代 + 标记 + 空节点不入栈
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br><br>        unordered_map&lt;TreeNode*, <span class="hljs-type">int</span>&gt; vis;<br>        stack&lt;TreeNode*&gt; stk;<br><br>        <span class="hljs-keyword">while</span> (root || stk.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">while</span> (root) &#123;<br>                vis[root] = <span class="hljs-number">1</span>;<br>                stk.<span class="hljs-built_in">push</span>(root);<br>                root = root-&gt;left;<br>            &#125;<br><br>            root = stk.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span> (vis[root] == <span class="hljs-number">1</span>) &#123;<br>                vis[root] = <span class="hljs-number">2</span>;<br>                root = root-&gt;right;<br>            &#125;<br><br>            <span class="hljs-keyword">else</span> &#123;<br>                stk.<span class="hljs-built_in">pop</span>();<br>                res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>                root = <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        迭代 + 标记 + 空节点入栈
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        stack&lt;pair&lt;TreeNode*, <span class="hljs-type">int</span>&gt;&gt;stk;<br>        stk.<span class="hljs-built_in">push</span>(&#123;root, <span class="hljs-number">0</span>&#125;);<br>        <span class="hljs-keyword">while</span> (stk.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span> (stk.<span class="hljs-built_in">top</span>().first == <span class="hljs-literal">NULL</span>)<br>            &#123;<br>                stk.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> t = stk.<span class="hljs-built_in">top</span>().second;<br>            <span class="hljs-keyword">if</span> (t == <span class="hljs-number">0</span>)<br>            &#123;<br>                stk.<span class="hljs-built_in">top</span>().second = <span class="hljs-number">1</span>;<br>                stk.<span class="hljs-built_in">push</span>(&#123;stk.<span class="hljs-built_in">top</span>().first-&gt;left, <span class="hljs-number">0</span>&#125;);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t == <span class="hljs-number">1</span>)<br>            &#123;<br>                stk.<span class="hljs-built_in">top</span>().second = <span class="hljs-number">2</span>;<br>                stk.<span class="hljs-built_in">push</span>(&#123;stk.<span class="hljs-built_in">top</span>().first-&gt;right, <span class="hljs-number">0</span>&#125;);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                res.<span class="hljs-built_in">push_back</span>(stk.<span class="hljs-built_in">top</span>().first-&gt;val);<br>                stk.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<br>

<h4 id="Reference-52"><a href="#Reference-52" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/404993/">[1]. yxc</a></p>
<br>

<h3 id="LeetCode-146-LRU缓存机制"><a href="#LeetCode-146-LRU缓存机制" class="headerlink" title="LeetCode 146. LRU缓存机制"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lru-cache/">LeetCode 146. LRU缓存机制</a></h3><hr>
<h4 id="基本思路-71"><a href="#基本思路-71" class="headerlink" title="基本思路"></a>基本思路</h4><p>设计类的题目一定要分析清楚题意再下手。<br>首先此题需要的数据结构需要有key-value对，然后get和put都需要在O(1)级别，所以很容易想到我们开个哈希表来维护。<br>然后对于get和put的不存在后的操作哈希表都可以完成，但是对于LRU机制是如果超过容量，需要把<strong>最久未使用</strong>的key删掉，这里涉及到了时间戳，也就是说我们需要对每个key加上时间戳的概念。<br>所以我们可以联想到队列，先入先出，这样就可以通过队列完成时间戳。对于LRU缓存机制我们这里需要对任意key删除后放到队头，然后超过容量就删掉队尾。<br>这里STL里的queue只能入队出队无法完成我们的操作，所以这里我们使用双链表实现队列（注意不能使用单链表，单链表删除是O(n))</p>
<p>所以数据结构确定下来了，就是利用双链表+哈希表来实现</p>
<h4 id="参考代码-70"><a href="#参考代码-70" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-keyword">public</span>:<br>            <span class="hljs-type">int</span> key, val;<br>            Node* left, *right;<br>            <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> _key, <span class="hljs-type">int</span> _val) : <span class="hljs-built_in">key</span>(_key), <span class="hljs-built_in">val</span>(_val), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>    &#125; *L, *R; <span class="hljs-comment">// 两个哨兵结点</span><br><br>    <span class="hljs-comment">// 从双链表里删除一个元素</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Node* p)</span> </span>&#123;<br>        p-&gt;left-&gt;right = p-&gt;right;<br>        p-&gt;right-&gt;left = p-&gt;left;<br>    &#125;<br><br>    <span class="hljs-comment">// 在双链表的最左侧插入一个元素</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Node* p)</span> </span>&#123;<br>        p-&gt;right = L-&gt;right;<br>        p-&gt;left = L;<br>        p-&gt;right-&gt;left = p;<br>        p-&gt;left-&gt;right = p;<br>    &#125;<br><br>    <span class="hljs-type">int</span> n;<br>    unordered_map&lt;<span class="hljs-type">int</span>, Node*&gt; hash;<br><br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> capacity) &#123;<br>        n = capacity;<br>        L = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>), R = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>);<br>        L -&gt; right = R, R -&gt; left = L;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!hash.<span class="hljs-built_in">count</span>(key))<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">auto</span> p = hash[key];<br>        <span class="hljs-comment">// 因为访问了，所以要把它移动到最左边</span><br>        <span class="hljs-built_in">remove</span>(p);<br>        <span class="hljs-built_in">insert</span>(p);<br>        <span class="hljs-keyword">return</span> p-&gt;val;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">count</span>(key)) &#123; <span class="hljs-comment">// 表里有这个元素</span><br>            <span class="hljs-keyword">auto</span> p = hash[key];<br>            p-&gt;val = value;<br>            <span class="hljs-built_in">remove</span>(p);<br>            <span class="hljs-built_in">insert</span>(p);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 表里没有这个元素</span><br>            <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">size</span>() == n) &#123; <span class="hljs-comment">// 表满了，要删除一个最右边的</span><br>                <span class="hljs-keyword">auto</span> p = R-&gt;left;<br>                hash.<span class="hljs-built_in">erase</span>(p-&gt;key);<br>                <span class="hljs-built_in">remove</span>(p);<br>                <span class="hljs-keyword">delete</span> p;<br>            &#125;<br>            <span class="hljs-comment">// 插入元素</span><br>            <span class="hljs-keyword">auto</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(key, value);<br>            <span class="hljs-built_in">insert</span>(p);<br>            hash[key] = p;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LRUCache* obj = new LRUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;get(key);</span><br><span class="hljs-comment"> * obj-&gt;put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-53"><a href="#Reference-53" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/562452/">[1]. LauZyHou</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/63191/">[2]. 有心人</a></p>
<h3 id="LeetCode-150-逆波兰表达式求值"><a href="#LeetCode-150-逆波兰表达式求值" class="headerlink" title="LeetCode 150. 逆波兰表达式求值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">LeetCode 150. 逆波兰表达式求值</a></h3><hr>
<h4 id="基本思路-72"><a href="#基本思路-72" class="headerlink" title="基本思路"></a>基本思路</h4><p>模拟题，用栈去模拟后缀表达式的计算过程<br>如果当前元素是数，那就压入栈；如果是运算符，那就将栈顶两个元素弹出做相应运算，然后将结果入栈</p>
<p>题目很简单，但是背后蕴含的一些思路我们这里深究一下</p>
<p>首先对于后缀表达式和前缀表达式，其实都对应了一棵表达式树（叶节点是数字，内部节点是运算符）：<br>中缀表达式其实就是表达式树的中序遍历<br>后缀表达式其实就是表达式树的后序遍历</p>
<p>所以最直接的做法可以建树，然后递归来做（递归函数里是求左右子树的值，然后根据节点的运算符求职）<br>这里用栈模拟达到递归的效果</p>
<blockquote>
<p>人类一般用中缀表达式计算，计算机用后缀表达式计算。</p>
</blockquote>
<h4 id="参考代码-71"><a href="#参考代码-71" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; stk;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eval</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> b = stk.<span class="hljs-built_in">top</span>(); stk.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> a = stk.<span class="hljs-built_in">top</span>(); stk.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-string">&quot;+&quot;</span>) stk.<span class="hljs-built_in">push</span>(a + b);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s == <span class="hljs-string">&quot;-&quot;</span>) stk.<span class="hljs-built_in">push</span>(a - b);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s == <span class="hljs-string">&quot;*&quot;</span>) stk.<span class="hljs-built_in">push</span>(a * b);<br>        <span class="hljs-keyword">else</span> stk.<span class="hljs-built_in">push</span>(a / b);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">evalRPN</span><span class="hljs-params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;<br>        unordered_set&lt;string&gt; S&#123;<span class="hljs-string">&quot;+&quot;</span>, <span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;s: tokens) &#123;<br>            <span class="hljs-keyword">if</span> (S.<span class="hljs-built_in">count</span>(s)) <span class="hljs-built_in">eval</span>(s);<br>            <span class="hljs-keyword">else</span> stk.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">stoi</span>(s));<br>        &#125;<br>        <span class="hljs-keyword">return</span> stk.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="Reference-54"><a href="#Reference-54" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/89218/">[1]. 详细笔记</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/19036/">[2]. 小呆呆</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/562864/">[3]. LauZyHou</a></p>
<br>

<h3 id="LeetCode-203-移除链表元素"><a href="#LeetCode-203-移除链表元素" class="headerlink" title="LeetCode 203. 移除链表元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-linked-list-elements/">LeetCode 203. 移除链表元素</a></h3><hr>
<h4 id="基本思路-73"><a href="#基本思路-73" class="headerlink" title="基本思路"></a>基本思路</h4><p>新建一个列表，然后遍历原链表，满足的放进去，不满足的就跳过，注意tail最后是原链表最后一个满足的点，后面还是有其他节点的<br>所以tail之后要指向空</p>
<h4 id="参考代码-72"><a href="#参考代码-72" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        迭代法
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>), tail = dummy;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = head; p; p = p-&gt;next)<br>            <span class="hljs-keyword">if</span> (p-&gt;val != val)<br>                tail = tail-&gt;next = p;<br>        tail-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-55"><a href="#Reference-55" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/422060/">[1]. yxc</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/420363/">[2]. other</a></p>
<h3 id="LeetCode-206-反转链表"><a href="#LeetCode-206-反转链表" class="headerlink" title="LeetCode 206. 反转链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/">LeetCode 206. 反转链表</a></h3><hr>
<h4 id="基本思路-74"><a href="#基本思路-74" class="headerlink" title="基本思路"></a>基本思路</h4><p><strong>迭代法</strong><br>链表的题目也是注意画图和思维流程</p>
<ol>
<li>首先要反转相邻两个节点间的指针，所以需要拿到这两个节点，“一段”直接枚举，然后指针移动即可</li>
<li>具体逻辑，就是改变后一个点的next，然后移动到下一段</li>
<li>最后把第一个节点的next指向空，然后返回新的头节点</li>
</ol>
<p>时间复杂度：只遍历一次链表，$O(n)$<br>空间复杂度：遍历时只有3个额外变量,$O(1)$</p>
<p><strong>递归法</strong><br>递归法主要就是明确递归函数的定义，reverseList 函数能做什么，它可以翻转一个链表，并返回新链表的头节点，也就是原链表的尾节点<br>然后结合定义直接处理剩余的步骤。</p>
<ol>
<li>递归处理 reverseList(head-&gt;next)，这样我们可以将以head-&gt;next为头节点的链表翻转，并得到原链表的尾节点tail。</li>
<li>此时head-&gt;next是新链表的尾节点，我们令它的next指针指向head，并将head-&gt;next指向空即可将整个链表翻转，且新链表的头节点是tail</li>
</ol>
<p>时间复杂度：只遍历一次链表，$O(n)$<br>空间复杂度：总共递归 n 层，系统栈的空间复杂度是$O(n)$</p>
<blockquote>
<p>这里我们需要知道为什么可以用递归，以及怎么写递归函数<br>  递归其实就是不断地层层进入，直到达到边界开始层层回溯到起点得到答案，所以我们先看看怎么进入，进入代码里对应的就是递归函数的写法，需要可以不断地进入，链表题一般是通过next<br>  然后看能否到达边界，这里的边界其实就是head指针移动到最后一个点或者是空点，因为这个时候反转的结果是它自己。所以此题可以用递归法做</p>
</blockquote>
<h4 id="参考代码-73"><a href="#参考代码-73" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        迭代法
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">auto</span> a = head, b = a-&gt;next;<br>        <span class="hljs-keyword">while</span> (b) &#123;<br>            <span class="hljs-keyword">auto</span> c = b-&gt;next;<br>            b-&gt;next = a;<br>            a = b;<br>            b = c;<br>        &#125;<br>        head-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        递归法
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head || !head-&gt;next) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-keyword">auto</span> tail = <span class="hljs-built_in">reverseList</span>(head-&gt;next);<br>        head-&gt;next-&gt;next = head;<br>        head-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> tail;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-56"><a href="#Reference-56" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/316/">[1]. Reverse Linked List</a></p>
<br>

<h3 id="LeetCode-215-数组中的第K个最大元素"><a href="#LeetCode-215-数组中的第K个最大元素" class="headerlink" title="LeetCode 215. 数组中的第K个最大元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">LeetCode 215. 数组中的第K个最大元素</a></h3><h4 id="基本思路-75"><a href="#基本思路-75" class="headerlink" title="基本思路"></a>基本思路</h4><p>模板题，快速选择算法，注意这里求的是第k大的元素，所以排序的时候翻转一下，其他的没区别</p>
<p>时间复杂度：$O(n)$<br>空间复杂度：$O(logn)$</p>
<h4 id="参考代码-74"><a href="#参考代码-74" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        快选模板
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">quick_select</span>(nums, <span class="hljs-number">0</span> , nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, k);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quick_select</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> nums[r];<br><br>        <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = nums[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (nums[i] &gt; x);<br>            <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (nums[j] &lt; x);<br>            <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br>        &#125;<br><br>        <span class="hljs-type">int</span> sl = j - l + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (k &lt;= sl) <span class="hljs-keyword">return</span> <span class="hljs-built_in">quick_select</span>(nums, l, j, k);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">quick_select</span>(nums, j + <span class="hljs-number">1</span>, r, k - sl);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-57"><a href="#Reference-57" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/597477/">[1]. LauZyHou</a><br><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/63587/">[2]. 其他解法汇总</a></p>
<br>

<h3 id="LeetCode-237-删除链表中的节点"><a href="#LeetCode-237-删除链表中的节点" class="headerlink" title="LeetCode 237. 删除链表中的节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-node-in-a-linked-list/">LeetCode 237. 删除链表中的节点</a></h3><hr>
<h4 id="基本思路-76"><a href="#基本思路-76" class="headerlink" title="基本思路"></a>基本思路</h4><p>这题是一个比较特殊的一题，它无法访问头节点，所以我们无法用常规地找到前一个节点来删除，这里用了一个比较trick的做法，就是让当前节点<strong>覆盖</strong>成后一个节点，就可以达到删除的效果<br>但是这个方法没办法删除尾节点，因为尾节点不存在后一个节点</p>
<h4 id="参考代码-75"><a href="#参考代码-75" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        分步
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode* node)</span> </span>&#123;<br>        node-&gt;val = node-&gt;next-&gt;val;<br>        node-&gt;next = node-&gt;next-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        一步到位
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode* node)</span> </span>&#123;<br>        *node = *(node-&gt;next);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<br>

<h3 id="LeetCode-445-两数相加-II"><a href="#LeetCode-445-两数相加-II" class="headerlink" title="LeetCode 445. 两数相加 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/add-two-numbers-ii/">LeetCode 445. 两数相加 II</a></h3><hr>
<h4 id="基本思路-77"><a href="#基本思路-77" class="headerlink" title="基本思路"></a>基本思路</h4><p>因为这里低位在右边，所以为了从低位开始相加，所以反转链表<br>然后反转完后，得到的结果我们要保证低位在右边，所以新加的点往前放，所以头插法</p>
<h4 id="参考代码-76"><a href="#参考代码-76" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        yxc
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> a = head, b = head-&gt;next;<br>        <span class="hljs-keyword">while</span> (b) &#123;<br>            <span class="hljs-keyword">auto</span> c = b-&gt;next;<br>            b-&gt;next = a;<br>            a = b, b = c;<br>        &#125;<br>        head-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        l1 = <span class="hljs-built_in">reverse</span>(l1), l2 = <span class="hljs-built_in">reverse</span>(l2);<br>        <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (l1 || l2 || t) &#123;<br>            <span class="hljs-keyword">if</span> (l1) t += l1-&gt;val, l1 = l1-&gt;next;<br>            <span class="hljs-keyword">if</span> (l2) t += l2-&gt;val, l2 = l2-&gt;next;<br>            <span class="hljs-keyword">auto</span> cur = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(t % <span class="hljs-number">10</span>);<br>            cur-&gt;next = dummy-&gt;next;<br>            dummy-&gt;next = cur;<br>            t /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>


<h4 id="Reference-58"><a href="#Reference-58" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/541543/">[1]. yxc</a></p>
<BR>

<h3 id="LeetCode-876-链表的中间结点"><a href="#LeetCode-876-链表的中间结点" class="headerlink" title="LeetCode 876. 链表的中间结点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/middle-of-the-linked-list/">LeetCode 876. 链表的中间结点</a></h3><hr>
<h4 id="基本思路-78"><a href="#基本思路-78" class="headerlink" title="基本思路"></a>基本思路</h4><p>思路1<br>快慢指针，同一起点出发，当快指针下一个节点为空或者快指针为空，慢指针走到中点<br>如果想拿</p>
<p>思路2<br>两次遍历，第一次得到链表长度，第二次拿到中点<br>拓展 如果偶数拿后面的节点 奇偶中点都是 n &#x2F; 2 + 1;如果偶数拿前面的节点 (n + 1) &#x2F; 2.</p>
<h4 id="参考代码-77"><a href="#参考代码-77" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路1
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">middleNode</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> slow = head, fast = head;<br>        <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        思路2
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">middleNode</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p = head; p != <span class="hljs-literal">NULL</span>; p = p-&gt;next) n ++;<br>        <span class="hljs-keyword">auto</span> res = head;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n / <span class="hljs-number">2</span>;i ++) res = res-&gt;next;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="Reference-59"><a href="#Reference-59" class="headerlink" title="Reference"></a>Reference</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/1250718/">[1]. gaoren</a></p>
<h2 id="LeetCode-901-1000"><a href="#LeetCode-901-1000" class="headerlink" title="LeetCode 901 - 1000"></a>LeetCode 901 - 1000</h2><h3 id="LeetCode-912-排序数组"><a href="#LeetCode-912-排序数组" class="headerlink" title="LeetCode 912. 排序数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-an-array/">LeetCode 912. 排序数组</a></h3><hr>
<h4 id="基本思路-79"><a href="#基本思路-79" class="headerlink" title="基本思路"></a>基本思路</h4><p>快速排序，归并排序，堆排序，主要是掌握这三种排序</p>
<h4 id="参考代码-78"><a href="#参考代码-78" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        快选模板
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">quick_sort</span>(nums, <span class="hljs-number">0</span> , n - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;q, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(q[i] &lt; x);<br>            <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(q[j] &gt; x);<br>            <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>        &#125;<br><br>        <span class="hljs-built_in">quick_sort</span>(q, l, j);<br>        <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);<br>    &#125; <br>&#125;;<br></code></pre></td></tr></table></figure>
    </div>
</div>



<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" class="category-chain-item">算法笔记</a>
  
  
    <span>></span>
    
  <a href="/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/LeetCode/" class="category-chain-item">LeetCode</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>LeetCode题目合集</div>
      <div>https://vendestine.com/2023/01/10/算法笔记/leetcode/leetcode-1-100/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Wenzhe Li</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>January 10, 2023</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/01/11/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/leetcode/binary-tree/" title="算法-二叉树">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">算法-二叉树</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/11/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/flask-note/" title="Python-Flask开发笔记">
                        <span class="hidden-mobile">Python-Flask开发笔记</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"IjvyDUC4CWIE5z0piBf1Dqia-9Nh9j0Va","appKey":"KQ2019uci92UXL6srhLsiY9K","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        Views: 
        <span id="leancloud-site-pv"></span>
        
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        Visitors: 
        <span id="leancloud-site-uv"></span>
        
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
