

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Wenzhe Li">
  <meta name="keywords" content="">
  
    <meta name="description" content="C++ primer 第一部分 包含前七章内容：变量，字符串，向量，数组，表达式，语句，函数，类">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Primer Part1 - C++基础">
<meta property="og:url" content="https://vendestine.com/2023/04/07/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/c++-primer-p1/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="C++ primer 第一部分 包含前七章内容：变量，字符串，向量，数组，表达式，语句，函数，类">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://vendestine.com/img/C++.png">
<meta property="article:published_time" content="2023-04-07T15:56:09.000Z">
<meta property="article:modified_time" content="2023-08-13T09:21:07.659Z">
<meta property="article:author" content="Wenzhe Li">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="C++ Primer">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://vendestine.com/img/C++.png">
  
  
  
  <title>C++ Primer Part1 - C++基础 - Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"vendestine.com","root":"/","version":"1.9.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"rsfCNwYEYG167BlEXzFi6nFM-9Nh9j0Va","app_key":"YgnhSGLdGVYg7L4mapy5ab5f","server_url":"https://rsfcnwye.lc-cn-e1-shared.com","path":"window.location.pathname","ignore_local":true}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Vendestine&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/fox.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="C++ Primer Part1 - C++基础"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-04-07 11:56" pubdate>
          April 7, 2023 am
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          58k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          480 mins
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> views
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar category-bar" style="margin-right: -1rem">
    





<div class="category-list">
  
  
    
    
    
    <div class="category row nomargin-x">
      <a class="category-item 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="编程语言"
        id="heading-3bf8a523aea21a3a0f6c53b0f43429bb" role="tab" data-toggle="collapse" href="#collapse-3bf8a523aea21a3a0f6c53b0f43429bb"
        aria-expanded="true"
      >
        编程语言
        <span class="list-group-count">(9)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-3bf8a523aea21a3a0f6c53b0f43429bb"
           role="tabpanel" aria-labelledby="heading-3bf8a523aea21a3a0f6c53b0f43429bb">
        
        
          
          
  <div class="category-post-list">
    
    
  </div>

          
  
    
    
    
    <div class="category-sub row nomargin-x">
      <a class="category-subitem collapsed
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="Assembly"
        id="heading-d75c45e11c8aeb13494dba59a388a164" role="tab" data-toggle="collapse" href="#collapse-d75c45e11c8aeb13494dba59a388a164"
        aria-expanded="false"
      >
        Assembly
        <span class="list-group-count">(1)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse " id="collapse-d75c45e11c8aeb13494dba59a388a164"
           role="tabpanel" aria-labelledby="heading-d75c45e11c8aeb13494dba59a388a164">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/2023/09/06/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Assembly/x86_att_tutorial/" title="x86 AT&amp;T语法 汇编语言入门教程"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">x86 AT&amp;T语法 汇编语言入门教程</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
    
    
    
    <div class="category-sub row nomargin-x">
      <a class="category-subitem 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="C++"
        id="heading-f6f87c9fdcf8b3c3f07f93f1ee8712c9" role="tab" data-toggle="collapse" href="#collapse-f6f87c9fdcf8b3c3f07f93f1ee8712c9"
        aria-expanded="true"
      >
        C++
        <span class="list-group-count">(5)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-f6f87c9fdcf8b3c3f07f93f1ee8712c9"
           role="tabpanel" aria-labelledby="heading-f6f87c9fdcf8b3c3f07f93f1ee8712c9">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/2023/04/07/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/c++-primer-p1/" title="C++ Primer Part1 - C++基础"
           class="list-group-item list-group-item-action
           active">
          <span class="category-post">C++ Primer Part1 - C++基础</span>
        </a>
      
    
      
      
        <a href="/2022/05/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/c-basic-1/" title="C++ 基础入门"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">C++ 基础入门</span>
        </a>
      
    
      
      
        <a href="/2022/07/02/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/c-question/" title="C++ 常见问题汇总"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">C++ 常见问题汇总</span>
        </a>
      
    
      
      
        <a href="/2022/05/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/c-basic-3/" title="C++ 提高编程"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">C++ 提高编程</span>
        </a>
      
    
      
      
        <a href="/2022/05/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/c-basic-2/" title="C++ 核心编程"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">C++ 核心编程</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
    
    
    
    <div class="category-sub row nomargin-x">
      <a class="category-subitem collapsed
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="Python"
        id="heading-a7f5f35426b927411fc9231b56382173" role="tab" data-toggle="collapse" href="#collapse-a7f5f35426b927411fc9231b56382173"
        aria-expanded="false"
      >
        Python
        <span class="list-group-count">(3)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse " id="collapse-a7f5f35426b927411fc9231b56382173"
           role="tabpanel" aria-labelledby="heading-a7f5f35426b927411fc9231b56382173">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/2022/11/13/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/django-note/" title="Python-Django开发笔记"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Python-Django开发笔记</span>
        </a>
      
    
      
      
        <a href="/2022/11/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/flask-note/" title="Python-Flask开发笔记"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Python-Flask开发笔记</span>
        </a>
      
    
      
      
        <a href="/2022/07/20/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/python-basic/" title="Python-基础语法笔记"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Python-基础语法笔记</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
        
      </div>
    </div>
  
</div>


  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">C++ Primer Part1 - C++基础</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="第一章：开始"><a href="#第一章：开始" class="headerlink" title="第一章：开始"></a>第一章：开始</h1><h3 id="main函数的返回值"><a href="#main函数的返回值" class="headerlink" title="main函数的返回值"></a>main函数的返回值</h3><hr>
<p>在大多数系统中，main的返回值被用来指示状态，返回值0表明成功，非0的返回值的含义由系统定义，通常用来指出错误类型。</p>
<p><strong>那么我们如何拿到main的返回值呢？</strong><br>访问main的返回值的方法依赖于系统。在UNIX和Windows系统中，执行完一个程序后，都可以通过echo命令获得其返回值。<br>UNIX： <code>echo $?</code><br>Windows: <code>echo %ERRORLEVEL%</code></p>
<br>

<h3 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h3><hr>
<p>编写好程序后，我们就需要编译它。如何编译程序依赖于你使用的操作系统和编译器。</p>
<h4 id="文件命名约定"><a href="#文件命名约定" class="headerlink" title="文件命名约定"></a>文件命名约定</h4><ul>
<li><a target="_blank" rel="noopener" href="http://labor-liber.org/en/gnu-linux/development/index.php?diapo=extensions">GNU</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/build/reference/file-types-created-for-visual-cpp-projects?redirectedfrom=MSDN&view=msvc-170">MSVC</a></li>
</ul>
<h4 id="命令行运行编译器"><a href="#命令行运行编译器" class="headerlink" title="命令行运行编译器"></a>命令行运行编译器</h4><p><strong>GNU</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ -o prog1 prog1.cc<br>-o prog1 是编译器参数，指定了可执行文件的文件名<br><br>g++ --std=c++11 ch01.cpp -o main<br>有时候根据使用的GNU编译器的版本，可能需要指定-std=c++11参数来打开对C++11的支持<br></code></pre></td></tr></table></figure>

<p><strong>MSVC</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">cl /EHsc prog1.cpp<br>/EHsc 是编译器选项，用来打开标准异常处理<br></code></pre></td></tr></table></figure>

<br>

<h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><hr>
<blockquote>
<p>C++语言并未定义任何输入输出（IO）语句，取而代之，包含了一个全面的标准库（STL）来提供IO机制（以及很多其他设施）。</p>
</blockquote>
<h4 id="标准输入输出对象"><a href="#标准输入输出对象" class="headerlink" title="标准输入输出对象"></a>标准输入输出对象</h4><p>iostream库包含两个基础类型<strong>istream</strong>和<strong>ostream</strong>,分别表示输入流和输出流。<br>一个流就是一个字符序列，是从IO设备读出或写入IO设备的。</p>
<p>标准库定义了4个IO对象</p>
<ul>
<li><strong>cin</strong>  istream类型对象 标准输入</li>
<li><strong>cout</strong> ostream类型对象 标准输出</li>
<li><strong>cerr</strong> ostream类型对象 标准错误</li>
<li><strong>clog</strong> ostream类型对方 输出程序运行时的一般性信息</li>
</ul>
<br>

<h4 id="向流读写数据"><a href="#向流读写数据" class="headerlink" title="向流读写数据"></a>向流读写数据</h4><p><strong>写入数据</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::cout &lt;&lt; <span class="hljs-string">&quot;Hello, World&quot;</span> &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<p><strong>&lt;&lt;</strong> 运算符接受两个运算对象：左侧的运算对象必须是一个ostream对象，右侧的运算对象是要打印的值。此运算符将给定的值写到给定的的ostream对象中。<strong>输出运算符的计算结果就是其左侧运算对象</strong>。即计算结果就是我们写入给定值的那个ostream对象。</p>
<p>所以第一个运算符的结果成为了第二个运算符的左侧运算对象。这样，我们就可以将输出请求连接起来。</p>
<p><strong>endl</strong>：这是一个被称为操纵符（manipulator）的特殊值，效果是结束当前行，并将设备关联的缓冲区（buffer）中的内容刷到设备中。</p>
<p><strong>读取数据</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::cin &gt;&gt; v1 &gt;&gt; v2;<br></code></pre></td></tr></table></figure>

<p><strong>&gt;&gt;</strong> 运算符与输出运算符类似，它接受一个istream对象作为其左侧运算对象，接受一个对象作为其右侧运算对象。它从给定的的istream对象中读入数据，并存入给定对象当中。与输出运算符类似，输入运算符返回其左侧运算对象作为其运算结果。同理我们也可以将一系列输入请求合并到单一语句中。</p>
<br>

<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><hr>
<p>C++有两种注释：单行注释和界定符对注释。</p>
<ul>
<li>单行注释： &#x2F;&#x2F;   当前行双斜线右侧的所有内容都会被编译器忽略，这种注释可以包含任何文本，包括额外的双斜线</li>
<li>界定符注释： &#x2F;* …. *&#x2F;   编译器将落在区间内的所有内容都当作注释，包括换行符。</li>
</ul>
<p><strong>注释界定符不能嵌套</strong><br>&#x2F;*<br> <em>注释对&#x2F;</em>   *&#x2F; 不能嵌套<br>*&#x2F;<br><strong>此例中，“不能嵌套”会被当成源码处理，报错。</strong></p>
<p>调试的时候，我们注释的代码可能包含界定符注释，因此最好的方式是采取单行注释方式注释掉代码的每一行（实际上IDE中的选中多行注释，也是采取单行注释）</p>
<br>

<h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><hr>
<h4 id="while循环与for循环"><a href="#while循环与for循环" class="headerlink" title="while循环与for循环"></a>while循环与for循环</h4><p>看一个经典的程序，统计1到10的和</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// while循环写法</span><br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>, val  = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (val &lt;= <span class="hljs-number">10</span>)<br>&#123;<br>    sum += val;<br>    val++;<br>&#125;<br><br><span class="hljs-comment">// for循环写法</span><br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> val = <span class="hljs-number">1</span>; val &lt;= <span class="hljs-number">10</span>; val++)<br>&#123;<br>    sum + = val;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>两种形式的优缺点和应用</strong><br>在循环次数已知的情况下，for循环的形式更为简洁。</p>
<p>而循环次数无法预知的时候，用while循环实现显然更适合。用特定条件控制循环是否执行，循环体中执行的语句可能导致循环判定条件发生变化。</p>
<br>

<h4 id="读取数量不定的输入数据"><a href="#读取数量不定的输入数据" class="headerlink" title="读取数量不定的输入数据"></a>读取数量不定的输入数据</h4><p>看一个经典的程序，对用户输入的一组数求和</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//while循环写法</span><br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>, val = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (std::cin &gt;&gt; value)<br>&#123;<br>    sum += val;<br>&#125;<br><br><span class="hljs-comment">//for循环写法</span><br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> val; std::cin &gt;&gt; val; sum += val);<br></code></pre></td></tr></table></figure>

<p><strong>cin &gt;&gt; value 作为条件的意义</strong><br>当我们使用一个istream对象作为条件时，其效果是检测流的状态，如果流是有效的，即流未遇到错误，那么检测成功。当遇到文件结束符(end-of-file)，或遇到一个无效输入时(例如读入的值在上例中不是一个整数)，istream对象的状态会变为无效。处于无效状态的istream对象会使条件变为假。因此while循环会一直执行直至遇到eof或输入错误。</p>
<p><strong>文件结束符</strong><br>对于如何指出文件结束，不同操作系统有不同的约定。</p>
<ul>
<li>Windows: ctrl + z</li>
<li>UNIX: ctrl + d</li>
</ul>
<p><strong>编译错误</strong></p>
<ul>
<li>语法错误(syntax error)</li>
<li>类型错误(type error)</li>
<li>声明错误(declaration error)</li>
</ul>
<p>按照报告的顺序来逐个修正错误，是个好习惯，因为一个单个错误常常会具有传递效应，导致编译器在其后报告比实际数量多得多的错误信息。</p>
<p>另一个好习惯是在每修正一个错误后就立即更新编译代码，或者是最多修正了一部分明显的错误后就重新编译。这就是所谓的”编辑-编译-调试”(edit-compile-debug)周期。</p>
<br>

<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><hr>
<p><strong>头文件</strong><br>类的类型一般存储在头文件中，标准库的头文件使用&lt;&gt;，非标准库的头文件使用””。申明写在.h文件，定义实现写在.cpp文件。</p>
<p><strong>文件重定向</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//从infile中读取数据，并将输出结果写入outfile中，两个文件都位于当前目录</span><br>addItem &lt;infile &gt;outfile<br></code></pre></td></tr></table></figure>

<p><strong>成员函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// item1：对象， isbn：成员函数   . 点运算符    () 调用运算符</span><br>item1.<span class="hljs-built_in">isbn</span>()<br></code></pre></td></tr></table></figure>

<br>

<h3 id="重点习题"><a href="#重点习题" class="headerlink" title="重点习题"></a>重点习题</h3><p>1.1, 1.2<br>1.8<br>1.23<br>习题答案可以参考<a target="_blank" rel="noopener" href="https://github.com/huangmingchuan/Cpp_Primer_Answers/blob/master/ch01/README.md">github上的答案</a></p>
<br>



<h1 id="第二章：变量和基本类型"><a href="#第二章：变量和基本类型" class="headerlink" title="第二章：变量和基本类型"></a>第二章：变量和基本类型</h1><h2 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h2><blockquote>
<p>C++支持广泛的数据类型，其包含了基本的内置类型，标准库中更加复杂的数据类型，同时也为程序员提供了自定义数据类型的的机制。</p>
</blockquote>
<p><strong>基本内置类型包括算术类型和空类型。</strong></p>
<br>

<h3 id="算术类型"><a href="#算术类型" class="headerlink" title="算术类型"></a>算术类型</h3><hr>
<p>算术类型分为两类：整型（包括字符和布尔类型）和浮点型。<br>算术类型的尺寸在不同机器上有所差别，这里列出了C++标准规定的尺寸的<strong>最小值</strong>，同时允许编译器赋予这些类型更大的尺寸。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
<th>最小尺寸</th>
</tr>
</thead>
<tbody><tr>
<td><code>bool</code></td>
<td>布尔类型</td>
<td>8bits</td>
</tr>
<tr>
<td><code>char</code></td>
<td>字符</td>
<td>8bits</td>
</tr>
<tr>
<td><code>wchar_t</code></td>
<td>宽字符</td>
<td>16bits</td>
</tr>
<tr>
<td><code>char16_t</code></td>
<td>Unicode字符</td>
<td>16bits</td>
</tr>
<tr>
<td><code>char32_t</code></td>
<td>Unicode字符</td>
<td>32bits</td>
</tr>
<tr>
<td><code>short</code></td>
<td>短整型</td>
<td>16bits</td>
</tr>
<tr>
<td><code>int</code></td>
<td>整型</td>
<td>16bits (在32位机器中是32bits)</td>
</tr>
<tr>
<td><code>long</code></td>
<td>长整型</td>
<td>32bits</td>
</tr>
<tr>
<td><code>long long</code></td>
<td>长整型</td>
<td>64bits （是在C++11中新定义的）</td>
</tr>
<tr>
<td><code>float</code></td>
<td>单精度浮点数</td>
<td>6位有效数字</td>
</tr>
<tr>
<td><code>double</code></td>
<td>双精度浮点数</td>
<td>10位有效数字</td>
</tr>
<tr>
<td><code>long double</code></td>
<td>扩展精度浮点数</td>
<td>10位有效数字</td>
</tr>
</tbody></table>
<br>

<p>然后这里附上实际64位机器的算术类型的尺寸。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;size of bool:&quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">bool</span>) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;size of char:&quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;size of wchar_t:&quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">wchar_t</span>) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;size of char16_t:&quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char16_t</span>) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;size of char32_t:&quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char32_t</span>) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;size of short:&quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">short</span>) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;size of int:&quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;size of long:&quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">long</span>) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;size of long long:&quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span>) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;size of float:&quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;size of double:&quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;size of long double:&quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">long</span> <span class="hljs-type">double</span>) &lt;&lt; endl;<br>&#125;<br><br><br><span class="hljs-comment">//output </span><br>size of <span class="hljs-type">bool</span>:<span class="hljs-number">1</span><br>size of <span class="hljs-type">char</span>:<span class="hljs-number">1</span><br>size of <span class="hljs-type">wchar_t</span>:<span class="hljs-number">2</span><br>size of <span class="hljs-type">char16_t</span>:<span class="hljs-number">2</span><br>size of <span class="hljs-type">char32_t</span>:<span class="hljs-number">4</span><br>size of <span class="hljs-type">short</span>:<span class="hljs-number">2</span><br>size of <span class="hljs-type">int</span>:<span class="hljs-number">4</span><br>size of <span class="hljs-type">long</span>:<span class="hljs-number">4</span><br>size of <span class="hljs-type">long</span> <span class="hljs-type">long</span>:<span class="hljs-number">8</span><br>size of <span class="hljs-type">float</span>:<span class="hljs-number">4</span><br>size of <span class="hljs-type">double</span>:<span class="hljs-number">8</span><br>size of <span class="hljs-type">long</span> <span class="hljs-type">double</span>:<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure>

<br>

<p><strong>布尔和字符类型</strong></p>
<p>bool类型的取值是true或false<br>一个char的大小和一个机器字节一样，确保可以存放机器基本字符集中任意字符对应的数字值。<br>其他字符类型用于扩展字符集，其中wchar_t确保可以存放机器最大扩展字符集中的任意一个字符。char16_t和char32_t则为Unicode字符集服务（Unicode是用于表示所有自然语言中字符的标准）。</p>
<p><strong>整形大小关系</strong><br>在整型类型大小方面，C++规定short ≤ int ≤ long ≤ long long（long long是C++11定义的类型）。</p>
<p><strong>字节和字</strong><br>字节byte：可寻址的最小内存块，大多数机器的字节由8比特构成<br>字word:存储的基本单元，4或8字节</p>
<p><strong>浮点型</strong><br>浮点型可表示单精度（single-precision）、双精度（double-precision）和扩展精度（extended-precision）值，分别对应float、double和long double类型。</p>
<p><strong>带符号类型与无符号类型</strong><br>除去布尔型和扩展字符型，其他整型可以分为带符号（signed）和无符号（unsigned）两种。带符号类型可以表示正数、负数和0，无符号类型只能表示大于等于0的数值。类型int、short、long和long long都是带符号的，在类型名前面添加unsigned可以得到对应的无符号类型，如unsigned int。</p>
<p>字符型分为char、signed char和unsigned char三种，但是表现形式只有带符号和无符号两种。类型char和signed char并不一样， char的具体形式由编译器（compiler）决定。</p>
<p><strong>如何选择类型</strong></p>
<ul>
<li>当明确知晓数值不可能为负时，应该使用无符号类型。</li>
<li>使用int执行整数运算，如果数值超过了int的表示范围，应该使用long long类型。</li>
<li>在算数表达式中不要使用char和bool类型。如果需要使用一个不大的整数，应该明确指定它的类型是signed char还是unsigned char。</li>
<li>执行浮点数运算时建议使用double类型。</li>
</ul>
<br>

<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><hr>
<p>进行类型转换时，类型所能表示的值的范围决定了转换的过程。</p>
<ul>
<li>把非布尔类型的算术值赋给布尔类型时，初始值为0则结果为false，否则结果为true。</li>
<li>把布尔值赋给非布尔类型时，初始值为false则结果为0，初始值为true则结果为1。</li>
<li>把浮点数赋给整数类型时，进行近似处理，结果值仅保留浮点数中的整数部分。</li>
<li>把整数值赋给浮点类型时，小数部分记为0。如果该整数所占的空间超过了浮点类型的容量，精度可能有损失。</li>
<li>赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数（8比特大小的unsigned char能表示的数值总数是256）取模后的余数。</li>
<li>赋给带符号类型一个超出它表示范围的值时，结果是未定义的（undefined）。</li>
</ul>
<p><strong>切勿混用带符号类型和无符号类型</strong><br>如果表达式里既有带符号类型又有无符号类型，带符号数会自动转换成无符号数。<br>当带符号类型取值为负时会出现异常结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">-1</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> b = <span class="hljs-number">1</span>;<br>cout &lt;&lt; a*b &lt;&lt; endl;<br><br><span class="hljs-comment">// output</span><br>此时输出就不是<span class="hljs-number">-1</span>，而是<span class="hljs-number">4294967295</span><br><br><span class="hljs-comment">// 无符号数不会小于0的，影响循环</span><br><span class="hljs-comment">// u永远不会小于0</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> u = <span class="hljs-number">10</span>; u &gt;= <span class="hljs-number">0</span>; --u)<br>    std::cout &lt;&lt; u &lt;&lt; std::endl;<br><br><span class="hljs-comment">//解决办法：改变循环的范围,10...0 变成 11...1 再减去1</span><br><span class="hljs-type">unsigned</span> u = <span class="hljs-number">11</span>;<br><span class="hljs-keyword">while</span> (u &gt; <span class="hljs-number">0</span>)<br>&#123;<br>    --u;    <br>    std::cout &lt;&lt; u &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<br>

<h3 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h3><hr>
<blockquote>
<p>一个形如42的值被称为字面值常量，每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。</p>
</blockquote>
<p><strong>整型和浮点型字面值</strong><br>整形字面值可以写作多种进制数的形式。以0开头的整数代表八进制（octal）数，以0x或0X开头的整数代表十六进制（hexadecimal）数。在C++14中，0b或0B开头的整数代表二进制（binary）数。</p>
<p>C++14新增了单引号’形式的数字分隔符。数字分隔符不会影响数字的值，但可以通过分隔符将数字分组，使数值读写更容易。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 按照书写形式，每3位分为一组</span><br>std::cout &lt;&lt; <span class="hljs-number">0B</span>1<span class="hljs-number">&#x27;101</span>;   <span class="hljs-comment">// 输出&quot;13&quot;</span><br>std::cout &lt;&lt; <span class="hljs-number">1&#x27;100&#x27;000</span>; <span class="hljs-comment">// 输出&quot;1100000&quot;</span><br></code></pre></td></tr></table></figure>

<p>浮点型字面值表现为一个小数或以科学计数法表示的指数，其中指数部分用E或e标识：</p>
<ul>
<li>3.14159     </li>
<li>3.14159E0   </li>
<li>0.0     </li>
<li>0e0     </li>
<li>.001</li>
</ul>
<p>浮点型字面值默认是一个double。</p>
<p><strong>字符和字符串字面值</strong><br>由单引号括起来的一个字符称为char型字面值，双引号括起来的零个或多个字符称为字符串字面值。</p>
<p>字符串字面值的类型是由常量字符构成的数组（array）。编译器在每个字符串的结尾处添加一个空字符’\0’，因此字符串字面值的实际长度要比它的内容多一位。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-string">&#x27;A&#x27;</span>  一个字符 <br><span class="hljs-string">&quot;A&quot;</span>  两个字符 一个A字符一个空字符<br></code></pre></td></tr></table></figure>

<p>如果两个字符串字面值位置紧邻且仅有空格，缩进，换行符分隔，则它们实际上是一个整体。因此当字符串字面值比较长，就可以采取分行书写的方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::cout &lt;&lt; <span class="hljs-string">&quot;a really long string literal&quot;</span><br>             <span class="hljs-string">&quot;that spans two lines&quot;</span> &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<p><strong>转义序列</strong><br>有两类字符程序员不能直接使用：一类是不可打印的字符，如退格或其他控制字符，另一类是在C++语言中含有特殊含义的字符（单引号，双引号，问号，反斜线）。所以我们需要用到转义序列，以\开头。</p>
<table>
<thead>
<tr>
<th>含义</th>
<th>转义字符</th>
</tr>
</thead>
<tbody><tr>
<td>newline</td>
<td>\n</td>
</tr>
<tr>
<td>horizontal tab</td>
<td>\t</td>
</tr>
<tr>
<td>alert (bell)</td>
<td>\a</td>
</tr>
<tr>
<td>vertical tab</td>
<td>\v</td>
</tr>
<tr>
<td>backspace</td>
<td>\b</td>
</tr>
<tr>
<td>double quote</td>
<td>\“</td>
</tr>
<tr>
<td>backslash</td>
<td>\|</td>
</tr>
<tr>
<td>question mark</td>
<td>\?</td>
</tr>
<tr>
<td>single quote</td>
<td>\‘</td>
</tr>
<tr>
<td>carriage return</td>
<td>\r</td>
</tr>
<tr>
<td>formfeed</td>
<td>\f</td>
</tr>
</tbody></table>
<p>八进制数和十六进制数可以拿来转义字符，可称为八进制字符和十六进制字符。<br>泛化转义序列的形式是\x后紧跟1个或多个十六进制数字，或者\后紧跟1个、2个或3个八进制数字，其中数字部分表示字符对应的数值。如果\后面跟着的八进制数字超过3个，则只有前3个数字与\构成转义序列。相反，\x要用到后面跟着的所有数字。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-string">&quot;\1234&quot;</span>  <span class="hljs-comment">//两个字符 八进制123对应的字符（八进制字符）和字符4</span><br><span class="hljs-string">&quot;\x1234&quot;</span>  <span class="hljs-comment">//一个字符 四个十六进制数所对应的比特唯一确定（十六进制字符）</span><br><span class="hljs-string">&quot;1234&quot;</span>    <span class="hljs-comment">//四个char字符</span><br></code></pre></td></tr></table></figure>

<p><strong>指定字面值的类型</strong><br><img src="/../img/primer/chapter2.1.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>布尔字面值和和指针字面值</strong></p>
<ul>
<li>true和false和布尔类型的字面值</li>
<li>nullptr是指针类型的字面值</li>
</ul>
<br>

<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><blockquote>
<p>变量提供一个具名的、可供程序操作的存储空间。 C++中变量和对象一般可以互换使用。</p>
</blockquote>
<br>

<h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><hr>
<p><strong>定义形式：</strong> 类型说明符（type specifier） + 一个或多个变量名组成的列表，变量名以逗号分隔，最后以分号结束。如int sum &#x3D; 0, value, units_sold &#x3D; 0;</p>
<p><strong>初始化：</strong>：初始化不等于赋值（assignment）。初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，再用一个新值来替代。</p>
<p><strong>列表初始化</strong><br>用花括号初始化变量称为列表初始化（list initialization）。当用于内置类型的变量时，如果使用了列表初始化并且初始值存在丢失信息的风险，则编译器会报错。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">long</span> <span class="hljs-type">double</span> ld = <span class="hljs-number">3.1415926536</span>;<br><span class="hljs-type">int</span> a&#123;ld&#125;, b = &#123;ld&#125;;    <span class="hljs-comment">// error: narrowing conversion required</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">c</span><span class="hljs-params">(ld)</span>, d </span>= ld;      <span class="hljs-comment">// ok: but value will be truncated</span><br></code></pre></td></tr></table></figure>

<p><strong>默认初始化</strong><br>如果定义变量时没有指定初值，则变量被默认初始化（default initialized）。如果指定了初始值又叫显示初始化。</p>
<p>如果是<strong>内置类型</strong>未被显式初始化，定义于任何函数体之外的变量被初始化为0，函数体内部的变量将不被初始化（uninitialized）。<br>如果是<strong>非内置类型</strong>，每个类各自决定其初始化对象的方式，绝大多数类都支持默认初始化而定义对象。<strong>函数内外定义无区别</strong>。</p>
<p>定义于函数体内的内置类型对象如果没有初始化，则其值未定义，使用该类值是一种错误的编程行为且很难调试。类的对象如果没有显式初始化，则其值由类确定。</p>
<p>建议初始化每一个内置类型的变量。</p>
<br>

<h3 id="变量声明vs变量定义"><a href="#变量声明vs变量定义" class="headerlink" title="变量声明vs变量定义"></a>变量声明vs变量定义</h3><hr>
<blockquote>
<p>为了允许把程序拆分成多个逻辑部分来写，C++语言支持分离式编译机制，该机制允许将程序分割为若干个文件，每个文件可以被独立编译。</p>
</blockquote>
<p>为了支持分离式编译，C++将声明和定义区分开。声明使得名字为程序所知。定义负责创建与名字关联的实体。</p>
<p>如果想声明一个变量而不定义它，就在变量名前添加关键字extern，并且不要显式地初始化变量。因为任何包含了显式初始化的声明即为定义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> i;      <span class="hljs-comment">//声明i而非定义i</span><br><span class="hljs-type">int</span> j;             <span class="hljs-comment">//声明并定义j</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> k = <span class="hljs-number">3</span>;  <span class="hljs-comment">//定义</span><br></code></pre></td></tr></table></figure>

<p>变量能且只能被定义一次，但是可以被声明多次。</p>
<p>如果要在多个文件中使用同一个变量，就必须将声明和定义分开。此时变量的定义必须出现且只能出现在一个文件中，其他使用该变量的文件必须对其进行声明，但绝对不能重复定义。</p>
<br>

<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><hr>
<p>C++的标识符由字母、数字和下划线组成，其中必须以字母或下划线开头。标识符的长度没有限制，但是对大小写字母敏感。C++为标准库保留了一些名字。用户自定义的标识符不能连续出现两个下划线，也不能以下划线紧连大写字母开头。此外，定义在函数体外的标识符不能以下划线开头。</p>
<p>C++保留了关键字和操作符替代名供本身使用，这些名字不能用作标识符。<br><img src="/../img/primer/chapter2.2.png" srcset="/img/loading.gif" lazyload></p>
<br>

<h3 id="名字的作用域"><a href="#名字的作用域" class="headerlink" title="名字的作用域"></a>名字的作用域</h3><hr>
<p>定义在函数体之外的名字拥有全局作用域（global scope）。声明之后，该名字在整个程序范围内都可使用。</p>
<p>最好在第一次使用变量时再去定义它。这样做更容易找到变量的定义位置，并且也可以赋给它一个比较合理的初始值。</p>
<p>作用域中一旦声明了某个名字，在它所嵌套着的所有作用域中都能访问该名字。同时，允许在内层作用域中重新定义外层作用域已有的名字，此时内层作用域中新定义的名字将屏蔽外层作用域的名字。</p>
<p>可以用作用域操作符::来覆盖默认的作用域规则。因为全局作用域本身并没有名字，所以当作用域操作符的左侧为空时，会向全局作用域发出请求获取作用域操作符右侧名字对应的变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">// Program for illustration purposes only: It is bad style for a function</span><br><span class="hljs-comment">// to use a global variable and also define a local variable with the same name</span><br><span class="hljs-type">int</span> reused = <span class="hljs-number">42</span>;    <span class="hljs-comment">// reused has global scope</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> unique = <span class="hljs-number">0</span>; <span class="hljs-comment">// unique has block scope</span><br>    <span class="hljs-comment">// output #1: uses global reused; prints 42 0</span><br>    std::cout &lt;&lt; reused &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;<br>    <span class="hljs-type">int</span> reused = <span class="hljs-number">0</span>; <span class="hljs-comment">// new, local object named reused hides global reused</span><br>    <span class="hljs-comment">// output #2: uses local reused; prints 0 0</span><br>    std::cout &lt;&lt; reused &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;<br>    <span class="hljs-comment">// output #3: explicitly requests the global reused; prints 42 0</span><br>    std::cout &lt;&lt; ::reused &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果函数有可能用到某个全局变量，则不宜再定义一个同名的局部变量。</p>
<br>

<h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><blockquote>
<p>复合类型是指基于其他类型定义的类型，C++语言中有几种复合类型，其中用的最多的是引用和指针。<br>一条声明语句由一个基本数据类型和紧随其后的的一个声明符列表组成，每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。</p>
</blockquote>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><hr>
<blockquote>
<p>C++11新增了右值引用的概念,一般说的引用是指的左值引用</p>
</blockquote>
<p>引用为对象起了另外一个名字，引用类型引用（refers to）另外一种类型。通过将声明符写成&amp;d的形式来定义引用类型，其中d是变量名称。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> ival = <span class="hljs-number">1024</span>;<br><span class="hljs-type">int</span> &amp;refVal = ival; <span class="hljs-comment">// refVal refers to (is another name for) ival</span><br><span class="hljs-type">int</span> &amp;refVal2;       <span class="hljs-comment">// error: a reference must be initialized</span><br></code></pre></td></tr></table></figure>
<p>定义引用时，程序把引用和它的初始值绑定（bind）在一起，而不是将初始值拷贝给引用。<strong>一旦初始化完成，将无法再令引用重新绑定到另一个对象，因此引用必须初始化</strong>。</p>
<p>引用不是对象，它只是为一个已经存在的对象所起的另外一个名字。定义一个引用后，对其进行的所有操作都是在与之绑定的对象上进行的。</p>
<p>因为引用本身不是一个对象，所以不能定义引用的引用。</p>
<p>声明语句中引用的类型实际上被用于指定它所绑定的对象类型。大部分情况下，引用的类型要和与之绑定的对象严格匹配。</p>
<p><strong>引用（非常量引用）只能绑定在对象上，不能与字面值或某个表达式的计算结果绑定在一起</strong>。</p>
<p><strong>引用的读法</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 读法1：b是对int对象a的引用</span><br><span class="hljs-comment">// 读法2：b是int引用,绑定了a对象</span><br><span class="hljs-type">int</span> &amp;b = a  <br></code></pre></td></tr></table></figure>

<br>

<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><hr>
<p>指针是“指向point to”另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。</p>
<ul>
<li>指针本身就是一个对象，允许对指针赋值和拷贝，而且在生命周期内它可以先后指向不同的对象。</li>
<li>指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。</li>
</ul>
<p>通过将声明符写成&amp;d的形式来定义指针类型，其中d是变量名称。如果在一条语句中定义了多个指针变量，则每个变量前都必须有符号*。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> *ip1, *ip2;     <span class="hljs-comment">// both ip1 and ip2 are pointers to int</span><br><span class="hljs-type">double</span> dp, *dp2;    <span class="hljs-comment">// dp2 is a pointer to double; dp is a double</span><br></code></pre></td></tr></table></figure>

<p>指针存放某个对象的地址，要想获取对象的地址，需要使用取地址符&amp;。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> ival = <span class="hljs-number">42</span>;<br><span class="hljs-type">int</span> *p = &amp;ival; <span class="hljs-comment">// p holds the address of ival; p is a pointer to ival</span><br></code></pre></td></tr></table></figure>
<p>因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。</p>
<p>与引用类似，声明语句中指针的类型实际上被用于指定它所指向的对象类型。大部分情况下，指针的类型要和它指向的对象严格匹配。</p>
<p><strong>指针值</strong><br>指针的值（即地址）应属于下列状态之一：</p>
<ol>
<li>指向一个对象。</li>
<li>指向紧邻对象所占空间的下一个位置。</li>
<li>空指针，即指针没有指向任何对象。</li>
<li>无效指针，即上述情况之外的其他值。</li>
</ol>
<p>试图拷贝或以其他方式访问无效指针的值都会引发错误。<br>第二种和第三种形式的指针是有效的，但是没有指向任何具体对象，试图访问此类指针指向的对象的行为是不被允许的。</p>
<p><strong>指针访问对象</strong><br>如果指针指向一个对象，可以使用解引用（dereference）符*来访问该对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> ival = <span class="hljs-number">42</span>;<br><span class="hljs-type">int</span> *p = &amp;ival; <span class="hljs-comment">// p holds the address of ival; p is a pointer to ival</span><br>cout &lt;&lt; *p;     <span class="hljs-comment">// * yields the object to which p points; prints 42</span><br></code></pre></td></tr></table></figure>

<p>给解引用的结果赋值就是给指针所指向的对象赋值。<strong>解引用操作仅适用于那些确实指向了某个对象的有效指针。</strong></p>
<p>&amp;，*既可以作为表达式里的运算符，也可以用于声明符中的类型修饰符，用于组成复合类型。</p>
<p><strong>空指针</strong><br>空指针（null pointer）不指向任何对象，在试图使用一个指针前代码可以先检查它是否为空。得到空指针最直接的办法是用字面值nullptr来初始化指针。这里有三种方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> *p1 = <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// equivalent to int *p1 = 0;</span><br><span class="hljs-type">int</span> *p2 = <span class="hljs-number">0</span>;        <span class="hljs-comment">// directly initializes p2 from the literal constant 0</span><br><span class="hljs-comment">// must #include cstdlib</span><br><span class="hljs-type">int</span> *p3 = <span class="hljs-literal">NULL</span>;     <span class="hljs-comment">// equivalent to int *p3 = 0;</span><br></code></pre></td></tr></table></figure>
<p>即使int变量的值恰好等于0，也不能拿来赋值给指针，我们提到过指针的类型要和对象严格匹配。</p>
<p>建议初始化所有指针。</p>
<p><strong>赋值和指针</strong><br>给指针赋值就是令它存放一个新的地址，从而指向一个新的对象<br>如果指针值为0，条件取false,任何非0指针对应的条件值都是true。</p>
<p><strong>void*指针</strong><br>void<em>是一种特殊的指针类型，可以存放任意对象的地址，但不能直接操作void</em>指针所指的对象。</p>
<p><strong>引用的读法</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 读法1：int指针b,指向对象a</span><br><span class="hljs-comment">// 读法2：b指针，指向int对象a</span><br><span class="hljs-type">int</span> *b = &amp;a  <br></code></pre></td></tr></table></figure>

<br>

<h3 id="复合类型的声明"><a href="#复合类型的声明" class="headerlink" title="复合类型的声明"></a>复合类型的声明</h3><hr>
<p>指向指针的指针（Pointers to Pointers）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> ival = <span class="hljs-number">1024</span>;<br><span class="hljs-type">int</span> *pi = &amp;ival;    <span class="hljs-comment">// pi points to an int</span><br><span class="hljs-type">int</span> **ppi = &amp;pi;    <span class="hljs-comment">// ppi points to a pointer to an int</span><br></code></pre></td></tr></table></figure>
<p><img src="/../img/primer/2-4.png" srcset="/img/loading.gif" lazyload></p>
<p>对指针的引用（References to Pointers）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-type">int</span> *p;         <span class="hljs-comment">// p is a pointer to int</span><br><span class="hljs-type">int</span> *&amp;r = p;    <span class="hljs-comment">// r is a reference to the pointer p</span><br>r = &amp;i;         <span class="hljs-comment">// r refers to a pointer; assigning &amp;i to r makes p point to i</span><br>*r = <span class="hljs-number">0</span>;         <span class="hljs-comment">// dereferencing r yields i, the object to which p points; changes i to 0</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p> 面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清它的真实含义。&amp;取址符可以理解为指向，会更容易分析。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> **ppi = &amp;pi; <span class="hljs-comment">//从右往左，指针ppi,指向int指针    初始化：指向pi</span><br><span class="hljs-type">int</span> *&amp;r = p;     <span class="hljs-comment">//从右往左，引用r,引用了int指针    初始化：绑定p</span><br></code></pre></td></tr></table></figure>

<br>

<h2 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h2><p>在变量类型前添加关键字const可以创建值不能被改变的对象。const变量必须被初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> bufSize = <span class="hljs-number">512</span>;    <span class="hljs-comment">// input buffer size</span><br>bufSize = <span class="hljs-number">512</span>;      <span class="hljs-comment">// error: attempt to write to const object</span><br></code></pre></td></tr></table></figure>
<p>当以编译时初始化的方式定义一个const对象时，编译器将在编译过程中把用到该变量的地方都替换成对应的值。为了执行这个替换，编译器必须知道变量的初始值，如果程序包含多个文件，那么每个用了这个const对象的文件都必须得能访问到它的初始值才行（即每个文件都要定义const对象）。为了避免对同一变量的重复定义，默认情况下，const对象被设定成仅在文件内有效。当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 下面是合法的, 不存在变量i重复定义问题</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// foo.cpp</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> i = <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">// bar.cpp</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> i = <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure>

<p>如果想在多个文件之间共享const对象，那么必须在变量的定义之前添加extern关键字：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 下面是合法的, main.cpp和foo.cpp中的const int对象是同一个</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// foo.cpp</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> i = <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">// main.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> i;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;i:&quot;</span> &lt;&lt; i &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<br>

<h3 id="const的引用"><a href="#const的引用" class="headerlink" title="const的引用"></a>const的引用</h3><hr>
<p>把引用绑定在const对象上即为对常量的引用（reference to const）。对常量的引用不能被用作修改它所绑定的对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> ci = <span class="hljs-number">1024</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r1 = ci;     <span class="hljs-comment">// ok: both reference and underlying object are const</span><br>r1 = <span class="hljs-number">42</span>;        <span class="hljs-comment">// error: r1 is a reference to const</span><br><span class="hljs-type">int</span> &amp;r2 = ci;   <span class="hljs-comment">// error: non const reference to a const object</span><br></code></pre></td></tr></table></figure>

<p>论述一下术语</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">3</span>;<br><span class="hljs-comment">//常量和常量对象</span><br><span class="hljs-comment">//一般说常量指的都是字面值常量，也就是这里的3</span><br><span class="hljs-comment">//常量对象指的是const对象，也就是这里的a</span><br><span class="hljs-comment">//对const的引用，通常可以称为常量引用</span><br></code></pre></td></tr></table></figure>

<p>一般而言，引用的类型必须与其所引用对象的类型一致，但是有两个例外：</p>
<ul>
<li><p>初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用类型即可，允许为一个常量引用绑定非常量的对象、字面值甚至是一个一般表达式（如下）</p>
</li>
<li><p>可以将基类的指针或引用绑定到派生类对象上（后续面向对象章节再探讨）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> i = <span class="hljs-number">10</span>;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;ri1 = i;      <span class="hljs-comment">// 合法: 绑定到非常量对象</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;ri2 = <span class="hljs-number">100</span>;    <span class="hljs-comment">// 合法: 绑定到字面值</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;ri3 = <span class="hljs-number">1</span> + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 合法: 绑定到一般表达式</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p>临时量（temporary）对象：当编译器需要一个空间来暂存表达式的求值结果时，临时创建的一个未命名的对象。对临时量的引用（非常量引用）是非法行为，常量引用可以绑定临时对象。</p>
<br>

<h3 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h3><hr>
<p><strong>指向常量的指针</strong></p>
<p>与引用一样，指针也可以指向常量或非常量,指向常量的指针（pointer to const）不能用于修改其所指向的对象。要想获得常量对象的地址，只能使用指向常量的指针。</p>
<p>前面提过，指针的类型必须与所指向对象的类型一致，但有两个例外，第一种例外就是允许令一个指向常量的指针指向一个非常量对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">double</span> pi = <span class="hljs-number">3.14</span>;     <span class="hljs-comment">// pi is const; its value may not be changed</span><br><span class="hljs-type">double</span> *ptr = &amp;pi;          <span class="hljs-comment">// error: ptr is a plain pointer</span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> *cptr = &amp;pi;   <span class="hljs-comment">// ok: cptr may point to a double that is const</span><br>*cptr = <span class="hljs-number">42</span>;         <span class="hljs-comment">// error: cannot assign to *cptr</span><br><span class="hljs-type">double</span> dval = <span class="hljs-number">3.14</span>; <span class="hljs-comment">// dval is a double; its value can be changed</span><br>cptr = &amp;dval;       <span class="hljs-comment">// ok: but can&#x27;t change dval through cptr</span><br></code></pre></td></tr></table></figure>

<p><strong>常量指针（const指针）</strong></p>
<p>定义语句中把*放在const之前用来说明指针本身是一个常量，常量指针（const pointer）必须初始化，指针值不能改变（指向不能改变，类似于引用，指针固定指向该对象，不能更改了），但是常量指针并不代表不能通过指针修改其所指向的对象的值，能否这样做完全依赖于其指向对象的类型。如果常量指针指向常量，指针指向的对象不能修改，但是如果常量指针指向非常量，那么此时就可以通过指针取修改对象的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> errNumb = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> *<span class="hljs-type">const</span> curErr = &amp;errNumb;   <span class="hljs-comment">// curErr will always point to errNumb</span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> pi = <span class="hljs-number">3.14159</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> *<span class="hljs-type">const</span> pip = &amp;pi;  <span class="hljs-comment">// pip is a const pointer to a const object</span><br><br>*pip = <span class="hljs-number">2.72</span> ;  <span class="hljs-comment">//error: pip is a pointer to  a const object</span><br>*curErr = <span class="hljs-number">0</span>;   <span class="hljs-comment">//ok: curErr is a pointer to a non-const object</span><br></code></pre></td></tr></table></figure>

<br>

<h3 id="顶层const与底层const"><a href="#顶层const与底层const" class="headerlink" title="顶层const与底层const"></a>顶层const与底层const</h3><hr>
<p>指针本身是一个对象，因此指针本身是不是常量与指针所指对象是不是常量是两个独立的问题，前者被称为顶层const，后者被称为底层const。</p>
<p>Tips：指针类型既可以是顶层const也可以是底层const，其他类型要么是顶层常量要么是底层常量。</p>
<p>顶层const用于表示任意的对象是常量，包括算数类型、类和指针等，底层const用于表示引用和指针等复合类型的基本类型部分是否是常量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> i = <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> *<span class="hljs-type">const</span> p1 = &amp;i;        <span class="hljs-comment">// 顶层const: 不能改变p1的值</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p2 = &amp;i;        <span class="hljs-comment">// 底层const: 不能通过p2改变i的值</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *<span class="hljs-type">const</span> p3 = &amp;i;  <span class="hljs-comment">// 底层const + 顶层const</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r1 = i;         <span class="hljs-comment">// 底层const: 不能通过r1改变i的值</span><br></code></pre></td></tr></table></figure>

<br>

<h3 id="constexpr和常量表达式"><a href="#constexpr和常量表达式" class="headerlink" title="constexpr和常量表达式"></a>constexpr和常量表达式</h3><hr>
<blockquote>
<p>常量表达式（constant expressions）指值不会改变并且在编译过程就能得到计算结果的表达式。显然，字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。</p>
</blockquote>
<p>一个对象是否为常量表达式由它的数据类型和初始值共同决定。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> max_files = <span class="hljs-number">20</span>;           <span class="hljs-comment">// max_files is a constant expression</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> limit = max_files + <span class="hljs-number">1</span>;    <span class="hljs-comment">// limit is a constant expression</span><br><span class="hljs-type">int</span> staff_size = <span class="hljs-number">27</span>;        <span class="hljs-comment">// staff_size is not a constant expression</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> sz = <span class="hljs-built_in">get_size</span>();  <span class="hljs-comment">// sz is not a constant expression</span><br></code></pre></td></tr></table></figure>

<p>C++11允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mf = <span class="hljs-number">20</span>;          <span class="hljs-comment">// 20 is a constant expression</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> limit = mf + <span class="hljs-number">1</span>;   <span class="hljs-comment">// mf + 1 is a constant expression</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> sz = <span class="hljs-built_in">size</span>();      <span class="hljs-comment">// ok only if size is a constexpr function</span><br></code></pre></td></tr></table></figure>

<p>指针和引用都能定义成constexpr，但是初始值受到严格限制。constexpr指针的初始值必须是0、nullptr或者是存储在某个固定地址中的对象。</p>
<p>函数体内定义的普通变量一般并非存放在固定地址中，因此constexpr指针不能指向这样的变量。相反，函数体外定义的变量地址固定不变，可以用来初始化constexpr指针。</p>
<p>在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针本身有效，与指针所指的对象无关。constexpr把它所定义的对象置为了顶层const。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> *p = <span class="hljs-literal">nullptr</span>;     <span class="hljs-comment">// p是指向int的const指针</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> *cp = &amp;i;   <span class="hljs-comment">// cp是指向const int的const指针</span><br></code></pre></td></tr></table></figure>

<p>const和constexpr限定的值都是常量。但constexpr对象的值必须在编译期间确定，而const对象的值可以延迟到运行期间确定。</p>
<p>建议使用constexpr修饰表示数组大小的对象，因为数组的大小必须在编译期间确定且不能改变。</p>
<br>

<h2 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h2><h3 id="类型别名（Type-Aliases）"><a href="#类型别名（Type-Aliases）" class="headerlink" title="类型别名（Type Aliases）"></a>类型别名（Type Aliases）</h3><hr>
<p>类型别名是某种类型的同义词，传统方法是使用关键字typedef定义类型别名。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">double</span> wages;   <span class="hljs-comment">// wages is a synonym for double</span><br><span class="hljs-keyword">typedef</span> wages base, *p; <span class="hljs-comment">// base is a synonym for double, p for double*</span><br></code></pre></td></tr></table></figure>

<p>C++11使用关键字using进行别名声明（alias declaration），作用是把等号左侧的名字规定成等号右侧类型的别名。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> SI = Sales_item; <span class="hljs-comment">// SI is a synonym for Sales_item</span><br></code></pre></td></tr></table></figure>

<p>如果声明语句中有const，类型别名的声明语句并不是简单的替换，顶层const修饰的还是必须为顶层const。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> *pstring;<br><span class="hljs-comment">//不能理解为 const char *cstr = 0,这样理解const从顶层const转变为了底层const</span><br><span class="hljs-comment">//所以还是要保留顶层const,正确的理解 char *const pstring = 0; </span><br><span class="hljs-comment">//复习一下：顶层const修饰的是对象，对于指针来说就是指针本身，底层const修饰的是指针指向的对象</span><br><span class="hljs-type">const</span> pstring cstr = <span class="hljs-number">0</span>;  <br><span class="hljs-type">const</span> pstring *ps;<br></code></pre></td></tr></table></figure>

<br>

<h3 id="auto类型说明符（The-auto-Type-Specifier）"><a href="#auto类型说明符（The-auto-Type-Specifier）" class="headerlink" title="auto类型说明符（The auto Type Specifier）"></a>auto类型说明符（The auto Type Specifier）</h3><hr>
<p>C++11新增auto类型说明符，能让编译器自动分析表达式所属的类型。auto定义的变量必须有初始值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// the type of item is deduced from the type of the result of adding val1 and val2</span><br><span class="hljs-keyword">auto</span> item = val1 + val2;    <span class="hljs-comment">// item initialized to the result of val1 + val2</span><br></code></pre></td></tr></table></figure>

<p>编译器推断出来的auto类型有时和初始值的类型并不完全一样。</p>
<ul>
<li><p>当引用被用作初始值时，编译器以引用对象的类型作为auto的类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, &amp;r = i;<br><span class="hljs-keyword">auto</span> a = r;     <span class="hljs-comment">// a is an int (r is an alias for i, which has type int)</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>auto一般会忽略顶层const。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> ci = i, &amp;cr = ci;<br><span class="hljs-keyword">auto</span> b = ci;    <span class="hljs-comment">// b is an int (top-level const in ci is dropped)</span><br><span class="hljs-keyword">auto</span> c = cr;    <span class="hljs-comment">// c is an int (cr is an alias for ci whose const is top-level)</span><br><span class="hljs-keyword">auto</span> d = &amp;i;    <span class="hljs-comment">// d is an int*(&amp; of an int object is int*)</span><br><span class="hljs-keyword">auto</span> e = &amp;ci;   <span class="hljs-comment">// e is const int*(&amp; of a const object is low-level const)</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p>如果希望推断出的auto类型是一个顶层const，需要显式指定const auto。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> f = ci;  <span class="hljs-comment">// deduced type of ci is int; f has type const int</span><br></code></pre></td></tr></table></figure>

<p>设置类型为auto的引用时，原来的初始化规则仍然适用，初始值中的顶层常量属性仍然保留。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> &amp;g = ci;   <span class="hljs-comment">// g is a const int&amp; that is bound to ci</span><br><span class="hljs-keyword">auto</span> &amp;h = <span class="hljs-number">42</span>;   <span class="hljs-comment">// error: we can&#x27;t bind a plain reference to a literal</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;j = <span class="hljs-number">42</span>;     <span class="hljs-comment">// ok: we can bind a const reference to a literal</span><br></code></pre></td></tr></table></figure>

<br>

<h3 id="decltype类型指示符（The-decltype-Type-Specifier）"><a href="#decltype类型指示符（The-decltype-Type-Specifier）" class="headerlink" title="decltype类型指示符（The decltype Type Specifier）"></a>decltype类型指示符（The decltype Type Specifier）</h3><hr>
<p>C++11新增decltype类型指示符，作用是选择并返回操作数的数据类型，此过程中编译器不实际计算表达式的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">f</span>()) sum = x;  <span class="hljs-comment">// sum has whatever type f returns</span><br></code></pre></td></tr></table></figure>
<p>decltype处理顶层const和引用的方式与auto有些不同，如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> ci = <span class="hljs-number">0</span>, &amp;cj = ci;<br><span class="hljs-keyword">decltype</span>(ci) x = <span class="hljs-number">0</span>;     <span class="hljs-comment">// x has type const int</span><br><span class="hljs-keyword">decltype</span>(cj) y = x;     <span class="hljs-comment">// y has type const int&amp; and is bound to x</span><br><span class="hljs-keyword">decltype</span>(cj) z;     <span class="hljs-comment">// error: z is a reference and must be initialized</span><br></code></pre></td></tr></table></figure>

<p><strong>decltype的结果类型与表达式密切相关</strong>，如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。<br>例如如果表达式的内容是解引用操作，则decltype将得到引用类型。如果decltype使用的是一个不加括号的变量，则得到的结果就是该变量的类型；<br>如果给变量加上了一层或多层括号，则decltype会得到引用类型，因为变量是一种可以作为赋值语句左值的特殊表达式。</p>
<p><strong>decltype((var))的结果永远是引用，而decltype(var)的结果只有当var本身是一个引用时才会是引用。</strong></p>
<br>

<h2 id="自定义数据结构"><a href="#自定义数据结构" class="headerlink" title="自定义数据结构"></a>自定义数据结构</h2><p>类以关键字struct开始，紧跟着类名和类体（类体部分可以为空）。<br>一般来说最好不要把对象的定义和类的定义放在一起。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//类和对象分开定义</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sales_data</span> &#123;......&#125;;<br>Sales_data accum, trans, *salesptr;<br></code></pre></td></tr></table></figure>

<p>C++11规定可以为类的数据成员（data member）提供一个类内初始值（in-class initializer）。创建对象时，类内初始值将用于初始化数据成员，没有初始值的成员将被默认初始化。</p>
<p>头文件（header file）通常包含那些只能被定义一次的实体，如类、const和constexpr变量。</p>
<p>头文件一旦改变，相关的源文件必须重新编译以获取更新之后的声明。</p>
<p>一个程序包含多次头文件会报错，所以需要对头文件做一些处理。确保头文件多次包含仍能安全工作的常用技术是预处理器（preprocessor)，#include就是一项预处理功能，当预处理器看到#include标记时，就会用指定的的头文件的内容代替#include。</p>
<p>头文件保护符（header guard）依赖于预处理变量（preprocessor variable）。预处理变量有两种状态：已定义和未定义。#define指令把一个名字设定为预处理变量。#ifdef指令当且仅当变量已定义时为真，#ifndef指令当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到#endif指令为止。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SALES_DATA_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SALES_DATA_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sales_data</span><br>&#123;<br>    std::string bookNo;<br>    <span class="hljs-type">unsigned</span> units_sold = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">double</span> revenue = <span class="hljs-number">0.0</span>;<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>

<p>在高级版本的IDE环境中，可以直接使用#pragma once命令来防止头文件的重复包含。</p>
<p>预处理变量无视C++语言中关于作用域的规则。</p>
<p>整个程序中的预处理变量，包括头文件保护符必须唯一。预处理变量的名字一般均为大写。</p>
<p>头文件即使目前还没有被包含在任何其他头文件中，也应该设置保护符。</p>
<br>




<h1 id="第三章：字符串，向量和数组"><a href="#第三章：字符串，向量和数组" class="headerlink" title="第三章：字符串，向量和数组"></a>第三章：字符串，向量和数组</h1><blockquote>
<p>内置类型是由C++语言直接定义的，这些类型体现了大多数计算机硬件本身具备的能力。标准库库定义了一组具有更高级性质的类型，它们尚未直接实现到计算机硬件中。</p>
</blockquote>
<h2 id="命名空间using的声明"><a href="#命名空间using的声明" class="headerlink" title="命名空间using的声明"></a>命名空间using的声明</h2><p>using声明引入命名空间的成员，<strong>最好每个成员都使用独立的using声明</strong>。</p>
<p><strong>头文件不应包含using声明</strong><br>如果头文件里有某个using声明，那么每个使用了该头文件的文件就都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。</p>
<br>

<h2 id="标准库类型string"><a href="#标准库类型string" class="headerlink" title="标准库类型string"></a>标准库类型string</h2><h3 id="定义和初始化string对象"><a href="#定义和初始化string对象" class="headerlink" title="定义和初始化string对象"></a>定义和初始化string对象</h3><hr>
<p>初始化string对象的方式：<br><img src="/../img/primer/3.2num1.png" srcset="/img/loading.gif" lazyload><br>如果使用等号初始化一个变量，实际上执行的是拷贝初始化（copy initialization），编译器把等号右侧的初始值拷贝到新创建的对象中去。如果不使用等号，则执行的是直接初始化（direct initialization).</p>
<br>

<h3 id="string对象上的操作"><a href="#string对象上的操作" class="headerlink" title="string对象上的操作"></a>string对象上的操作</h3><hr>
<p><strong>string的操作：</strong><br><img src="/../img/primer/3.2num2.png" srcset="/img/loading.gif" lazyload></p>
<p>在执行读取操作时，string对象会自动忽略开头的空白（空格符、换行符、制表符等）并从第一个真正的字符开始读取，直到遇见下一处空白为止。</p>
<p>使用getline函数可以读取一整行字符。<br>该函数只要遇到换行符就结束读取并返回结果，如果输入的开始就是一个换行符，则得到空string。触发getline函数返回的那个换行符实际上被丢弃掉了，得到的string对象中并不包含该换行符。</p>
<p>size函数返回string对象的长度，返回值是string::size_type类型，这是一种无符号类型。需要注意混用int和unsigned可能带来的问题。</p>
<p><strong>string对象的比较运算符</strong><br>string里重载后的比较运算符逐一比较string对象中的字符，并且对大小写敏感</p>
<ul>
<li>如果两个string对象的长度不同，而且较短的string对象的每个字符都与较长string对象对应位置上的字符相同，则较短string对象 &lt; 较长string对象。</li>
<li>如果两个string对象在某些对应的位置上不一致，则string对象比较的结果其实是string对象中第一对相异字符比较的结果。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// a &lt; b &lt; c</span><br>string a = <span class="hljs-string">&quot;Hello&quot;</span>;<br>string b = <span class="hljs-string">&quot;Hello World&quot;</span>;<br>string c = <span class="hljs-string">&quot;Hiya&quot;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p><strong>string对象的+运算符</strong><br>当把string对象和字符字面值及字符串字面值混合在一条语句中使用时，必须确保每个加法运算符两侧的运算对象中至少有一个是string。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">string s4 = s1 + <span class="hljs-string">&quot;, &quot;</span>;          <span class="hljs-comment">// ok: adding a string and a literal</span><br>string s5 = <span class="hljs-string">&quot;hello&quot;</span> + <span class="hljs-string">&quot;, &quot;</span>;     <span class="hljs-comment">// error: no string operand</span><br>string s6 = s1 + <span class="hljs-string">&quot;, &quot;</span> + <span class="hljs-string">&quot;world&quot;</span>;    <span class="hljs-comment">// ok: each + has a string operand</span><br></code></pre></td></tr></table></figure>
<p>为了与C兼容，C++语言中的字符串字面值并不是标准库string的对象。</p>
<br>

<h3 id="处理string对象中的字符"><a href="#处理string对象中的字符" class="headerlink" title="处理string对象中的字符"></a>处理string对象中的字符</h3><hr>
<p><strong>cctype头文件中定义了一组标准库函数处理string对象中的字符。</strong><br><img src="/../img/primer/3.2num3.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>cctype vs ctype.h</strong><br><img src="/../img/primer/3.2num4.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>range for</strong><br>C++11提供了范围for（range for）语句，可以遍历给定序列中的每个元素并执行某种操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (declaration : expression)<br>    statement<br></code></pre></td></tr></table></figure>
<p><code>expression</code>部分是一个对象，用于表示一个序列。<code>declaration</code>部分负责定义一个变量，该变量被用于访问序列中的基础元素。每次迭代，<code>declaration</code>部分的变量都会被初始化为<code>expression</code>部分的下一个元素值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">string <span class="hljs-title">str</span><span class="hljs-params">(<span class="hljs-string">&quot;some string&quot;</span>)</span></span>;<br><span class="hljs-comment">// print the characters in str one character to a line</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : str)      <span class="hljs-comment">// for every char in str</span><br>    cout &lt;&lt; c &lt;&lt; endl;  <span class="hljs-comment">// print the current character followed by a newline</span><br></code></pre></td></tr></table></figure>
<p>如果想在范围for语句中改变string对象中字符的值，<strong>必须把循环变量定义成引用类型。</strong></p>
<br>

<p><strong>要想访问string对象中的单个字符有两种方式；一种是使用下标，另外一种是使用迭代器。</strong></p>
<p>[]下标运算符接收的输入参数是string::size_type类型的值，表示要访问字符的位置，返回值是该位置上字符的引用。</p>
<blockquote>
<p>下标的值称为索引，任何表达式只要它的值是一个整型值就能作为索引。例如给出int整型值也会自动转化为string::size_type类型值。不过要注意，如果某个索引是带符号类型的值，它将自动转化成由string::size_type表达的无符号类型。</p>
</blockquote>
<p>下标数值从0记起，范围是0至size - 1。使用超出范围的下标将引发不可预知的后果。所以使用下标访问空string也会引发不可预知的后果。</p>
<br>

<h2 id="标准库类型vector"><a href="#标准库类型vector" class="headerlink" title="标准库类型vector"></a>标准库类型vector</h2><p><strong>基本概念</strong></p>
<ul>
<li>标准库类型vector表示对象的集合，也叫做容器（container），定义在头文件vector中。vector中所有对象的类型都相同，每个对象都有一个索引与之对应并用于访问该对象。</li>
<li>vector是模板（template）而非类型，由vector生成的类型必须包含vector中元素的类型，如vector<int>。</li>
<li>类模板：本身不是类，但可以实例化instantiation出一个类，通过将类型放在类模板名称后面的尖括号中来指定类型，如vector<int> ivec。</li>
<li>因为引用不是对象，所以不存在包含引用的vector</li>
<li>在早期的C++标准中，如果vector的元素还是vector，定义时必须在外层vector对象的右尖括号和其元素类型之间添加一个空格，如vector&lt;vector<int> &gt;。但是在C++11标准中，可以直接写成vector&lt;vector<int>&gt;，不需要添加空格。</li>
</ul>
<br>

<h3 id="定义和初始化vector对象"><a href="#定义和初始化vector对象" class="headerlink" title="定义和初始化vector对象"></a>定义和初始化vector对象</h3><hr>
<p><strong>初始化vector对象的方法</strong><br><img src="/../img/primer/3.3num1.png" srcset="/img/loading.gif" lazyload></p>
<br>

<p><strong>初始化方式比较</strong></p>
<ul>
<li><p>初始化vector对象时如果使用圆括号，可以说提供的值是用来构造（construct）vector对象的，一个初始值指示容量，两个初始值指示容量和初始值</p>
</li>
<li><p>如果使用的是花括号，则是在尽可能地列表初始化（list initialize）该vector对象，如果提供的值无法列表初始化，编译器会尝试构造初始化<br>eg:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;string&gt; v5&#123;<span class="hljs-string">&quot;hi&quot;</span>&#125;       <span class="hljs-comment">//列表初始化 一个元素&quot;hi&quot;</span><br><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">v6</span><span class="hljs-params">(<span class="hljs-string">&quot;hi&quot;</span>)</span>       <span class="hljs-comment">//错误：不能使用字符串字面值构造初始化</span></span><br><span class="hljs-function">vector&lt;string&gt; v7</span>&#123;<span class="hljs-number">10</span>&#125;         <span class="hljs-comment">//值无法列表初始化，自动构造初始化 10个元素</span><br>vector&lt;string&gt; v8&#123;<span class="hljs-number">10</span>, <span class="hljs-string">&quot;hi&quot;</span>&#125;   <span class="hljs-comment">//值无法列表初始化，自动构造初始化 10个元素&quot;hi&quot;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>可以只提供vector对象容纳的元素数量而省略初始值，此时会创建一个值初始化（value-initialized）的元素初值，并把它赋给容器中的所有元素。这个初值由vector对象中的元素类型决定。</p>
</li>
</ul>
<br>

<h3 id="向vector对象中添加元素"><a href="#向vector对象中添加元素" class="headerlink" title="向vector对象中添加元素"></a>向vector对象中添加元素</h3><hr>
<p>C++标准要求vector应该能在运行时高效快速地添加元素，所以常用的方式是先定义一个空的vector，然后向其添加具体值。</p>
<p>push_back函数可以把一个值添加到vector的尾端。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;<span class="hljs-type">int</span>&gt; v2;         <span class="hljs-comment">// empty vector</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-number">100</span>; ++i)<br>    v2.<span class="hljs-built_in">push_back</span>(i);    <span class="hljs-comment">// append sequential integers to v2</span><br><span class="hljs-comment">// at end of loop v2 has 100 elements, values 0 . . . 99</span><br></code></pre></td></tr></table></figure>

<p>范围for语句体内不应该改变其所遍历序列的大小。</p>
<br>

<h3 id="其他vector操作"><a href="#其他vector操作" class="headerlink" title="其他vector操作"></a>其他vector操作</h3><hr>
<p><img src="/../img/primer/3.3num2.png" srcset="/img/loading.gif" lazyload></p>
<br>

<ul>
<li>size函数返回vector对象中元素的个数，返回值是由vector定义的size_type类型。vector对象的类型包含其中元素的类型.</li>
<li>vector和string对象的下标运算符只能用来访问已经存在的元素，而不能用来添加元素.</li>
<li>试图用下标的形式访问一个不存在的元素将引发错误，不过这种错误不会被编译器发现，而是在运行时产生一个不可预知的值。</li>
<li>确保下标合法的一种有效手段就是尽可能地使用范围for语句。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;<span class="hljs-type">int</span>&gt;::size_type  <span class="hljs-comment">// ok</span><br>vector::size_type       <span class="hljs-comment">// error</span><br><br>vector&lt;<span class="hljs-type">int</span>&gt; ivec;   <span class="hljs-comment">// empty vector</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">decltype</span>(ivec.<span class="hljs-built_in">size</span>()) ix = <span class="hljs-number">0</span>; ix != <span class="hljs-number">10</span>; ++ix)<br>&#123;<br>    ivec[ix] = ix;  <span class="hljs-comment">// disaster: ivec has no elements</span><br>    ivec.<span class="hljs-built_in">push_back</span>(ix); <span class="hljs-comment">// ok: adds a new element with value ix</span><br>&#125;<br></code></pre></td></tr></table></figure>

<br>

<h2 id="迭代器iterator"><a href="#迭代器iterator" class="headerlink" title="迭代器iterator"></a>迭代器iterator</h2><blockquote>
<ul>
<li>迭代器的作用和下标类似，但是更加通用。所有标准库容器都可以使用迭代器，但是其中只有少数几种同时支持下标运算符。</li>
<li>类似于指针类型，迭代器也提供了对对象的间接访问，有效的迭代器指向某个元素或者指向容器中尾元素的下一个位置，其余所有情况都属于无效。</li>
</ul>
</blockquote>
<br>

<h3 id="使用迭代器"><a href="#使用迭代器" class="headerlink" title="使用迭代器"></a>使用迭代器</h3><hr>
<ul>
<li><p><code>vector&lt;int&gt;::iterator iter</code>。</p>
</li>
<li><p><code>auto b = v.begin();</code>begin函数返回指向第一个元素的迭代器.</p>
</li>
<li><p><code>auto e = v.end();</code>end函数返回指向容器“尾元素的下一位置（one past the end）”的迭代器，通常被称作尾后迭代器（off-the-end iterator）或者简称为尾迭代器（end iterator）</p>
</li>
<li><p>如果容器为空， <code>begin()</code>和 <code>end()</code>返回的是同一个迭代器，都是尾后迭代器。</p>
</li>
<li><p>养成使用迭代器和<code>!=</code>的习惯（泛型编程）。</p>
</li>
<li><p><strong>const_iterator</strong>：只能读取容器内元素不能改变。</p>
<ul>
<li>begin和end返回的迭代器具体类型由对象是否是常量决定，如果对象是常量，则返回const_iterator；如果对象不是常量，则返回iterator。</li>
<li>C++11新增了cbegin和cend函数，不论vector或string对象是否为常量，都返回const_iterator迭代器。</li>
</ul>
</li>
<li><p><strong>箭头运算符</strong>： 解引用 + 成员访问，<code>it-&gt;mem</code>等价于 <code>(*it).mem</code></p>
</li>
<li><p><strong>容器</strong>：可以包含其他对象；但所有的对象必须类型相同。</p>
</li>
<li><p><strong>迭代器（iterator）</strong>：每种标准容器都有自己的迭代器。<code>C++</code>倾向于用迭代器而不是下标遍历元素。</p>
</li>
<li><p><strong>谨记</strong>：任何可能改变容器对象容量的操作，都会使该对象的迭代器失效。但凡是使用了<strong>迭代器</strong>的循环体，都<strong>不要</strong>向迭代器所属的容器<strong>添加元素</strong>。</p>
</li>
</ul>
<p>标准容器迭代器的运算符:</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>*iter</code></td>
<td>返回迭代器<code>iter</code>所指向的<strong>元素的引用</strong></td>
</tr>
<tr>
<td><code>iter-&gt;mem</code></td>
<td>等价于<code>(*iter).mem</code></td>
</tr>
<tr>
<td><code>++iter</code></td>
<td>令<code>iter</code>指示容器中的下一个元素</td>
</tr>
<tr>
<td><code>--iter</code></td>
<td>令<code>iter</code>指示容器中的上一个元素</td>
</tr>
<tr>
<td><code>iter1 == iter2</code></td>
<td>判断两个迭代器是否相等</td>
</tr>
<tr>
<td><code>iter1 != iter2</code></td>
<td>不是指向同一元素，也不是同一个容器的尾后迭代器，不相等</td>
</tr>
</tbody></table>
<br>

<h3 id="迭代器运算"><a href="#迭代器运算" class="headerlink" title="迭代器运算"></a>迭代器运算</h3><hr>
<p><code>vector</code>和<code>string</code>迭代器支持的运算：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>iter + n</code></td>
<td>迭代器加上一个整数值仍得到一个迭代器，迭代器指示的新位置和原来相比向前移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置。</td>
</tr>
<tr>
<td><code>iter - n</code></td>
<td>迭代器减去一个整数仍得到一个迭代器，迭代器指示的新位置比原来向后移动了若干个元素。结果迭代器或者指向容器内的一个元素，或者指示容器尾元素的下一位置。</td>
</tr>
<tr>
<td><code>iter1 += n</code></td>
<td>迭代器加法的复合赋值语句，将<code>iter1</code>加n的结果赋给<code>iter1</code></td>
</tr>
<tr>
<td><code>iter1 -= n</code></td>
<td>迭代器减法的复合赋值语句，将<code>iter2</code>减n的加过赋给<code>iter1</code></td>
</tr>
<tr>
<td><code>iter1 - iter2</code></td>
<td>两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后得到左侧的迭代器。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一位置。</td>
</tr>
<tr>
<td><code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&lt;=</code></td>
<td>迭代器的关系运算符</td>
</tr>
</tbody></table>
<ul>
<li><strong>difference_type</strong>：保证足够大以存储任何两个迭代器对象间的距离，可正可负。</li>
<li><strong>注意迭代器之间只有减法，没有其余运算</strong></li>
</ul>
<br>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><blockquote>
<p>数组类似vector，但数组的大小确定不变，不能随意向数组中添加元素。<br>如果不清楚元素的确切个数，应该使用vector。</p>
</blockquote>
<br>

<h3 id="定义和初始化内置数组"><a href="#定义和初始化内置数组" class="headerlink" title="定义和初始化内置数组"></a>定义和初始化内置数组</h3><hr>
<p>数组是一种复合类型，声明形式为a[d]，其中a是数组名称，d是数组维度（dimension）。维度必须是一个<strong>常量表达式</strong>。</p>
<p>默认情况下，数组的元素被默认初始化。</p>
<p>定义数组的时候<strong>必须指定数组的类型</strong>，不允许用auto关键字由初始值列表推断类型。</p>
<p>如果定义数组时提供了元素的初始化列表，则允许省略数组维度，编译器会根据初始值的数量计算维度。但<strong>如果显式指明了维度，那么初始值的数量不能超过指定的大小</strong>。如果维度比初始值的数量大，则用提供的值初始化数组中靠前的元素，剩下的元素被默认初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> sz = <span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> ia1[sz] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;  <span class="hljs-comment">// array of three ints with values 0, 1, 2</span><br><span class="hljs-type">int</span> a2[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;   <span class="hljs-comment">// an array of dimension 3</span><br><span class="hljs-type">int</span> a3[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;  <span class="hljs-comment">// equivalent to a3[] = &#123;0, 1, 2, 0, 0&#125;</span><br>string a4[<span class="hljs-number">3</span>] = &#123;<span class="hljs-string">&quot;hi&quot;</span>, <span class="hljs-string">&quot;bye&quot;</span>&#125;;   <span class="hljs-comment">// same as a4[] = &#123;&quot;hi&quot;, &quot;bye&quot;, &quot;&quot;&#125;</span><br><span class="hljs-type">int</span> a5[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;    <span class="hljs-comment">// error: too many initializers</span><br></code></pre></td></tr></table></figure>
<p>可以用字符串字面值初始化字符数组，但字符串字面值<strong>结尾处的空字符</strong>也会一起被拷贝到字符数组中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">char</span> a1[] = &#123;<span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;+&#x27;</span>&#125;;        <span class="hljs-comment">// list initialization, no null</span><br><span class="hljs-type">char</span> a2[] = &#123;<span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;\0&#x27;</span>&#125;;  <span class="hljs-comment">// list initialization, explicit null</span><br><span class="hljs-type">char</span> a3[] = <span class="hljs-string">&quot;C++&quot;</span>;      <span class="hljs-comment">// null terminator added automatically</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> a4[<span class="hljs-number">6</span>] = <span class="hljs-string">&quot;Daniel&quot;</span>;    <span class="hljs-comment">// error: no space for the null!</span><br></code></pre></td></tr></table></figure>
<p>不能用一个数组初始化或直接赋值给另一个数组。</p>
<p>不同于默认的从右向左理解类型修饰，从数组的名字开始由内向外阅读有助于理解复杂数组声明的含义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> *ptrs[<span class="hljs-number">10</span>];              <span class="hljs-comment">// ptrs is an array of ten pointers to int</span><br><span class="hljs-type">int</span> &amp;refs[<span class="hljs-number">10</span>] = <span class="hljs-comment">/* ? */</span>;    <span class="hljs-comment">// error: no arrays of references</span><br><span class="hljs-built_in">int</span> (*Parray)[<span class="hljs-number">10</span>] = &amp;arr;   <span class="hljs-comment">// Parray points to an array of ten ints</span><br><span class="hljs-built_in">int</span> (&amp;arrRef)[<span class="hljs-number">10</span>] = arr;    <span class="hljs-comment">// arrRef refers to an array of ten ints</span><br></code></pre></td></tr></table></figure>

<br>

<h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><hr>
<p>数组下标通常被定义成size_t类型，这是一种机器相关的无符号类型，可以表示内存中任意对象的大小。size_t定义在头文件cstddef中。</p>
<p>大多数常见的安全问题都源于缓冲区溢出错误。当数组或其他类似数据结构的下标越界并试图访问非法内存区域时，就会产生此类错误。</p>
<br>

<h3 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h3><hr>
<p>在大多数表达式中，使用数组类型的对象其实是在使用一个指向该数组首元素的指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">string nums[] = &#123;<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>&#125;;    <span class="hljs-comment">// array of strings</span><br>string *p = &amp;nums[<span class="hljs-number">0</span>];   <span class="hljs-comment">// p points to the first element in nums</span><br>string *p2 = nums;      <span class="hljs-comment">// equivalent to p2 = &amp;nums[0]</span><br></code></pre></td></tr></table></figure>

<p>当使用数组作为一个auto变量的初始值时，推断得到的类型是指针而非数组。但decltype关键字不会发生这种转换，直接返回数组类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> ia[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;   <span class="hljs-comment">// ia is an array of ten ints</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">ia2</span><span class="hljs-params">(ia)</span></span>;   <span class="hljs-comment">// ia2 is an int* that points to the first element in ia</span><br>ia2 = <span class="hljs-number">42</span>;       <span class="hljs-comment">// error: ia2 is a pointer, and we can&#x27;t assign an int to a pointer</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">ia2</span><span class="hljs-params">(&amp;ia[<span class="hljs-number">0</span>])</span></span>;   <span class="hljs-comment">// now it&#x27;s clear that ia2 has type int*</span><br><span class="hljs-comment">// ia3 is an array of ten ints</span><br><span class="hljs-keyword">decltype</span>(ia) ia3 = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<br>ia3 = p;    <span class="hljs-comment">// error: can&#x27;t assign an int* to an array</span><br>ia3[<span class="hljs-number">4</span>] = i;     <span class="hljs-comment">// ok: assigns the value of i to an element in ia3</span><br></code></pre></td></tr></table></figure>

<p>C++11在头文件iterator中定义了两个名为begin和end的函数，功能与容器中的两个同名成员函数类似，参数是一个数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> ia[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;   <span class="hljs-comment">// ia is an array of ten ints</span><br><span class="hljs-type">int</span> *beg = <span class="hljs-built_in">begin</span>(ia);   <span class="hljs-comment">// pointer to the first element in ia</span><br><span class="hljs-type">int</span> *last = <span class="hljs-built_in">end</span>(ia);    <span class="hljs-comment">// pointer one past the last element in ia</span><br></code></pre></td></tr></table></figure>

<p>标准库类型限定使用的下标必须是无符号类型，而内置的下标运算无此要求。</p>
<br>

<h3 id="C风格字符串"><a href="#C风格字符串" class="headerlink" title="C风格字符串"></a>C风格字符串</h3><hr>
<ul>
<li><p>C风格字符串是将字符串存放在字符数组中，并以空字符结束（null terminated）。这不是一种类型，而是一种为了表达和使用字符串而形成的书写方法。</p>
<br>
</li>
<li><p>C++标准支持C风格字符串，但是最好不要在C++程序中使用它们。对大多数程序来说，使用标准库string要比使用C风格字符串更加安全和高效。</p>
<br>
</li>
<li><p>C风格字符串的函数：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td><code>strlen(p)</code></td>
<td>返回<code>p</code>的长度，空字符不计算在内</td>
</tr>
<tr>
<td><code>strcmp(p1, p2)</code></td>
<td>比较<code>p1</code>和<code>p2</code>的相等性。如果<code>p1==p2</code>，返回0；如果<code>p1&gt;p2</code>，返回一个正值；如果<code>p1&lt;p2</code>，返回一个负值。</td>
</tr>
<tr>
<td><code>strcat(p1, p2)</code></td>
<td>将<code>p2</code>附加到<code>p1</code>之后，返回<code>p1</code></td>
</tr>
<tr>
<td><code>strcpy(p1, p2)</code></td>
<td>将<code>p2</code>拷贝给<code>p1</code>，返回<code>p1</code></td>
</tr>
</tbody></table>
<br>

<ul>
<li><p>C风格字符串函数不负责验证其参数的正确性，传入此类函数的指针必须指向以空字符作为结尾的数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">char</span> ca[] = &#123;<span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;+&#x27;</span>&#125;;  <span class="hljs-comment">//不以空字符结束</span><br>cout &lt;&lt; <span class="hljs-built_in">strlen</span>(ca) &lt;&lt; endl;   <span class="hljs-comment">//严重错误： ca没有以空字符结束</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>C风格字符串和标准库string对象的同类操作差别很大，包括比较，连接，拷贝。</p>
<br></li>
<li><p>对大多数应用来说，使用标准库 string比使用C风格字符串更安全、更高效。</p>
<br></li>
</ul>
<h3 id="与旧代码的接口"><a href="#与旧代码的接口" class="headerlink" title="与旧代码的接口"></a>与旧代码的接口</h3><hr>
<p>任何出现字符串字面值的地方都可以用以空字符结束的字符数组来代替：</p>
<ul>
<li><p>允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值。</p>
</li>
<li><p>在string对象的加法运算中，允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个运算对象都是）。</p>
</li>
<li><p>在string对象的复合赋值运算中，允许使用以空字符结束的字符数组作为右侧运算对象。</p>
</li>
</ul>
<p>不能用string对象直接初始化指向字符的指针。为了实现该功能，string提供了一个名为c_str的成员函数，返回const char*类型的指针，指向一个以空字符结束的字符数组，数组的数据和string对象一样。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello World&quot;</span>)</span></span>;    <span class="hljs-comment">// s holds Hello World</span><br><span class="hljs-type">char</span> *str = s;  <span class="hljs-comment">// error: can&#x27;t initialize a char* from a string</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *str = s.<span class="hljs-built_in">c_str</span>();    <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure>

<p>针对string对象的后续操作有可能会让c_str函数之前返回的数组失去作用，如果程序想一直都能使用其返回的数组，最好将该数组重新拷贝一份。</p>
<p>可以使用数组来初始化vector对象，但是需要指明要拷贝区域的首元素地址和尾后地址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> int_arr[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-comment">// ivec has six elements; each is a copy of the corresponding element in int_arr</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ivec</span><span class="hljs-params">(begin(int_arr), end(int_arr))</span></span>;<br></code></pre></td></tr></table></figure>

<p>在新版本的C++程序中应该尽量使用vector、string和迭代器，避免使用内置数组、C风格字符串和指针。</p>
<br>

<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><hr>
<p>C++中的多维数组其实就是数组的数组。当一个数组的元素仍然是数组时，通常需要用两个维度定义它：一个维度表示数组本身的大小，另一个维度表示其元素（也是数组）的大小。通常把二维数组的第一个维度称作行，第二个维度称作列。</p>
<p>多维数组初始化的几种方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> ia[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] =<br>&#123;   <span class="hljs-comment">// three elements; each element is an array of size 4</span><br>    &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;,   <span class="hljs-comment">// initializers for the row indexed by 0</span><br>    &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;,   <span class="hljs-comment">// initializers for the row indexed by 1</span><br>    &#123;<span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>&#125;  <span class="hljs-comment">// initializers for the row indexed by 2</span><br>&#125;;<br><span class="hljs-comment">// equivalent initialization without the optional nested braces for each row</span><br><span class="hljs-type">int</span> ib[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>&#125;;<br><span class="hljs-comment">// explicitly initialize only element 0 in each row</span><br><span class="hljs-type">int</span> ic[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;&#123; <span class="hljs-number">0</span> &#125;, &#123; <span class="hljs-number">4</span> &#125;, &#123; <span class="hljs-number">8</span> &#125;&#125;;<br><span class="hljs-comment">// explicitly initialize row 0; the remaining elements are value initialized</span><br><span class="hljs-type">int</span> id[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>&#125;;<br></code></pre></td></tr></table></figure>

<p>可以使用下标访问多维数组的元素，数组的每个维度对应一个下标运算符。如果表达式中下标运算符的数量和数组维度一样多，则表达式的结果是给定类型的元素。如果下标运算符数量比数组维度小，则表达式的结果是给定索引处的一个内层数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// assigns the first element of arr to the last element in the last row of ia</span><br>ia[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = arr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br><span class="hljs-built_in">int</span> (&amp;row)[<span class="hljs-number">4</span>] = ia[<span class="hljs-number">1</span>];  <span class="hljs-comment">// binds row to the second four-element array in ia</span><br></code></pre></td></tr></table></figure>

<p>使用范围for语句处理多维数组时，为了避免数组被自动转换成指针，语句中的外层循环控制变量必须声明成引用类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;row : ia)  <span class="hljs-comment">// for every element in the outer array</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> col : row)    <span class="hljs-comment">// for every element in the inner array</span><br>        cout &lt;&lt; col &lt;&lt; endl;<br></code></pre></td></tr></table></figure>
<p>如果row不是引用类型，编译器初始化row时会自动将数组形式的元素转换成指向该数组内首元素的指针，这样得到的row就是int<em>类型，而之后的内层循环则试图在一个int</em>内遍历，程序将无法通过编译。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> row : ia)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> col : row)<br></code></pre></td></tr></table></figure>
<p>使用范围for语句处理多维数组时，除了最内层的循环，其他所有外层循环的控制变量都应该定义成引用类型。</p>
<p>因为多维数组实际上是数组的数组，所以由多维数组名称转换得到的指针指向第一个内层数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> ia[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>];       <span class="hljs-comment">// array of size 3; each element is an array of ints of size 4</span><br><span class="hljs-built_in">int</span> (*p)[<span class="hljs-number">4</span>] = ia;   <span class="hljs-comment">// p points to an array of four ints</span><br>p = &amp;ia[<span class="hljs-number">2</span>];         <span class="hljs-comment">// p now points to the last element in ia</span><br></code></pre></td></tr></table></figure>

<p><strong>声明指向数组类型的指针时，必须带有圆括号。</strong></p>
<p>int *ip[4];     &#x2F;&#x2F; array of pointers to int<br>int (*ip)[4];   &#x2F;&#x2F; pointer to an array of four ints</p>
<p><strong>使用auto和decltype能省略复杂的指针定义。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// print the value of each element in ia, with each inner array on its own line</span><br><span class="hljs-comment">// p points to an array of four ints</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = ia; p != ia + <span class="hljs-number">3</span>; ++p)<br>&#123;<br>    <span class="hljs-comment">// q points to the first element of an array of four ints; that is, q points to an int</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> q = *p; q != *p + <span class="hljs-number">4</span>; ++q)<br>        cout &lt;&lt; *q &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<br>


<h1 id="第四章：表达式"><a href="#第四章：表达式" class="headerlink" title="第四章：表达式"></a>第四章：表达式</h1><blockquote>
<p>表达式（expression）由一个或多个运算对象（operand）组成，对表达式求值将得到一个结果（result）。<strong>字面值和变量是最简单的表达式</strong>，其结果就是字面值和变量的值。</p>
</blockquote>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><hr>
<p><strong>运算符：</strong> C++定义了<strong>一元运算符</strong>（unary operator）和<strong>二元运算符</strong>（binary operator）。除此之外，还有一个作用于三个运算对象的<strong>三元运算符</strong>。函数调用也是一种特殊的运算符，它对运算对象的数量没有限制。</p>
<p><strong>表达式理解</strong>：要想理解一个表达式，关注三个元素，<strong>优先级（precedence），结合律（associativity)，求值顺序（order of evaluation）</strong>.</p>
<p><strong>运算对象转换：</strong> 表达式求值过程中，<strong>小整数类型</strong>（如bool、char、short等）通常会被提升（promoted）为较大的整数类型，主要是<strong>int</strong>。</p>
<p><strong>重载运算符：</strong> C++定义了运算符作用于内置类型和复合类型的运算对象时所执行的操作。当运算符作用于类类型的运算对象时，用户可以自定义其含义，这被称作运算符重载（overloaded operator）。</p>
<p><strong>左值和右值：</strong><br>C++中的表达式要么是左值要么是右值，在C语言中可以位于赋值语句左侧的是左值，不能的被称为右值。但是在C++中两者的区别没有那么明显，但是可以简单归纳为：</p>
<ul>
<li><p>左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象</p>
</li>
<li><p><strong>当一个对象被用作右值的时候，用的是对象的值（内容）；当一个对象被用作左值的时候，用的是对象的身份（在内存中的位置）</strong></p>
</li>
</ul>
<p>不同的运算符对运算对象的要求不尽相同：有的需要左值运算对象，有的需要右值运算对象；有的返回值得到左值结果，有的得到右值结果。</p>
<p>Tips：一个重要的原则是：在需要右值的地方可以用左值代替，但是不能把右值当做左值（也就是位置）来使用。</p>
<p>下面列举几种需要用到左值的常用运算符：</p>
<ul>
<li><p>赋值运算符：需要一个非常量左值作为左侧运算对象，返回一个左值</p>
</li>
<li><p>取地址符：作用于一个左值运算对象，返回一个指向该运算对象的指针右值</p>
</li>
<li><p>内置解引用运算符、下标运算符、迭代器解引用运算符、vector和string的下标运算符：求值结果都是左值</p>
</li>
<li><p>内置类型和迭代器的递增递减运算符：作用于左值运算对象，其前置版本所得的结果也是左值</p>
</li>
</ul>
<p><strong>优先级与结合律：</strong><br>复合表达式（compound expression）指含有两个或多个运算符的表达式。优先级与结合律决定了运算对象的组合方式。<br>括号无视优先级与结合律，表达式中括号括起来的部分被当成一个单元来求值，然后再与其他部分一起按照优先级组合。</p>
<p><strong>求值顺序：</strong><br>并不是所有的运算符都规定了明确的求值顺序，只有<code>&amp;&amp; || , ?:</code> 这四种运算符规定了明确的求值顺序。</p>
<p>对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; ++i &lt;&lt; endl;    <span class="hljs-comment">// 编译器可能先求++i， 也可能先求i</span><br><br><span class="hljs-type">int</span> i = <span class="hljs-built_in">f1</span>() + <span class="hljs-built_in">f2</span>() <span class="hljs-comment">//f1和f2的计算先后不确定</span><br></code></pre></td></tr></table></figure>

<p>处理复合表达式时建议遵循以下两点：</p>
<ul>
<li><p>不确定求值顺序时，使用括号来强制让表达式的组合关系符合程序逻辑的要求。</p>
</li>
<li><p>如果表达式改变了某个运算对象的值，则在表达式的其他位置不要再使用这个运算对象。</p>
</li>
</ul>
<p>当改变运算对象的子表达式本身就是另一个子表达式的运算对象时，第二条规则无效。如*++iter，递增运算符改变了iter的值，而改变后的iter又是解引用运算符的运算对象。类似情况下，求值的顺序不会成为问题。（总结其实这里就是在当前位置继续使用，不会造成问题）</p>
<br>

<h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><hr>
<table>
<thead>
<tr>
<th>运算符</th>
<th>功能</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>一元正号</td>
<td>+ expr</td>
</tr>
<tr>
<td>-</td>
<td>一元负号</td>
<td>- expr</td>
</tr>
<tr>
<td>*</td>
<td>乘法</td>
<td>expr * expr</td>
</tr>
<tr>
<td>&#x2F;</td>
<td>除法</td>
<td>expr &#x2F; expr</td>
</tr>
<tr>
<td>%</td>
<td>求余</td>
<td>expr % expr</td>
</tr>
<tr>
<td>+</td>
<td>加法</td>
<td>expr + expr</td>
</tr>
<tr>
<td>-</td>
<td>减法</td>
<td>expr - expr</td>
</tr>
</tbody></table>
<h4 id="1-优先级和结合律"><a href="#1-优先级和结合律" class="headerlink" title="1. 优先级和结合律"></a>1. 优先级和结合律</h4><p>一元运算符的优先级最高，然后是乘法和除法，优先级最低的是加法和减法。上面所有的运算符都满足左结合律，意味着优先级相同时满足从左到右的顺序进行组合。</p>
<h4 id="2-溢出"><a href="#2-溢出" class="headerlink" title="2. 溢出"></a>2. 溢出</h4><p>当计算结果超出该类型所能表示的范围时可能产生溢出，比如最大的<code>short</code>型数值为<code>32767</code>，这时候<code>+1</code>可能输出<code>-32768</code>（这是因为符号位从<code>0</code>变为<code>1</code>，从而变成负值）。当然在别的系统程序的行为可能不同甚至崩溃。</p>
<h4 id="3-除法与负号"><a href="#3-除法与负号" class="headerlink" title="3. 除法与负号"></a>3. 除法与负号</h4><blockquote>
<p>Tips：C++语言的早期版本允许结果为负值的商向上或向下取整，C++11新标准规定商一律向0取整（即直接切除小数部分）。如果两个运算对象的符号相同则商为正，否则商为负。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">21</span> / <span class="hljs-number">6</span>;    <span class="hljs-comment">// 3</span><br><span class="hljs-number">-21</span> / <span class="hljs-number">-6</span>;  <span class="hljs-comment">// 3</span><br><span class="hljs-number">21</span> / <span class="hljs-number">-6</span>;   <span class="hljs-comment">// -3</span><br><span class="hljs-number">-21</span> / <span class="hljs-number">6</span>;   <span class="hljs-comment">// -3</span><br></code></pre></td></tr></table></figure>

<h4 id="4-取余与负号"><a href="#4-取余与负号" class="headerlink" title="4. 取余与负号"></a>4. 取余与负号</h4><blockquote>
<p> Tips：如果<code>m%n</code>不等于0，那么运算结果的符号和m相同。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">21</span> % <span class="hljs-number">6</span>;    <span class="hljs-comment">// 3</span><br><span class="hljs-number">21</span> % <span class="hljs-number">7</span>;    <span class="hljs-comment">// 0</span><br><span class="hljs-number">-21</span> % <span class="hljs-number">-8</span>;  <span class="hljs-comment">// -5</span><br><span class="hljs-number">21</span> % <span class="hljs-number">-5</span>;   <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure>

<br>

<h3 id="逻辑和关系运算符"><a href="#逻辑和关系运算符" class="headerlink" title="逻辑和关系运算符"></a>逻辑和关系运算符</h3><hr>
<table>
<thead>
<tr>
<th>结合律</th>
<th>运算符</th>
<th>功能</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>右</td>
<td>!</td>
<td>逻辑非</td>
<td>!expr</td>
</tr>
<tr>
<td>左</td>
<td>&lt;</td>
<td>小于</td>
<td>expr &lt; expr</td>
</tr>
<tr>
<td>左</td>
<td>&lt;&#x3D;</td>
<td>小于等于</td>
<td>expr &lt;&#x3D; expr</td>
</tr>
<tr>
<td>左</td>
<td>&gt;</td>
<td>大于</td>
<td>expr &gt; expr</td>
</tr>
<tr>
<td>左</td>
<td>&gt;&#x3D;</td>
<td>大于等于</td>
<td>expr &gt;&#x3D; expr</td>
</tr>
<tr>
<td>左</td>
<td>&#x3D;&#x3D;</td>
<td>相等</td>
<td>expr &#x3D;&#x3D; expr</td>
</tr>
<tr>
<td>左</td>
<td>!&#x3D;</td>
<td>不等</td>
<td>expr !&#x3D; expr</td>
</tr>
<tr>
<td>左</td>
<td>&amp;&amp;</td>
<td>逻辑与</td>
<td>expr &amp;&amp; expr</td>
</tr>
<tr>
<td>左</td>
<td>||</td>
<td>逻辑或</td>
<td>expr || expr</td>
</tr>
</tbody></table>
<h4 id="1-逻辑与和逻辑或的短路求值"><a href="#1-逻辑与和逻辑或的短路求值" class="headerlink" title="1. 逻辑与和逻辑或的短路求值"></a>1. 逻辑与和逻辑或的短路求值</h4><p>逻辑与<code>&amp;&amp;</code>和逻辑或<code>||</code>都是先求左侧对象的值再求右侧运算对象的值，<strong>当且仅当左侧运算对象无法确定表达式的结果才会计算右侧运算对象的值</strong>，这种策略被称为短路求值。基于短路求值的特点，我们可以通过左侧运算对象来确保右侧运算对象求值的正确性和安全性：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 只能左侧运算对象为真则右侧运算对象才安全</span><br>index != s.<span class="hljs-built_in">size</span>() &amp;&amp; !<span class="hljs-built_in">isspace</span>(s[index])<br></code></pre></td></tr></table></figure>

<h4 id="2-不要连写关系运算符"><a href="#2-不要连写关系运算符" class="headerlink" title="2. 不要连写关系运算符"></a>2. 不要连写关系运算符</h4><p>因为关系运算符的求值结果是布尔值，所以将几个关系运算符连写在一起会产生意想不到的结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 错误写法: 用i &lt; j的布尔值结果与k比较</span><br><span class="hljs-keyword">if</span> (i &lt; j &lt; k)<br>    <br><span class="hljs-comment">// 正确写法: 使用&amp;&amp;或者||连接</span><br><span class="hljs-keyword">if</span> (i &lt; j &amp;&amp; j &lt; k)<br></code></pre></td></tr></table></figure>

<br>

<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><hr>
<h4 id="1-运算对象与返回结果"><a href="#1-运算对象与返回结果" class="headerlink" title="1. 运算对象与返回结果"></a>1. 运算对象与返回结果</h4><p>赋值运算符的左侧运算对象必须是一个可修改的左值，返回的结果是它的左侧运算对象（仍然是左值）。</p>
<blockquote>
<p>Tips：注意赋值不等于初始化，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦去，并用一个新值替代它。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, k = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 初始化而非赋值</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> ci = i;         <span class="hljs-comment">// 初始化而非赋值, 因此左侧运算对象可以是常量</span><br><br><span class="hljs-number">1024</span> = k;   <span class="hljs-comment">// 错误: 字面值是右值</span><br>i + j = k;  <span class="hljs-comment">// 错误: 算数表达式是右值</span><br>ci = k;     <span class="hljs-comment">// 错误: ci是常量, 是不可修改的左值</span><br></code></pre></td></tr></table></figure>

<h4 id="2-初始化列表赋值"><a href="#2-初始化列表赋值" class="headerlink" title="2. 初始化列表赋值"></a>2. 初始化列表赋值</h4><p>C++11新标准允许使用初始化列表赋值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 1) 编译器warning提示窄化转换: narrowing conversion of ‘3.1499999999999999e+0’ from ‘double’ to ‘int’ inside &#123; &#125;</span><br><span class="hljs-type">int</span> k;<br>k = &#123;<span class="hljs-number">3.14</span>&#125;;<br><br><span class="hljs-comment">// 2) 无论左侧运算对象类型是什么, 初始值列表都可以为空, 此时编译器创造一个值初始化的临时量并将其赋给左侧运算对象</span><br><span class="hljs-type">int</span> i = &#123;&#125;;  <span class="hljs-comment">// i值为0</span><br></code></pre></td></tr></table></figure>

<h4 id="3-赋值运算符满足右结合律"><a href="#3-赋值运算符满足右结合律" class="headerlink" title="3. 赋值运算符满足右结合律"></a>3. 赋值运算符满足右结合律</h4><p>在下面的例子中，先执行<code>j = 0</code>，返回左侧运算对象，再执行<code>i = j</code>，因此执行结束后两个变量都被赋值为0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i, j;<br>i = j = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>

<h4 id="4-赋值运算符优先级较低"><a href="#4-赋值运算符优先级较低" class="headerlink" title="4. 赋值运算符优先级较低"></a>4. 赋值运算符优先级较低</h4><p>由于赋值运算符的优先级低于关系运算符的优先级，因此在条件语句中，赋值部分通常应该加上括号：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i;<br><br><span class="hljs-comment">// 如果i = get_value()左右两侧不加括号的话, 含义就截然不同</span><br><span class="hljs-keyword">while</span> ((i = <span class="hljs-built_in">get_value</span>()) != <span class="hljs-number">10</span> ) &#123;<br>    <span class="hljs-comment">// do something...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<br>

<h3 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h3><hr>
<h4 id="1-前置版本和后置版本"><a href="#1-前置版本和后置版本" class="headerlink" title="1. 前置版本和后置版本"></a>1. 前置版本和后置版本</h4><p>前置版本会将运算对象加1（或减1），然后将改变后的对象作为求值结果。后置版本也会将运算对象加1（或减1），但是求值结果是运算对象改变之前值的副本。这两种运算符必须作用于左侧运算对象，其中前置版本将对象本身作为左值返回，后置版本将对象原始值的副本的作为右值返回。</p>
<blockquote>
<p>Tips：除非必须，否则不用递增递减运算符的后置版本。前置版本的递增运算将值加1之后直接返回该运算对象，但是后置版本需要将原始值存储下来以便于返回这个未修改的内容，如果我们不需要修改前的值的话就是一种性能上的浪费。对于整数和指针类型而言，编译器可能对这种额外的工作进行优化，但是如果是对于相对复杂的迭代器类型，这种额外的工作就消耗巨大了。建议养成使用前置版本习惯，这样不仅不需要担心性能问题，而且不会引入非预期的错误。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j;<br>j = ++i;    <span class="hljs-comment">// j = 1, i = 1: 前置版本得到递增之后的值</span><br>j = i++;    <span class="hljs-comment">// j = 1, i = 2：后置版本得到递增之前的值</span><br></code></pre></td></tr></table></figure>

<h4 id="2-后置版本的可能使用场景"><a href="#2-后置版本的可能使用场景" class="headerlink" title="2. 后置版本的可能使用场景"></a>2. 后置版本的可能使用场景</h4><p>后置版本最常用的场景就是在一条语句中混用解引用和递增运算符的后置版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> pbeg = v.<span class="hljs-built_in">begin</span>();<br><span class="hljs-comment">// 输出元素直到遇到第一个负值</span><br><span class="hljs-keyword">while</span> (pbeg != v.<span class="hljs-built_in">end</span>() &amp;&amp; *pbeg &gt;= <span class="hljs-number">0</span>)<br>    cout &lt;&lt; *pebg++ &lt;&lt; endl; <span class="hljs-comment">// 输出当前值并将pbeg向前移动一个元素</span><br></code></pre></td></tr></table></figure>

<p><code>*pbeg++</code>这种写法非常普遍，会先把<code>pbeg</code>的值加1，然后返回<code>pbeg</code>的初始值的副本作为其求解结果，此时解引用的运算对象是<code>pbeg</code>未增加之前的值。</p>
<br>
 
<h3 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h3><hr>
<p>点运算符和箭头运算符都可用于访问成员，<code>ptr-&gt;mem</code>等价于<code>(*ptr).mem</code>。需要注意的是解引用运算符优先级低于点运算符，所以必须加上括号。</p>
<br>

<h3 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h3><hr>
<p>条件运算符满足<strong>右结合律</strong>，意味着运算对象一般按照从右往左的顺序组合，因此我们使用嵌套条件运算符：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">finalgrade = (grade &gt; <span class="hljs-number">90</span>) ? <span class="hljs-string">&quot;high pass&quot;</span><br>                            : (grade &lt; <span class="hljs-number">60</span>) ? <span class="hljs-string">&quot;fail&quot;</span> : <span class="hljs-string">&quot;pass&quot;</span><br></code></pre></td></tr></table></figure>

<p>注意条件运算符的<strong>优先级非常低</strong>，所以一条长表达式中嵌套了条件运算子表达式时，通常需要在两端加上括号：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout &lt;&lt; ((grade &lt; <span class="hljs-number">60</span>) ? <span class="hljs-string">&quot;fail&quot;</span> : <span class="hljs-string">&quot;pass&quot;</span>); <span class="hljs-comment">// 输出pass或者fail</span><br></code></pre></td></tr></table></figure>

<br>

<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><hr>
<p>用于检查和设置二进制位的功能。</p>
<ul>
<li>位运算符是作用于<strong>整数类型</strong>的运算对象。</li>
<li>二进制位向左移（<code>&lt;&lt;</code>）或者向右移（<code>&gt;&gt;</code>），移出边界外的位就被舍弃掉了。</li>
<li>位取反（<code>~</code>）（逐位求反）、与（<code>&amp;</code>）、或（<code>|</code>）、异或（<code>^</code>）</li>
</ul>
<p>有符号数负值可能移位后变号，所以强烈建议<strong>位运算符仅用于无符号数</strong>。</p>
<p>应用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> quiz1 = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 每一位代表一个学生是否通过考试</span><br><span class="hljs-number">1UL</span> &lt;&lt; <span class="hljs-number">12</span>;  <span class="hljs-comment">// 代表第12个学生通过</span><br>quiz1 |= (<span class="hljs-number">1UL</span> &lt;&lt; <span class="hljs-number">12</span>);   <span class="hljs-comment">// 将第12个学生置为已通过</span><br>quiz1 &amp;= ~(<span class="hljs-number">1UL</span> &lt;&lt; <span class="hljs-number">12</span>);  <span class="hljs-comment">// 将第12个学生修改为未通过</span><br><span class="hljs-type">bool</span> stu12 = quiz1 &amp; (<span class="hljs-number">1UL</span> &lt;&lt; <span class="hljs-number">12</span>);   <span class="hljs-comment">// 判断第12个学生是否通过</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>位运算符使用较少，但是重载cout、cin大家都用过</p>
</blockquote>
<p>位运算符满足左结合律，优先级介于中间，使用时尽量加括号。</p>
<br>

<h3 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h3><hr>
<p><code>sizeof</code>运算符返回一条表达式或者一个类型名字所占的字节数，所得的值是一个<code>size_t</code>类型（一种机器相关的无符号类型，它被设计得足够大以便能表示内存中任意对象的大小）。当传入一条表达式时，<code>sizeof</code>运算符并不实际计算其运算对象的值。</p>
<h4 id="1-不同类型的sizeof运算结果"><a href="#1-不同类型的sizeof运算结果" class="headerlink" title="1. 不同类型的sizeof运算结果"></a>1. 不同类型的sizeof运算结果</h4><ul>
<li>对<code>char</code>或者类型为<code>char</code>的表达式执行<code>sizeof</code>，返回<code>1</code></li>
<li>对引用类型执行<code>sizeof</code>运算得到被引用对象所占空间的大小</li>
<li>对指针执行<code>sizeof</code>得到指针本身所占空间的大小</li>
<li>对解引用指针执行<code>sizeof</code>运算得到指针你指向的对象所占空间的大小，指针本身不需要有效</li>
<li>对数组执行<code>sizeof</code>运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次<code>sizeof</code>运算并将所得结果求和</li>
<li>对<code>string</code>对象或<code>vector</code>对象执行<code>sizeof</code>运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间</li>
</ul>
<h4 id="2-sizeof返回常量表达式"><a href="#2-sizeof返回常量表达式" class="headerlink" title="2. sizeof返回常量表达式"></a>2. sizeof返回常量表达式</h4><p>因为<code>sizeof</code>的返回值是一个常量表达式，因此我们可以用<code>sizeof</code>的结果声明数组的维度。</p>
<h4 id="3-sizeof中解引用指针"><a href="#3-sizeof中解引用指针" class="headerlink" title="3. sizeof中解引用指针"></a>3. sizeof中解引用指针</h4><p>由于<code>sizeof</code>满足右结合律并且与<code>*</code>运算符的优先级一样，因此<code>sizeof *p</code>等价于<code>sizeof (*p)</code>。另外由于<code>sizeof</code>不会实际求运算对象的值，所以在<code>sizeof</code>的运算对象中解引用一个无效指针仍然是一种安全的行为，因为指针实际上并没有被真正地使用。</p>
<br>

<h3 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h3><hr>
<p>逗号运算符含有两个运算对象，首先对左侧的表达式求值，然后将求值结果丢弃掉。逗号运算符真正的<strong>结果是右侧表达式的值</strong>，如果右侧运算对象是左值，那么最终的求值结果也是左值。</p>
<p>逗号运算符通常被用在for循环中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt;::size_type cnt = ivec.<span class="hljs-built_in">size</span>();<br><br><span class="hljs-comment">// 把从size到1的值依次赋给ivec的元素</span><br><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::size_type ix = <span class="hljs-number">0</span>; ix != ivec.<span class="hljs-built_in">size</span>(); ++ix, --cnt) &#123;<br>    ivec[ix] = cnt;<br>&#125;<br></code></pre></td></tr></table></figure>

<br>

<h3 id="类型转换-1"><a href="#类型转换-1" class="headerlink" title="类型转换"></a>类型转换</h3><hr>
<p>在C++语言中，如果两种类型有关联，那么当程序需要其中一种类型的运算对象时，可以用另一种关联类型的对象或值代替。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C++不会直接将两个不同类型的值相加, 会先将3的int类型隐式转换为double类型, 再执行两个double类型相加</span><br><span class="hljs-comment">// 初始化i的过程中由于i的类型无法改变, 因此加法运算得到的double类型的结果会被转换为int类型的值用于初始化i</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">3.14</span> + <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure>

<h4 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h4><p><strong>1. 隐式转换发生的场景</strong></p>
<p>在下面这些场景中，编译器会自动地转换运算对象的类型：</p>
<ul>
<li>比int类型小的整型值首先提升为比较大的整数类型</li>
<li>在条件中，非布尔值转换为布尔类型（指针或者算术类型的值为0，则自动转换为false）</li>
<li>初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型</li>
<li>如果算数运算或关系运算的运算对象有多种类型，需要转换成同一种类型</li>
<li>函数调用时也会发生类型转换</li>
<li>大多数用到数组的表达式会将数组自动转换为指向数组首元素的指针（数组作为decltype关键字参数、取地址符&amp;、sizeof和typeid等运算符的运算对象时，上述自动转换不会发生）</li>
<li>常量整数值0或者字面值<code>nullptr</code>能转换成任意指针类型，指向任意非常量的指针能转换为<code>void*</code>，指向任意对象的指针能转换为<code>const void*</code></li>
<li>转换成常量：允许指向非常量类型的指针&#x2F;引用转换为指向相应的常量类型的指针&#x2F;引用</li>
</ul>
<p><strong>2. 算数转换</strong></p>
<p>算数转换的含义是指把一种算数类型转换为另一种算数类型，有如下一些规则：</p>
<ul>
<li>运算符的运算对象将转换成最宽的类型：例如一个对象是long double类型，那么无论另一个对象是什么类型都会转化为long double类型；表达式中既有浮点类型又有整数类型时，整数值将转换为对应的浮点类型</li>
<li>如果运算对象是无符号对象和有符号对象，且无符号类型不小于带符号类型，那么带符号的类型会转化为无符号类型：例如两个类型分别是unsigned int和int，那么int类型的运算对象会转换为unsigned int，此时如果int运算对象为负值，那么存在后面提到的副作用</li>
</ul>
<h4 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h4><p><strong>1. static_cast</strong></p>
<p>任何具有明确定义的类型转换，只要不包含底层const就可以使用<code>static_cast</code>。例如将int运算对象强制转换为double类型就可以使表达式执行浮点数除法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i, j;<br><span class="hljs-type">double</span> slope = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">double</span>&gt;(j) / i;<br></code></pre></td></tr></table></figure>

<p><code>static_cast</code>也常用于编译器无法自动执行的类型转换，例如我们可以使用<code>static_cast</code>找回存在于<code>void*</code>的指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">double</span> d;<br><span class="hljs-type">void</span> *p = &amp;d;<br><span class="hljs-type">double</span> *dp = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">double</span>*&gt;(p);<br></code></pre></td></tr></table></figure>

<p><strong>2. const_cast</strong></p>
<p><code>const_cast</code>只能用于改变运算对象的底层const，用于将常量对象改成非常量对象。一旦我们去掉了某个对象的const性质，编译器就不会再组织我们对该对象进行写操作了。如果对象本身不是一个常量，使用强制类型转换获得写权限是合法的行为，如果对象是一个常量，再使用<code>const_cast</code>执行写操作就会产生未定义的后果。</p>
<p>只有<code>const_cast</code>能改变表达式的常量属性，使用其他形式的强制类型转换改变表达式的常量属性都将引发编译错误。同样地，也不能用<code>const_cast</code>改变表达式的类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *cp;<br><span class="hljs-type">char</span> *q = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(cp);  <span class="hljs-comment">// 错误: static_cast不能去掉const性质</span><br><span class="hljs-built_in">static_cast</span>&lt;string&gt;(cp);           <span class="hljs-comment">// 正确: 字符串字面量转换为string类型</span><br><span class="hljs-built_in">const_cast</span>&lt;string&gt;(cp);            <span class="hljs-comment">// 错误: const_cast只能改变常量属性</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>Tips：<code>const_cast</code>最常用于重载函数的情景。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 常量引用的函数版本</span><br><span class="hljs-function"><span class="hljs-type">const</span> string &amp;<span class="hljs-title">shorterString</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;s1, <span class="hljs-type">const</span> string &amp;s2)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> s1.<span class="hljs-built_in">size</span>() &lt;= s2.<span class="hljs-built_in">size</span>() ? s1 : s2;<br>&#125;<br><br><span class="hljs-comment">// 非常量引用的函数版本复用常量引用的函数版本</span><br><span class="hljs-function">string &amp;<span class="hljs-title">shorterString</span><span class="hljs-params">(string &amp;s1, string &amp;s2)</span> </span>&#123;<br>    <span class="hljs-type">const</span> string &amp;r = <span class="hljs-built_in">shorterString</span>(<span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">const</span> string&amp;&gt;(s1),<br>                                    <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">const</span> string&amp;&gt;(s2));<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">const_cast</span>&lt;string &amp;&gt;(r);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>3. reinterpret_cast</strong></p>
<p><code>reinterpret_cast</code>通常为运算对象的位模式提供较低层次上的重新解释，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *ip;<br><span class="hljs-type">char</span> *cp = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(ip);<br></code></pre></td></tr></table></figure>

<p>我们必须牢记pc所指的真实对象是一个int而非char，如果把pc当成普通字符指针使用就可能在运行时发生错误。</p>
<p><strong>4. dynamic_cast</strong></p>
<p><code>dynamic_cast</code>主要用来执行“安全向下转型”（safe downcasting），也就是用来决定某对象是否归属继承体系中的某个类型。它是唯一无法由旧式语法执行的动作，也是唯一可能耗费重大运行成本的转型动作。</p>
<p><strong>5. 旧式的强制类型转换</strong></p>
<p>在早期版本的C++语言中，显式地进行强制类型转换包含两种形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">type</span>(expr);  <span class="hljs-comment">// 函数形式的强制类型转换</span><br>(type)expr;  <span class="hljs-comment">// C语言风格的强制类型转换</span><br></code></pre></td></tr></table></figure>

<p>根据所涉及的类型不同，旧式的强制类型转换分别具有与<code>const_cast</code>、<code>static_cast</code>和<code>reinterpret_cast</code>相似的行为，例如转换后不合法，则旧式强制类型转换与<code>reinterpret_cast</code>具有相似的功能：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *ip;<br><span class="hljs-type">char</span> *cp = (<span class="hljs-type">char</span>*)ip;  <span class="hljs-comment">// 等价于使用reinterpret_cast</span><br></code></pre></td></tr></table></figure>

<br>

<h3 id="运算符优先级表"><a href="#运算符优先级表" class="headerlink" title="运算符优先级表"></a>运算符优先级表</h3><hr>
<table>
<thead>
<tr>
<th>优先级</th>
<th>结合律</th>
<th>运算符</th>
<th>功能</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>左</td>
<td><code>::</code></td>
<td>全局作用域</td>
<td><code>::name</code></td>
</tr>
<tr>
<td>1</td>
<td>左</td>
<td><code>::</code></td>
<td>类作用域</td>
<td><code>class::name</code></td>
</tr>
<tr>
<td>1</td>
<td>左</td>
<td><code>::</code></td>
<td>命名空间作用域</td>
<td><code>namespace::name</code></td>
</tr>
<tr>
<td>2</td>
<td>左</td>
<td><code>.</code></td>
<td>成员选择</td>
<td><code>object.member</code></td>
</tr>
<tr>
<td>2</td>
<td>左</td>
<td><code>-&gt;</code></td>
<td>成员选择</td>
<td><code>pointer-&gt;member</code></td>
</tr>
<tr>
<td>2</td>
<td>左</td>
<td><code>[]</code></td>
<td>下标</td>
<td><code>expr[expr]</code></td>
</tr>
<tr>
<td>2</td>
<td>左</td>
<td><code>()</code></td>
<td>函数调用</td>
<td><code>name(epxr_list)</code></td>
</tr>
<tr>
<td>2</td>
<td>左</td>
<td><code>()</code></td>
<td>类型构造</td>
<td><code>type(expr_list)</code></td>
</tr>
<tr>
<td>3</td>
<td>右</td>
<td><code>++</code></td>
<td>后置递增运算</td>
<td><code>lvalue++</code></td>
</tr>
<tr>
<td>3</td>
<td>右</td>
<td><code>--</code></td>
<td>后置递减运算</td>
<td><code>lvalue--</code></td>
</tr>
<tr>
<td>3</td>
<td>右</td>
<td><code>typeid</code></td>
<td>类型ID</td>
<td><code>typeid(type)</code></td>
</tr>
<tr>
<td>3</td>
<td>右</td>
<td><code>typeid</code></td>
<td>运行时类型ID</td>
<td><code>typeid(expr)</code></td>
</tr>
<tr>
<td>3</td>
<td>右</td>
<td><code>explicit cast</code></td>
<td>类型转换</td>
<td><code>cast_name&lt;type&gt;(expr)</code></td>
</tr>
<tr>
<td>4</td>
<td>右</td>
<td><code>++</code></td>
<td>前置递增运算</td>
<td><code>++lvalue</code></td>
</tr>
<tr>
<td>4</td>
<td>右</td>
<td><code>--</code></td>
<td>前置递减运算</td>
<td><code>--lvalue</code></td>
</tr>
<tr>
<td>4</td>
<td>右</td>
<td><code>~</code></td>
<td>位求反</td>
<td><code>~expr</code></td>
</tr>
<tr>
<td>4</td>
<td>右</td>
<td><code>!</code></td>
<td>逻辑非</td>
<td><code>!expr</code></td>
</tr>
<tr>
<td>4</td>
<td>右</td>
<td><code>-</code></td>
<td>一元负号</td>
<td><code>-expr</code></td>
</tr>
<tr>
<td>4</td>
<td>右</td>
<td><code>+</code></td>
<td>一元正号</td>
<td><code>+expr</code></td>
</tr>
<tr>
<td>4</td>
<td>右</td>
<td><code>*</code></td>
<td>解引用</td>
<td><code>*expr</code></td>
</tr>
<tr>
<td>4</td>
<td>右</td>
<td><code>&amp;</code></td>
<td>取地址</td>
<td><code>&amp;lvalue</code></td>
</tr>
<tr>
<td>4</td>
<td>右</td>
<td><code>()</code></td>
<td>类型转换</td>
<td><code>(type)expr</code></td>
</tr>
<tr>
<td>4</td>
<td>右</td>
<td><code>sizeof</code></td>
<td>对象的大小</td>
<td><code>sizeof expr</code></td>
</tr>
<tr>
<td>4</td>
<td>右</td>
<td><code>sizeof</code></td>
<td>类型的大小</td>
<td><code>sizeof(type)</code></td>
</tr>
<tr>
<td>4</td>
<td>右</td>
<td><code>sizeof...</code></td>
<td>参数包的大小</td>
<td><code>sizeof...(name)</code></td>
</tr>
<tr>
<td>4</td>
<td>右</td>
<td><code>new</code></td>
<td>创建对象</td>
<td><code>new type</code></td>
</tr>
<tr>
<td>4</td>
<td>右</td>
<td><code>new[]</code></td>
<td>创建数组</td>
<td><code>new type[size]</code></td>
</tr>
<tr>
<td>4</td>
<td>右</td>
<td><code>delete</code></td>
<td>释放对象</td>
<td><code>delete expr</code></td>
</tr>
<tr>
<td>4</td>
<td>右</td>
<td><code>delete[]</code></td>
<td>释放数组</td>
<td><code>delete []expr</code></td>
</tr>
<tr>
<td>4</td>
<td>右</td>
<td><code>noexcept</code></td>
<td>能否抛出异常</td>
<td><code>noexcept(expr)</code></td>
</tr>
<tr>
<td>5</td>
<td>左</td>
<td><code>-&gt;*</code></td>
<td>指向成员选择的指针</td>
<td><code>ptr-&gt;*ptr_to_member</code></td>
</tr>
<tr>
<td>5</td>
<td>左</td>
<td><code>.*</code></td>
<td>指向成员选择的指针</td>
<td><code>obj.*ptr_to_member</code></td>
</tr>
<tr>
<td>6</td>
<td>左</td>
<td><code>*</code></td>
<td>乘法</td>
<td><code>expr * expr</code></td>
</tr>
<tr>
<td>6</td>
<td>左</td>
<td><code>/</code></td>
<td>除法</td>
<td><code>expr / expr</code></td>
</tr>
<tr>
<td>6</td>
<td>左</td>
<td><code>%</code></td>
<td>取模（取余）</td>
<td><code>expr % expr</code></td>
</tr>
<tr>
<td>7</td>
<td>左</td>
<td><code>+</code></td>
<td>加法</td>
<td><code>expr + expr</code></td>
</tr>
<tr>
<td>7</td>
<td>左</td>
<td><code>-</code></td>
<td>减法</td>
<td><code>expr - expr</code></td>
</tr>
<tr>
<td>8</td>
<td>左</td>
<td><code>&lt;&lt;</code></td>
<td>向左移位</td>
<td><code>expr &lt;&lt; expr</code></td>
</tr>
<tr>
<td>8</td>
<td>左</td>
<td><code>&gt;&gt;</code></td>
<td>向右移位</td>
<td><code>expr &gt;&gt; expr</code></td>
</tr>
<tr>
<td>9</td>
<td>左</td>
<td><code>&lt;</code></td>
<td>小于</td>
<td><code>expr &lt; expr</code></td>
</tr>
<tr>
<td>9</td>
<td>左</td>
<td><code>&lt;=</code></td>
<td>小于等于</td>
<td><code>expr &lt;= expr</code></td>
</tr>
<tr>
<td>9</td>
<td>左</td>
<td><code>&gt;</code></td>
<td>大于</td>
<td><code>expr &gt; expr</code></td>
</tr>
<tr>
<td>9</td>
<td>左</td>
<td><code>&gt;=</code></td>
<td>大于等于</td>
<td><code>expr &gt;= expr</code></td>
</tr>
<tr>
<td>10</td>
<td>左</td>
<td><code>==</code></td>
<td>相等</td>
<td><code>expr == expr</code></td>
</tr>
<tr>
<td>10</td>
<td>左</td>
<td><code>!=</code></td>
<td>不相等</td>
<td><code>expr != expr</code></td>
</tr>
<tr>
<td>11</td>
<td>左</td>
<td><code>&amp;</code></td>
<td>位与</td>
<td><code>expr &amp; expr</code></td>
</tr>
<tr>
<td>12</td>
<td>左</td>
<td><code>^</code></td>
<td>位异或</td>
<td><code>expr ^ expr</code></td>
</tr>
<tr>
<td>13</td>
<td>左</td>
<td>&#96;</td>
<td>&#96;</td>
<td>位或</td>
</tr>
<tr>
<td>14</td>
<td>左</td>
<td><code>&amp;&amp;</code></td>
<td>逻辑与</td>
<td><code>expr &amp;&amp; expr</code></td>
</tr>
<tr>
<td>15</td>
<td>左</td>
<td>&#96;</td>
<td></td>
<td>&#96;</td>
</tr>
<tr>
<td>16</td>
<td>右</td>
<td><code>? :</code></td>
<td>条件</td>
<td><code>expr ? expr : expr</code></td>
</tr>
<tr>
<td>16</td>
<td>右</td>
<td><code>=</code></td>
<td>赋值</td>
<td><code>lvalue = expr</code></td>
</tr>
<tr>
<td>16</td>
<td>右</td>
<td><code>+=</code>等</td>
<td>复合赋值</td>
<td><code>lvalue += expr</code>等</td>
</tr>
<tr>
<td>17</td>
<td>右</td>
<td><code>throw</code></td>
<td>抛出异常</td>
<td><code>throw expr</code></td>
</tr>
<tr>
<td>18</td>
<td>左</td>
<td><code>,</code></td>
<td>逗号</td>
<td><code>expr, expr</code></td>
</tr>
</tbody></table>
<br>


<h1 id="第五章：语句"><a href="#第五章：语句" class="headerlink" title="第五章：语句"></a>第五章：语句</h1><h2 id="简单语句"><a href="#简单语句" class="headerlink" title="简单语句"></a>简单语句</h2><ul>
<li><strong>表达式语句</strong>：一个表达式末尾加上分号，就变成了表达式语句。</li>
<li><strong>空语句</strong>：只有一个单独的分号。</li>
<li><strong>复合语句（块）</strong>：用花括号 <code>&#123;&#125;</code>包裹起来的语句和声明的序列。一个块就是一个作用域。</li>
</ul>
<br>

<h2 id="语句作用域"><a href="#语句作用域" class="headerlink" title="语句作用域"></a>语句作用域</h2><p>可以在if、switch、while和for语句的控制结构内定义变量，这些变量只在相应语句的内部可见，一旦语句结束，变量也就超出了其作用范围。</p>
<br>

<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><blockquote>
<p>C++语言提供了两种按照条件执行的语句：</p>
<ul>
<li>if语句：根据条件决定控制流</li>
<li>switch语句：计算整型表达式的值，并根据这个值从几条执行路径中选择一条</li>
</ul>
</blockquote>
<h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 普通的if语句</span><br><span class="hljs-keyword">if</span> (condition)<br>    statement<br>    <br><span class="hljs-comment">// if-else语句</span><br><span class="hljs-keyword">if</span> (condition)<br>    statement<br><span class="hljs-keyword">else</span> <br>    statement2<br></code></pre></td></tr></table></figure>

<p><strong>悬垂else</strong>（dangling else）：用来描述在嵌套的<code>if else</code>语句中，如果<code>if</code>比<code>else</code>多时如何处理的问题。C++使用的方法是<code>else</code>匹配最近没有配对的<code>if</code>。</p>
<h3 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h3><hr>
<h4 id="1-例子：统计每个元音字母的数量"><a href="#1-例子：统计每个元音字母的数量" class="headerlink" title="1. 例子：统计每个元音字母的数量"></a>1. 例子：统计每个元音字母的数量</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">unsigned</span> aCnt = <span class="hljs-number">0</span>, eCnt = <span class="hljs-number">0</span>, iCnt = <span class="hljs-number">0</span>, oCnt = <span class="hljs-number">0</span>, uCnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">char</span> ch;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; ch) &#123;<br>    <span class="hljs-keyword">switch</span> (ch) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;a&#x27;</span>:<br>            ++aCnt;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;e&#x27;</span>:<br>            ++eCnt;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;i&#x27;</span>:<br>            ++iCnt;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;o&#x27;</span>:<br>            ++oCnt;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;u&#x27;</span>:<br>            ++uCnt;<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-case标签"><a href="#2-case标签" class="headerlink" title="2. case标签"></a>2. case标签</h4><ul>
<li>case标签<strong>必须是整型常量表达式</strong></li>
<li>任意两个case标签的值不能相同</li>
<li>如果某个case标签匹配成功，将从该标签开始往后顺序执行所有case分支，直到遇到break语句</li>
<li>可以把多个case标签写在同一行内，强调这些case表示的是某个范围内的值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 统计元音字母出现次数</span><br><span class="hljs-type">unsigned</span> vowelCnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">char</span> ch;<br><br><span class="hljs-keyword">while</span> (cin &gt;&gt; ch) &#123;<br>  	<span class="hljs-keyword">switch</span> (ch) &#123;<br>    	<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;e&#x27;</span>: <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;i&#x27;</span>: <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;o&#x27;</span>: <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;u&#x27;</span>:<br>        	++vowelCnt;<br>        	<span class="hljs-keyword">break</span>;<br>	&#125;  <br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-break"><a href="#3-break" class="headerlink" title="3. break"></a>3. break</h4><p><strong>一般不要省略case分支最后的break语句</strong>，如果没写break语句，最好加一段注释说明程序的逻辑，否则可能带来非预期的结果。</p>
<h4 id="4-default标签"><a href="#4-default标签" class="headerlink" title="4. default标签"></a>4. default标签</h4><blockquote>
<p>Tips：标签不应该孤零零存在，它后面必须跟上一条语句或者另外一个case标签。如果switch结构以一个空的default标签作为接受，则该default标签后面必须跟上一条空语句或者一个空块。</p>
</blockquote>
<p>如果没有任何一个case标签能匹配上switch表达式的值，那么程序将执行紧跟在default标签后面的语句：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 统计元音字母和非元音字母出现次数</span><br><span class="hljs-type">unsigned</span> vowelCnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">unsigned</span> otherCnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">char</span> ch;<br><br><span class="hljs-keyword">while</span> (cin &gt;&gt; ch) &#123;<br>  	<span class="hljs-keyword">switch</span> (ch) &#123;<br>    	<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;e&#x27;</span>: <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;i&#x27;</span>: <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;o&#x27;</span>: <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;u&#x27;</span>:<br>        	++vowelCnt;<br>        	<span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            ++otherCnt;<br>            <span class="hljs-keyword">break</span>;<br>	&#125;  <br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4-switch内部的变量定义"><a href="#4-switch内部的变量定义" class="headerlink" title="4. switch内部的变量定义"></a>4. switch内部的变量定义</h4><p>switch的执行流程中可能会跨过某些case标签，如果需要为某个case分支定义并初始化一个变量，我们应该把变量定义在块内，从而保证后面所有case标签都在变量的作用域之外：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">case</span> <span class="hljs-literal">true</span>:<br>	&#123;<br>    	string file_name = <span class="hljs-built_in">get_file_name</span>();<br>	&#125;<br>	<span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-literal">false</span>:<br>	<span class="hljs-comment">// 编译报错: file_name不在作用域之内</span><br>	<span class="hljs-keyword">if</span> (file_name.<span class="hljs-built_in">empty</span>())<br></code></pre></td></tr></table></figure>
<br>

<h2 id="迭代语句"><a href="#迭代语句" class="headerlink" title="迭代语句"></a>迭代语句</h2><h3 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h3><hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span> (condition)<br>    statement<br></code></pre></td></tr></table></figure>
<ul>
<li><p>只要condition的求值结果为true，就一直执行statement（通常是一个块）。condition不能为空，如果condition第一次求值就是false，statement一次都不会执行。</p>
</li>
<li><p><strong>定义在while条件部分或者循环体内的变量每次迭代都经历从创建到销毁的过程。</strong></p>
</li>
<li><p>在不确定迭代次数，或者想在循环结束后访问循环控制变量时，使用while比较合适。</p>
</li>
</ul>
<h3 id="do-while语句"><a href="#do-while语句" class="headerlink" title="do-while语句"></a>do-while语句</h3><hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">do</span></span><br><span class="hljs-function">    statement</span><br><span class="hljs-function"><span class="hljs-title">while</span> <span class="hljs-params">(condition)</span></span>;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>计算condition的值之前会先执行一次statement，condition不能为空。如果condition的值为false，循环终止，否则重复执行statement。</p>
</li>
<li><p>因为do-while语句先执行语句或块，再判断条件，<strong>所以不允许在条件部分定义变量</strong>。</p>
</li>
</ul>
<h3 id="传统的for语句"><a href="#传统的for语句" class="headerlink" title="传统的for语句"></a>传统的for语句</h3><hr>
<p>for语句的语法形式是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (initializer; condition; expression)<br>    statement<br></code></pre></td></tr></table></figure>

<ul>
<li>initializer：初始化值</li>
<li>condition：循环控制条件，为真就会执行一次statement</li>
<li>expression：修改initializer初始化的变量</li>
</ul>
<blockquote>
<p>initializer中可以定义多个对象，但是只能有一条声明语句，因此所有变量的基础类型必须相同：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 通过for循环把vector的元素拷贝一份添加到原来的元素后面</span><br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">decltype</span>(v.<span class="hljs-built_in">size</span>()) i = <span class="hljs-number">0</span>, sz = v.<span class="hljs-built_in">size</span>(); i != sz; ++i) &#123;<br>    v.<span class="hljs-built_in">push_back</span>(v[i]);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="范围for语句"><a href="#范围for语句" class="headerlink" title="范围for语句"></a>范围for语句</h3><hr>
<p>C++11新标准引入了范围for语句：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (declaration : expression)<br>    statement<br></code></pre></td></tr></table></figure>

<p>其中expression表示的是一个序列，比如用花括号括起来的初始值列表、数组或者vector等类型的对象，这些类型的特点是拥有能返回迭代器begin和end成员。declaration定义一个变量，序列中每个元素都能转换成该变量的类型。确保类型相容最简单的办法是使用auto类型说明符。</p>
<blockquote>
<p>注意事项: 在范围for循环中预存了<code>end()</code>的值，一旦在序列中添加（删除）元素，end函数的值就可能变得无效。</p>
</blockquote>
<br>

<h2 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h2><h3 id="break-语句"><a href="#break-语句" class="headerlink" title="break 语句"></a>break 语句</h3><hr>
<p>break语句只能出现在迭代语句或者switch语句的内部，负责终止离它最近的while、do-while、for或者switch语句，并从这些语句之后的第一条语句开始执行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++">string buf;<br><span class="hljs-keyword">while</span> (cin &lt;&lt; buf &amp;&amp; !buf.<span class="hljs-built_in">empty</span>()) &#123;<br>    <span class="hljs-keyword">switch</span>(buf[<span class="hljs-number">0</span>]) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> <span class="hljs-keyword">if</span> = buf.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>; it != buf.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>                <span class="hljs-keyword">if</span> (*it == <span class="hljs-string">&#x27;&#x27;) &#123;</span><br><span class="hljs-string">                    break;  // 第一个break: 离开for循环</span><br><span class="hljs-string">                &#125;</span><br><span class="hljs-string">            &#125;</span><br><span class="hljs-string">            break;  // 第二个break: 离开switch</span><br><span class="hljs-string">        case &#x27;</span>+<span class="hljs-string">&#x27;:</span><br><span class="hljs-string">            // do something...</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure>

<h3 id="continue-语句"><a href="#continue-语句" class="headerlink" title="continue 语句"></a>continue 语句</h3><hr>
<p>continue语句<strong>只能出现在迭代语句的内部</strong>，负责终止离它最近的循环的当前一次迭代并立即开始下一次迭代。和break语句不同的是，只有当switch语句嵌套在迭代语句内部时，才能在switch中使用continue。</p>
<p>continue语句中断当前迭代后，具体操作视迭代语句类型而定：</p>
<ul>
<li><p>对于while和do-while语句来说，继续判断条件的值。</p>
</li>
<li><p>对于传统的for语句来说，继续执行for语句头中的第三部分，之后判断条件的值。</p>
</li>
<li><p>对于范围for语句来说，是用序列中的下一个元素初始化循环变量。</p>
</li>
</ul>
<br>

<h2 id="try语句块和异常处理"><a href="#try语句块和异常处理" class="headerlink" title="try语句块和异常处理"></a>try语句块和异常处理</h2><p>异常（exception）是指程序运行时的反常行为，这些行为超出了函数正常功能的范围。当程序的某一部分检测到一个它无法处理的问题时，需要使用异常处理（exception handling）。</p>
<p>异常处理机制包括throw表达式（throw expression）、try语句块（try block）和异常类（exception class）。</p>
<ul>
<li><p>异常检测部分使用throw表达式表示它遇到了无法处理的问题（throw引发了异常）。</p>
</li>
<li><p>异常处理部分使用try语句块处理异常。try语句块以关键字try开始，并以一个或多个catch子句（catch clause）结束。try语句块中代码抛出的异常通常会被某个catch子句处理，catch子句也被称作异常处理代码（exception handler）。</p>
</li>
<li><p>异常类用于在throw表达式和相关的catch子句之间传递异常的具体信息。</p>
</li>
</ul>
<h3 id="throw表达式"><a href="#throw表达式" class="headerlink" title="throw表达式"></a>throw表达式</h3><hr>
<p>throw表达式包含关键字throw和紧随其后的一个表达式，其中表达式的类型就是抛出的异常类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><br><span class="hljs-keyword">throw</span> <span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;tomocat&quot;</span>);<br></code></pre></td></tr></table></figure>

<h3 id="try语句块"><a href="#try语句块" class="headerlink" title="try语句块"></a>try语句块</h3><hr>
<p>try语句块的通用形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">try</span><br>&#123;<br>    program-statements<br>&#125;<br><span class="hljs-built_in">catch</span> (exception-declaration)<br>&#123;<br>    handler-statements<br>&#125;<br><span class="hljs-built_in">catch</span> (exception-declaration)<br>&#123;<br>    handler-statements<br>&#125; <span class="hljs-comment">// . . .</span><br></code></pre></td></tr></table></figure>

<p>try语句块中的program-statements组成程序的正常逻辑，<strong>其内部声明的变量在块外无法访问</strong>，即使在catch子句中也不行。catch子句包含关键字catch、括号内一个对象的声明（异常声明，exception declaration）和一个块。当选中了某个catch子句处理异常后，执行与之对应的块。<strong>catch一旦完成，程序会跳过剩余的所有catch子句，继续执行后面的语句。</strong></p>
<p>如果最终没能找到与异常相匹配的catch子句，程序会执行名为terminate的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。类似的，如果一段程序没有try语句块且发生了异常，系统也会调用terminate函数并终止当前程序的执行。</p>
<h3 id="标准异常"><a href="#标准异常" class="headerlink" title="标准异常"></a>标准异常</h3><hr>
<p>异常类分别定义在4个头文件中：</p>
<ul>
<li><p>头文件exception定义了最通用的异常类exception。它只报告异常的发生，不提供任何额外信息。</p>
</li>
<li><p>头文件stdexcept定义了几种常用的异常类。<br>stdexcept头文件中定义的异常类如下：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>异常类</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>exception</td>
<td>最常见的问题</td>
</tr>
<tr>
<td>runtime_error</td>
<td>只有在运行时才能检测出的问题</td>
</tr>
<tr>
<td>range_error</td>
<td>运行时错误：生成的结果超出了有意义的值域范围</td>
</tr>
<tr>
<td>overflow_error</td>
<td>运行时错误：计算上溢</td>
</tr>
<tr>
<td>underflow_error</td>
<td>运行时错误：计算下溢</td>
</tr>
<tr>
<td>logic_error</td>
<td>程序逻辑错误</td>
</tr>
<tr>
<td>domian_error</td>
<td>逻辑错误：参数对应的结果值不存在</td>
</tr>
<tr>
<td>invalid_argument</td>
<td>逻辑错误：无效参数</td>
</tr>
<tr>
<td>length_error</td>
<td>逻辑错误：试图创建一个超出该类型最大长度的对象</td>
</tr>
<tr>
<td>out_of_range</td>
<td>逻辑错误：使用一个超出有效范围的值</td>
</tr>
</tbody></table>
<ul>
<li><p>头文件new定义了bad_alloc异常类。</p>
</li>
<li><p>头文件type_info定义了bad_cast异常类。</p>
</li>
<li><p>异常类只定义了一个名为what的成员函数，返回一个提供错误信息的C风格字符串</p>
</li>
<li><p>如果异常类型有一个字符串初始值，那么what方法返回该字符串；对于其他无初始值的异常类型来说，what返回的内容由编译器决定</p>
</li>
</ul>
<br>


<h1 id="第六章：函数"><a href="#第六章：函数" class="headerlink" title="第六章：函数"></a>第六章：函数</h1><h2 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h2><ul>
<li><strong>函数定义</strong>：包括返回类型、函数名字和0个或者多个<strong>形参</strong>（parameter）组成的列表和函数体。</li>
<li><strong>调用运算符</strong>：调用运算符的形式是一对圆括号 <code>()</code>，作用于一个表达式，该表达式是函数或者指向函数的指针。</li>
<li>圆括号内是用逗号隔开的<strong>实参</strong>（argument）列表。</li>
<li>函数调用过程：<ul>
<li>1.主调函数（calling function）的执行被中断。</li>
<li>2.被调函数（called function）开始执行。</li>
</ul>
</li>
<li><strong>形参和实参</strong>：形参和实参的<strong>个数</strong>和<strong>类型</strong>必须匹配上。</li>
<li><strong>返回类型</strong>： <code>void</code>表示函数不返回任何值。函数的返回类型不能是数组类型或者函数类型，但可以是指向数组或者函数的指针。</li>
<li><strong>名字</strong>：名字的作用于是程序文本的一部分，名字在其中可见。</li>
</ul>
<h3 id="局部对象"><a href="#局部对象" class="headerlink" title="局部对象"></a>局部对象</h3><hr>
<ul>
<li><strong>生命周期</strong>：对象的生命周期是程序执行过程中该对象存在的一段时间。</li>
<li><strong>局部变量</strong>（local variable）：形参和函数体内部定义的变量统称为局部变量。它对函数而言是局部的，对函数外部而言是<strong>隐藏</strong>的。</li>
<li><strong>自动对象</strong>：只存在于块执行期间的对象。当块的执行结束后，它的值就变成<strong>未定义</strong>的了。</li>
<li><strong>局部静态对象</strong>： <code>static</code>类型的局部变量，生命周期贯穿函数调用前后。</li>
</ul>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><hr>
<ul>
<li><strong>函数声明</strong>：函数的声明和定义唯一的区别是声明无需函数体，用一个分号替代。函数声明主要用于描述函数的接口，也称<strong>函数原型</strong>。</li>
<li><strong>在头文件中进行函数声明</strong>：建议变量在头文件中声明；在源文件中定义。</li>
<li><strong>分离编译</strong>： <code>CC a.cc b.cc</code>直接编译生成可执行文件；<code>CC -c a.cc b.cc</code>编译生成对象代码<code>a.o b.o</code>； <code>CC a.o b.o</code>编译生成可执行文件。</li>
</ul>
<br>

<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>形参初始化的机理与<strong>变量初始化</strong>一样，形参的类型决定了形参和实参交互的方式：</p>
<ul>
<li><p>当形参是引用类型时，它对应的实参被引用传递（passed by reference），函数被传引用调用（called by reference）。引用形参是它对应实参的别名。</p>
</li>
<li><p>当形参不是引用类型时，形参和实参是两个相互独立的对象，实参的值会被拷贝给形参（值传递，passed by value），函数被传值调用（called by value）。</p>
</li>
</ul>
<h3 id="传值参数"><a href="#传值参数" class="headerlink" title="传值参数"></a>传值参数</h3><hr>
<p><strong>如果形参不是引用类型，则函数对形参做的所有操作都不会影响实参。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// function that takes a pointer and sets the pointed-to value to zero</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(<span class="hljs-type">int</span> *ip)</span></span><br><span class="hljs-function"></span>&#123;<br>    *ip = <span class="hljs-number">0</span>;  <span class="hljs-comment">// changes the value of the object to which ip points</span><br>    ip = <span class="hljs-number">0</span>;   <span class="hljs-comment">// changes only the local copy of ip; the argument is unchanged</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用指针类型的形参可以访问或修改函数外部的对象，建议使用引用形参代替指针形参。</p>
<h3 id="传引用参数"><a href="#传引用参数" class="headerlink" title="传引用参数"></a>传引用参数</h3><hr>
<p>通过使用引用形参，函数可以改变实参的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// function that takes a reference to an int and sets the given object to zero</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;i)</span>  <span class="hljs-comment">// i is just another name for the object passed to reset</span></span><br><span class="hljs-function"></span>&#123;<br>    i = <span class="hljs-number">0</span>;  <span class="hljs-comment">// changes the value of the object to which i refers</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>使用引用形参可以<strong>避免拷贝操作</strong>，拷贝大的类类型对象或容器对象比较低效。另外有的类类型（如IO类型）根本就不支持拷贝操作，这时只能通过引用形参访问该类型的对象。</p>
</li>
<li><p>除了内置类型、函数对象和标准库迭代器外，其他类型的参数建议以引用方式传递。</p>
</li>
<li><p>如果函数无须改变引用形参的值，最好将其声明为常量引用。</p>
</li>
<li><p>一个函数只能返回一个值，但利用引用形参可以使函数返回额外信息。</p>
</li>
</ul>
<h3 id="const形参和实参"><a href="#const形参和实参" class="headerlink" title="const形参和实参"></a>const形参和实参</h3><hr>
<ul>
<li><p>当形参有顶层const时，传递给它常量对象或非常量对象都是可以的。<strong>因为实参初始化形参时会忽略掉顶层const</strong></p>
</li>
<li><p><strong>通用的初始化规则</strong>：可以使用非常量对象初始化一个底层const形参，但是反过来不行。同时一个普通的引用必须用同类型的对象初始化</p>
</li>
<li><p>把函数不会改变的形参定义成普通引用会极大地限制函数所能接受的实参类型，同时也会给别人一种误导，即函数可以修改实参的值。</p>
</li>
</ul>
<h3 id="数组形参"><a href="#数组形参" class="headerlink" title="数组形参"></a>数组形参</h3><hr>
<h4 id="1-传递数组形参"><a href="#1-传递数组形参" class="headerlink" title="1. 传递数组形参"></a>1. 传递数组形参</h4><p>数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响：</p>
<ul>
<li>不允许拷贝数组：无法以值传递的方式使用数组参数</li>
<li>使用数组时会将其转换成指针：当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针</li>
</ul>
<p>尽管不能以值传递的方式传递数组，但是我们把形参写成类似数组的形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 下面三个函数等价, 都接受const int*类型的形参</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>*)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>[])</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>])</span></span>;  <span class="hljs-comment">// 这里的维度表示我们期望数组含有多少个元素, 实际上不一定</span><br></code></pre></td></tr></table></figure>

<h4 id="2-传递数组形参大小"><a href="#2-传递数组形参大小" class="headerlink" title="2. 传递数组形参大小"></a>2. 传递数组形参大小</h4><p>由于数组是以指针的形式传递给函数的，所以函数并不知道数组的确切尺寸，调用者一般需要提供一些额外的信息。管理数组形参通常有三种技术：</p>
<h6 id="2-1-数组中包含结束标记（一般只有C风格字符串）"><a href="#2-1-数组中包含结束标记（一般只有C风格字符串）" class="headerlink" title="2.1 数组中包含结束标记（一般只有C风格字符串）"></a>2.1 数组中包含结束标记（一般只有C风格字符串）</h6><p>第一种方法要求数组本身包含一个结束标记，最典型的例子是C风格字符串，接受C风格字符串的函数在遇到空字符时就会停止：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *cp)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (cp) &#123;               <span class="hljs-comment">// cp不是空指针</span><br>        <span class="hljs-keyword">while</span> (*cp) &#123;       <span class="hljs-comment">// 指针所指字符不是空字符</span><br>            cout &lt;&lt; *cp++;  <span class="hljs-comment">// 输出当前字符并将指针向前移动一个位置</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h6 id="2-2-使用标准库规范"><a href="#2-2-使用标准库规范" class="headerlink" title="2.2 使用标准库规范"></a>2.2 使用标准库规范</h6><blockquote>
<p>Tips：标准库begin和end函数可以返回数组的首元素指针和尾后元素指针。</p>
</blockquote>
<p>第二种方式是传递指向数组首元素和尾后元素的指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> *beg, <span class="hljs-type">const</span> <span class="hljs-type">int</span> *end)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (beg != end) &#123;<br>        cout &lt;&lt; *beg++ &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> j[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">begin</span>(j), <span class="hljs-built_in">end</span>(j));<br></code></pre></td></tr></table></figure>

<h6 id="2-3-显式传递一个表示数组大小的形参"><a href="#2-3-显式传递一个表示数组大小的形参" class="headerlink" title="2.3 显式传递一个表示数组大小的形参"></a>2.3 显式传递一个表示数组大小的形参</h6><p>第三种方法是专门定义一个表示数组大小的形参：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// const int ia[]等价于const int *ia</span><br><span class="hljs-comment">// size表示数组的大小</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> ia[], <span class="hljs-type">size_t</span> size)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i != size; ++i) &#123;<br>        cout &lt;&lt; ia[i] &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> j[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br><span class="hljs-built_in">print</span>(j, <span class="hljs-built_in">end</span>(j) - <span class="hljs-built_in">begin</span>(j));<br></code></pre></td></tr></table></figure>

<h4 id="3-数组形参与const"><a href="#3-数组形参与const" class="headerlink" title="3. 数组形参与const"></a>3. 数组形参与const</h4><p>当函数不需要对数组元素执行写操作时，数组形参应该是指向const的指针。只有当函数确实要改变元素值的时候，才把形参定义成指向常量的指针。</p>
<h4 id="4-数组引用形参"><a href="#4-数组引用形参" class="headerlink" title="4. 数组引用形参"></a>4. 数组引用形参</h4><blockquote>
<p>Tips：当形参是数组的引用时，维度也是类型的一部分。</p>
</blockquote>
<p>C++语言允许将变量定义为数组的引用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 形参是数组的引用, 维度是类型的一部分</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> (&amp;arr)[<span class="hljs-number">10</span>])</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> elem : arr) &#123;<br>        cout &lt;&lt; elem &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意arr两边的括号是必不可少的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">f</span>(<span class="hljs-type">int</span> &amp;arr[<span class="hljs-number">10</span>]);    <span class="hljs-comment">// 错误: 将arr声明成了引用的数组</span><br><span class="hljs-built_in">f</span>(<span class="hljs-built_in">int</span> (&amp;arr)[<span class="hljs-number">10</span>]);  <span class="hljs-comment">// 正确: arr是具有10个整数的整型数组的引用</span><br></code></pre></td></tr></table></figure>

<p>由于数组的大小是构成数组类型的一部分，所以只要不超过维度，在函数体内我们可以放心地使用数组。但是这一用法也无形中限制了print函数的可用性，我们只能将函数作用于维度为10的数组。</p>
<h4 id="5-传递多维数组"><a href="#5-传递多维数组" class="headerlink" title="5. 传递多维数组"></a>5. 传递多维数组</h4><p>前面我们提到过C++中并没有真正的多维数组，所谓的数组其实是数组的数组。和所有的数组一样，当我们把多维数组传递给函数时，实际上传递的是指向数组首元素的指针，即一个指向数组的指针。</p>
<blockquote>
<p>Tips：由于数组第二维以及后面的维度的大小都是数组类型的一部分，因此传递多维数组时不能省略。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// matrix是指向含有10个整数的数组的指针</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> (*matrix)[<span class="hljs-number">10</span>], <span class="hljs-type">int</span> rowSize)</span></span>;<br><br><span class="hljs-comment">// 等价定义</span><br><span class="hljs-comment">// 由于编译器会忽略掉第一个维度, 因此最好不要把它包含在形参列表内</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> matrix[][<span class="hljs-number">10</span>], <span class="hljs-type">int</span> rowSize)</span></span>;<br></code></pre></td></tr></table></figure>

<br>

<h3 id="main函数处理命令行选项"><a href="#main函数处理命令行选项" class="headerlink" title="main函数处理命令行选项"></a>main函数处理命令行选项</h3><hr>
<p>假设我们的可执行文件名为prog，我们可以向程序传递如下选项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">prog -d -o ofile data0<br></code></pre></td></tr></table></figure>

<p>这些选项会通过两个可选的形参传递给main函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span>;<br><br><span class="hljs-comment">// 等价</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span></span>;<br></code></pre></td></tr></table></figure>

<p>其中第二个形参argv是一个数组，它的元素是指向C风格字符串的指针，第一个形参argc表示数组中字符串的数量。</p>
<p>当实参传递给main函数之后，argv第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为0。</p>
<p>在前面的例子中，argc等于5，argv指向的类型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">argv[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;prog&quot;</span>;  <span class="hljs-comment">// 或者一个空字符串</span><br>argv[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;-d&quot;</span>;<br>argv[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;-o&quot;</span>;<br>argv[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;ofile&quot;</span>;<br>argv[<span class="hljs-number">4</span>] = <span class="hljs-string">&quot;data0&quot;</span>;<br>argv[<span class="hljs-number">5</span>] = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>

<br>

<h3 id="可变形参"><a href="#可变形参" class="headerlink" title="可变形参"></a>可变形参</h3><hr>
<p><code>initializer_list</code>提供的操作（<code>C++11</code>）：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>initializer_list&lt;T&gt; lst;</code></td>
<td>默认初始化；<code>T</code>类型元素的空列表</td>
</tr>
<tr>
<td><code>initializer_list&lt;T&gt; lst&#123;a,b,c...&#125;;</code></td>
<td><code>lst</code>的元素数量和初始值一样多；<code>lst</code>的元素是对应初始值的副本；列表中的元素是<code>const</code>。</td>
</tr>
<tr>
<td><code>lst2(lst)</code></td>
<td>拷贝或赋值一个<code>initializer_list</code>对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素。</td>
</tr>
<tr>
<td><code>lst2 = lst</code></td>
<td>同上</td>
</tr>
<tr>
<td><code>lst.size()</code></td>
<td>列表中的元素数量</td>
</tr>
<tr>
<td><code>lst.begin()</code></td>
<td>返回指向<code>lst</code>中首元素的指针</td>
</tr>
<tr>
<td><code>lst.end()</code></td>
<td>返回指向<code>lst</code>中微元素下一位置的指针</td>
</tr>
</tbody></table>
<p><code>initializer_list</code>使用demo：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">err_msg</span><span class="hljs-params">(ErrCode e, initializer_list&lt;string&gt; il)</span></span>&#123;<br>    cout &lt;&lt; e.msg &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> bed = il.<span class="hljs-built_in">begin</span>(); beg != il.<span class="hljs-built_in">end</span>(); ++ beg)<br>        cout &lt;&lt; *beg &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-built_in">err_msg</span>(<span class="hljs-built_in">ErrCode</span>(<span class="hljs-number">0</span>), &#123;<span class="hljs-string">&quot;functionX&quot;</span>, <span class="hljs-string">&quot;okay&#125;);</span><br></code></pre></td></tr></table></figure>

<ul>
<li>所有实参类型相同，可以使用 <code>initializer_list</code>的标准库类型。</li>
<li>实参类型不同，可以使用<code>可变参数模板</code>。</li>
<li>省略形参符： <code>...</code>，便于<code>C++</code>访问某些C代码，这些C代码使用了 <code>varargs</code>的C标准功能。</li>
</ul>
<br>

<h2 id="返回类型和return语句"><a href="#返回类型和return语句" class="headerlink" title="返回类型和return语句"></a>返回类型和return语句</h2><h3 id="无返回值函数"><a href="#无返回值函数" class="headerlink" title="无返回值函数"></a>无返回值函数</h3><hr>
<p>没有返回值的 <code>return</code>语句只能用在返回类型是 <code>void</code>的函数中，返回 <code>void</code>的函数不要求非得有 <code>return</code>语句。</p>
<h3 id="有返回值函数"><a href="#有返回值函数" class="headerlink" title="有返回值函数"></a>有返回值函数</h3><hr>
<ul>
<li><code>return</code>语句的返回值的类型必须和函数的返回类型相同，或者能够<strong>隐式地</strong>转换成函数的返回类型。</li>
<li>值的返回：返回的值用于初始化调用点的一个<strong>临时量</strong>，该临时量就是函数调用的结果。</li>
<li><strong>不要返回局部对象的引用或指针</strong>。</li>
<li><strong>引用返回左值</strong>：函数的返回类型决定函数调用是否是左值。调用一个返回引用的函数得到左值；其他返回类型得到右值。</li>
<li><strong>列表初始化返回值</strong>：函数可以返回花括号包围的值的列表。（<code>C++11</code>）</li>
<li><strong>主函数main的返回值</strong>：如果结尾没有<code>return</code>，编译器将隐式地插入一条返回0的<code>return</code>语句。返回0代表执行成功。</li>
</ul>
<h3 id="不要返回局部对象的引用或指针"><a href="#不要返回局部对象的引用或指针" class="headerlink" title="不要返回局部对象的引用或指针"></a>不要返回局部对象的引用或指针</h3><hr>
<p>函数完成后它所占用的存储空间也会被释放掉，因此局部变量的引用将指向不再有效的内存区域：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 严重错误: 试图返回局部对象的引用</span><br><span class="hljs-function"><span class="hljs-type">const</span> string &amp;<span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>    string ret;<br>    <span class="hljs-keyword">if</span> (!ret.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">return</span> ret;      <span class="hljs-comment">// 错误: 返回局部对象的引用</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Empty&quot;</span>;  <span class="hljs-comment">// 错误: 返回局部对象的引用</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="列表初始化返回值"><a href="#列表初始化返回值" class="headerlink" title="列表初始化返回值"></a>列表初始化返回值</h3><hr>
<p>C++11新标准规定，函数可以通过列表初始化来对函数返回的临时量进行初始化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function">std::vector&lt;std::string&gt; <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">5</span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;  <span class="hljs-comment">// 返回一个空vector对象</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;tomo&quot;</span>, <span class="hljs-string">&quot;cat&quot;</span>, <span class="hljs-string">&quot;tomocat&quot;</span>&#125;;  <span class="hljs-comment">// 返回列表初始化的vector对象</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">foo</span>(<span class="hljs-number">10</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="main函数返回值"><a href="#main函数返回值" class="headerlink" title="main函数返回值"></a>main函数返回值</h3><hr>
<p>main函数的返回值可以看成是状态指示器，返回0表示成功，返回其他值表示失败。<code>cstdlib</code>头文件定义了两个预处理变量，分别表示成功和失败：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (some_failure) &#123;<br>        <span class="hljs-keyword">return</span> EXIT_FAILURE;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> EXIT_SUCCESS:<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="返回函数指针"><a href="#返回函数指针" class="headerlink" title="返回函数指针"></a>返回函数指针</h3><hr>
<p>由于数组不能拷贝，因此函数不能返回数组，不过可以返回数组的指针或者引用。想要定义一个返回数组的引用或者指针的函数比较繁琐，不过我们可以使用类型别名来简化这一任务：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// arrT: 包含10个整型元素数组的类型别名</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> arrT[<span class="hljs-number">10</span>];<br><span class="hljs-comment">// arrT的等价声明</span><br><span class="hljs-keyword">using</span> arrT = <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];<br><br><span class="hljs-function">arrT* <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>;  <span class="hljs-comment">// 返回指向10个整数的数组的指针</span><br></code></pre></td></tr></table></figure>

<p>如果不使用类型别名，那么相同的函数我们需要写成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">int</span> (*<span class="hljs-built_in">func</span>(<span class="hljs-type">int</span> i))[<span class="hljs-number">10</span>];<br></code></pre></td></tr></table></figure>

<p>C++11允许我们使用尾置返回类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> -&gt; <span class="hljs-title">int</span><span class="hljs-params">(*)</span>[10]</span>;<br></code></pre></td></tr></table></figure>

<p>还有一种情况是如果我们直到函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> odd[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>&#125;;<br><span class="hljs-type">int</span> even[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>&#125;;<br><br><span class="hljs-comment">// 根据i指向的不同返回两个已知数组中的一个</span><br><span class="hljs-keyword">decltype</span>(odd) *<span class="hljs-built_in">arrPtr</span>(<span class="hljs-type">int</span> i) &#123;<br>    <span class="hljs-keyword">return</span> (i % <span class="hljs-number">2</span>) ? &amp;odd : &amp;even;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="尾置返回类型"><a href="#尾置返回类型" class="headerlink" title="尾置返回类型"></a>尾置返回类型</h3><hr>
<blockquote>
<p>编码规范：只有在常规写法（返回类型前置）不便于书写或者不便于阅读时才使用返回类型后置语法。</p>
</blockquote>
<p>C++现在允许两种不同的函数声明方式，以往的写法是将返回类型置于函数名之前：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>;<br></code></pre></td></tr></table></figure>

<p>C++11新标准引入了尾置返回类型，可以在函数名前使用<code>auto</code>关键字，在参数列表之后后置返回类型，例如：</p>
<blockquote>
<p>Tips：尾置返回类型是显式地指定<code>Lambda</code>表达式返回值的唯一方式，当返回类型依赖模板参数时也可以使用使用尾置返回类型。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 普通函数</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> -&gt; <span class="hljs-type">int</span></span>;<br><br><span class="hljs-comment">// lambda表达式</span><br><span class="hljs-keyword">auto</span> f = []() -&gt; <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; &#125;;<br><br><span class="hljs-comment">// 模型函数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">U</span>&gt; <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(T t, U u)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(t + u)</span></span>;<br></code></pre></td></tr></table></figure>

<br>

<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><blockquote>
<p>如果同一作用域内几个函数名字相同但形参列表不同，我们称之为重载（overload）函数。</p>
</blockquote>
<h2 id="main函数不能重载。-重载和const形参"><a href="#main函数不能重载。-重载和const形参" class="headerlink" title="main函数不能重载。### 重载和const形参"></a><code>main</code>函数不能重载。<br><br>### 重载和const形参</h2><h4 id="1-顶层const"><a href="#1-顶层const" class="headerlink" title="1. 顶层const"></a>1. 顶层const</h4><p>一个有顶层const的形参和没有它的函数无法区分。<code>Record lookup(Phone* const)</code>和 <code>Record lookup(Phone*)</code>无法区分。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 错误: 重复声明foo(string)函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(string)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">const</span> string)</span></span>;<br><br><span class="hljs-comment">// 错误: 重复声明foo(string*)函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(string*)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(string* <span class="hljs-type">const</span>)</span></span>;<br></code></pre></td></tr></table></figure>

<h4 id="2-底层const"><a href="#2-底层const" class="headerlink" title="2. 底层const"></a>2. 底层const</h4><p>相反，是否有某个底层const形参可以区分。 <code>Record lookup(Account*)</code>和 <code>Record lookup(const Account*)</code>可以区分。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 正确</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(string&amp;)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp;)</span></span>;<br><br><span class="hljs-comment">// 正确</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(string*)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-type">const</span> string*)</span></span>;<br></code></pre></td></tr></table></figure>

<h4 id="const-cast与重载"><a href="#const-cast与重载" class="headerlink" title="const_cast与重载"></a>const_cast与重载</h4><p><code>const_cast</code>最常用于重载函数的情景。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 常量引用的函数版本</span><br><span class="hljs-function"><span class="hljs-type">const</span> string &amp;<span class="hljs-title">shorterString</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;s1, <span class="hljs-type">const</span> string &amp;s2)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> s1.<span class="hljs-built_in">size</span>() &lt;= s2.<span class="hljs-built_in">size</span>() ? s1 : s2;<br>&#125;<br><br><span class="hljs-comment">// 非常量引用的函数版本复用常量引用的函数版本</span><br><span class="hljs-function">string &amp;<span class="hljs-title">shorterString</span><span class="hljs-params">(string &amp;s1, string &amp;s2)</span> </span>&#123;<br>    <span class="hljs-type">const</span> string &amp;r = <span class="hljs-built_in">shorterString</span>(<span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">const</span> string&amp;&gt;(s1),<br>                                    <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">const</span> string&amp;&gt;(s2));<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">const_cast</span>&lt;string &amp;&gt;(r);<br>&#125;<br></code></pre></td></tr></table></figure>

<br>

<h3 id="重载和作用域"><a href="#重载和作用域" class="headerlink" title="重载和作用域"></a>重载和作用域</h3><hr>
<p>在不同的作用域中无法重载函数名。一旦在当前作用域内找到了所需的名字，编译器就会忽略掉外层作用域中的同名实体。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">string <span class="hljs-title">read</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span></span>;     <span class="hljs-comment">// overloads the print function</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fooBar</span><span class="hljs-params">(<span class="hljs-type">int</span> ival)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">bool</span> read = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// new scope: hides the outer declaration of read</span><br>    string s = <span class="hljs-built_in">read</span>();  <span class="hljs-comment">// error: read is a bool variable, not a function</span><br>    <span class="hljs-comment">// bad practice: usually it&#x27;s a bad idea to declare functions at local scope</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;    <span class="hljs-comment">// new scope: hides previous instances of print</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Value: &quot;</span>);   <span class="hljs-comment">// error: print(const string &amp;) is hidden</span><br>    <span class="hljs-built_in">print</span>(ival);    <span class="hljs-comment">// ok: print(int) is visible</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-number">3.14</span>);    <span class="hljs-comment">// ok: calls print(int); print(double) is hidden</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>在C++中，名字查找发生在类型检查之前。</p>
<br>

<h2 id="特殊用途语言特性"><a href="#特殊用途语言特性" class="headerlink" title="特殊用途语言特性"></a>特殊用途语言特性</h2><h3 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h3><hr>
<ul>
<li><code>string screen(sz ht = 24, sz wid = 80, char backgrnd = &#39; &#39;);</code></li>
<li>一旦某个形参被赋予了默认值，那么它之后的形参都必须要有默认值。</li>
</ul>
<h3 id="内联（inline）函数"><a href="#内联（inline）函数" class="headerlink" title="内联（inline）函数"></a>内联（inline）函数</h3><hr>
<ul>
<li>普通函数的缺点：调用函数比求解等价表达式要慢得多。</li>
<li><code>inline</code>函数可以避免函数调用的开销，可以让编译器在编译时<strong>内联地展开</strong>该函数。</li>
<li><code>inline</code>函数应该在头文件中定义。</li>
</ul>
<h3 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a>constexpr函数</h3><hr>
<ul>
<li>指能用于常量表达式的函数。</li>
<li><code>constexpr int new_sz() &#123;return 42;&#125;</code></li>
<li>函数的返回类型及所有形参类型都要是字面值类型。</li>
<li><code>constexpr</code>函数应该在头文件中定义。</li>
</ul>
<h3 id="调试帮助"><a href="#调试帮助" class="headerlink" title="调试帮助"></a>调试帮助</h3><hr>
<ul>
<li><code>assert</code>预处理宏（preprocessor macro）：<code>assert(expr);</code></li>
</ul>
<p>开关调试状态：</p>
<p><code>CC -D NDEBUG main.c</code>可以定义这个变量<code>NDEBUG</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> NDEBUG</span><br>        cerr &lt;&lt; __func__ &lt;&lt; <span class="hljs-string">&quot;...&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure>

<br>

<h2 id="函数匹配"><a href="#函数匹配" class="headerlink" title="函数匹配"></a>函数匹配</h2><ul>
<li>重载函数匹配的<strong>三个步骤</strong>：1.候选函数；2.可行函数；3.寻找最佳匹配。</li>
<li><strong>候选函数</strong>：选定本次调用对应的重载函数集，集合中的函数称为候选函数（candidate function）。</li>
<li><strong>可行函数</strong>：考察本次调用提供的实参，选出可以被这组实参调用的函数，新选出的函数称为可行函数（viable function）。</li>
<li><strong>寻找最佳匹配</strong>：基本思想：实参类型和形参类型越接近，它们匹配地越好。</li>
<li><strong>const重载</strong>：顶层const会忽略，所以不可以函数重载，底层const虽然非常量对象既可以初始化const形参和非const形参，但是编译器为了避免类型转换，会选择非常量版本的函数，所以底层const可以重载。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(Account&amp;)</span></span>;    <span class="hljs-comment">// function that takes a reference to Account</span><br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-type">const</span> Account&amp;)</span></span>;  <span class="hljs-comment">// new function that takes a const reference</span><br><br><span class="hljs-type">const</span> Account a;<br>Account b;<br><span class="hljs-built_in">lookup</span>(a);  <span class="hljs-comment">// calls lookup(const Account&amp;)</span><br><span class="hljs-built_in">lookup</span>(b);  <span class="hljs-comment">// calls lookup(Account&amp;)</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p>调用重载函数<br>调用重载函数时有三种可能的结果：</p>
<ul>
<li><p>编译器找到一个与实参最佳匹配的函数，并生成调用该函数的代码</p>
</li>
<li><p>找不到任何一个函数与调用的实参匹配，这时候编译器发出无匹配的错误信息</p>
</li>
<li><p>有多于一个函数可以匹配，但是每一个都不是明显的最佳选择，此时会发生<strong>二义性调用的错误</strong></p>
</li>
</ul>
<br>

<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针指向的是函数而非对象，与其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">lengthCompare</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;, <span class="hljs-type">const</span> string &amp;)</span></span>;<br><span class="hljs-comment">// pf是一个未初始化的函数指针: 参数是两个const string的引用, 返回值是bool类型</span><br><span class="hljs-built_in">bool</span> (*pf) (<span class="hljs-type">const</span> string &amp;, <span class="hljs-type">const</span> string &amp;);<br></code></pre></td></tr></table></figure>

<p>把函数名作为一个值时, 该函数自动转换成指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// pf指向名为lengthCompare的函数</span><br>pf = lengthCompare;<br><span class="hljs-comment">// 等价写法</span><br>pf = &amp;lengthCompare;<br></code></pre></td></tr></table></figure>

<p>我们可以使用函数指针调用该函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 等价的三种写法</span><br><span class="hljs-type">bool</span> b1 = <span class="hljs-built_in">pf</span>(<span class="hljs-string">&quot;tomo&quot;</span>, <span class="hljs-string">&quot;cat&quot;</span>);<br><span class="hljs-type">bool</span> b2 = (*pf)(<span class="hljs-string">&quot;tomo&quot;</span>, <span class="hljs-string">&quot;cat&quot;</span>);<br><span class="hljs-type">bool</span> b3 = <span class="hljs-built_in">lengthCompare</span>(<span class="hljs-string">&quot;tomo&quot;</span>, <span class="hljs-string">&quot;cat&quot;</span>);<br></code></pre></td></tr></table></figure>

<h3 id="函数指针形参"><a href="#函数指针形参" class="headerlink" title="函数指针形参"></a>函数指针形参</h3><hr>
<p>虽然不能定义函数类型的形参，但是形参可以是指向函数的指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 第三个参数是函数类型, 它会自动转换成函数指针</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">useBigger</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;s1, <span class="hljs-type">const</span> string &amp;s2,</span></span><br><span class="hljs-params"><span class="hljs-function">              <span class="hljs-type">bool</span> pf(<span class="hljs-type">const</span> string &amp;, <span class="hljs-type">const</span> string &amp;))</span></span>;<br><span class="hljs-comment">// 等价声明: 显式将形参定义成函数指针</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">useBigger</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;s1, <span class="hljs-type">const</span> string &amp;s2,</span></span><br><span class="hljs-params"><span class="hljs-function">              <span class="hljs-type">bool</span> (*pf) (<span class="hljs-type">const</span> string &amp;, <span class="hljs-type">const</span> string &amp;))</span></span>;<br></code></pre></td></tr></table></figure>

<p>我们可以使用类型别名和decltype来简化使用了函数指针的代码：</p>
<blockquote>
<p>Tips：decltype返回函数类型，此时不会将函数类型自动转换成指针类型，只有在结果前面加上<code>*</code>才能得到函数指针。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Func1和Func2是函数类型</span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-type">bool</span> <span class="hljs-title">Func1</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp;, <span class="hljs-type">const</span> string&amp;)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">decltype</span><span class="hljs-params">(lengthCompare)</span> Func2</span>;<br><span class="hljs-comment">// FuncP1和FuncP2是函数指针类型</span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">bool</span><span class="hljs-params">(*FuncP1)</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp;, <span class="hljs-type">const</span> string&amp;)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">decltype</span><span class="hljs-params">(lengthCompare)</span> *FuncP2</span>;<br><span class="hljs-comment">// 使用类型别名简化useBigger函数的声明</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">useBigger</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp;, <span class="hljs-type">const</span> string&amp;, Func1)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">useBigger</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp;, <span class="hljs-type">const</span> string&amp;, Func2)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">useBigger</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp;, <span class="hljs-type">const</span> string&amp;, FuncP1)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">useBigger</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp;, <span class="hljs-type">const</span> string&amp;, FuncP2)</span></span>;<br></code></pre></td></tr></table></figure>

<h3 id="返回指向函数的指针"><a href="#返回指向函数的指针" class="headerlink" title="返回指向函数的指针"></a>返回指向函数的指针</h3><hr>
<h4 id="1-类型别名using简化返回函数指针的函数声明"><a href="#1-类型别名using简化返回函数指针的函数声明" class="headerlink" title="1. 类型别名using简化返回函数指针的函数声明"></a>1. 类型别名using简化返回函数指针的函数声明</h4><p>一般情况下直接声明返回函数指针的函数比较复杂：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// foo参数为int, 返回值是int(*)(int*, int)的函数指针</span><br><span class="hljs-built_in">int</span> (*<span class="hljs-built_in">foo</span>(<span class="hljs-type">int</span>))(<span class="hljs-type">int</span>*, <span class="hljs-type">int</span>);<br></code></pre></td></tr></table></figure>

<p>新标准下我们可以使用<code>using</code>关键字定义类型别名：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// F是函数类型而非函数指针类型</span><br><span class="hljs-keyword">using</span> F = <span class="hljs-built_in">int</span>(<span class="hljs-type">int</span>*, <span class="hljs-type">int</span>);<br><span class="hljs-comment">// PF是函数指针类型</span><br><span class="hljs-keyword">using</span> PF = <span class="hljs-built_in">int</span>(*)(<span class="hljs-type">int</span>*, <span class="hljs-type">int</span>);<br></code></pre></td></tr></table></figure>

<p>有了类型别名我们可以将foo函数重新声明为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// foo接收int类型作为参数, 返回PF的函数指针</span><br><span class="hljs-function">PF <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-comment">// 等价写法</span><br><span class="hljs-function">F *<span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br></code></pre></td></tr></table></figure>

<h4 id="2-尾置返回类型"><a href="#2-尾置返回类型" class="headerlink" title="2. 尾置返回类型"></a>2. 尾置返回类型</h4><p>前面提到的foo函数还有另外一种声明方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> -&gt; <span class="hljs-title">int</span><span class="hljs-params">(*)</span><span class="hljs-params">(<span class="hljs-type">int</span>* <span class="hljs-type">int</span>)</span></span>;<br></code></pre></td></tr></table></figure>

<br>


<h1 id="第七章：-类"><a href="#第七章：-类" class="headerlink" title="第七章： 类"></a>第七章： 类</h1><h2 id="定义抽象数据类型"><a href="#定义抽象数据类型" class="headerlink" title="定义抽象数据类型"></a>定义抽象数据类型</h2><ul>
<li><strong>类背后的基本思想</strong>：<strong>数据抽象</strong>（data abstraction）和<strong>封装</strong>（encapsulation）。</li>
<li>数据抽象是一种依赖于<strong>接口</strong>（interface）和<strong>实现</strong>（implementation）分离的编程技术。</li>
</ul>
<br>

<h3 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h3><hr>
<ul>
<li>必须在类的内部声明，不能在其他地方增加成员。</li>
<li>成员可以是数据，函数，类型别名。<blockquote>
<p>Tips：用来定义类型的成员和普通成员不同，必须先定义后使用，因此类型成员通常出现在类开始的地方。</p>
</blockquote>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 类型别名, 等价于: using pos = std::string::size_type</span><br>    <span class="hljs-keyword">typedef</span> std::string::size_type pos;<br> <span class="hljs-keyword">private</span>:<br>    pos cursor = <span class="hljs-number">0</span>;<br>    pos height = <span class="hljs-number">0</span>, width = <span class="hljs-number">0</span>;<br>    std::string contents;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><hr>
<h4 id="1-声明与定义"><a href="#1-声明与定义" class="headerlink" title="1. 声明与定义"></a>1. 声明与定义</h4><ul>
<li>成员函数的<strong>声明</strong>必须在类的内部。</li>
<li>成员函数的<strong>定义</strong>既可以在类的内部也可以在外部。</li>
</ul>
<h4 id="2-this指针"><a href="#2-this指针" class="headerlink" title="2. this指针"></a>2. this指针</h4><ul>
<li>每个成员函数都有一个额外的，隐含的形参<code>this</code>。</li>
<li><code>this</code>总是指向当前对象，因此<code>this</code>是一个常量指针。</li>
<li>形参表后面的<code>const</code>，改变了隐含的<code>this</code>形参的类型，如 <code>bool same_isbn(const Sales_item &amp;rhs) const</code>，这种函数称为“常量成员函数”（<code>this</code>指向的当前对象是常量）。</li>
<li><code>return *this;</code>可以让成员函数连续调用。</li>
<li>普通的非<code>const</code>成员函数：<code>this</code>是指向类类型的<code>const</code>指针（可以改变<code>this</code>所指向的值，不能改变<code>this</code>保存的地址）。</li>
<li><code>const</code>成员函数：<code>this</code>是指向const类类型的<code>const</code>指针（既不能改变<code>this</code>所指向的值，也不能改变<code>this</code>保存的地址）。</li>
</ul>
<h4 id="3-const限定符"><a href="#3-const限定符" class="headerlink" title="3. const限定符"></a>3. const限定符</h4><ul>
<li><p>默认情况下，this的类型是指向类类型非常量版本的常量指针。this也遵循初始化规则，所以默认不能把this绑定到一个常量对象上，即不能在常量对象上调用普通的成员函数。</p>
</li>
<li><p>C++允许在成员函数的参数列表后面添加关键字const，表示this是一个指向常量的指针。使用关键字const的成员函数被称作常量成员函数</p>
</li>
<li><p>常量对象和指向常量对象的引用或指针都只能调用常量成员函数。</p>
</li>
</ul>
<br>

<h3 id="非成员函数"><a href="#非成员函数" class="headerlink" title="非成员函数"></a>非成员函数</h3><hr>
<p>类的作者通常会定义一些辅助函数，尽管这些函数从概念上来说属于类接口的组成部分，但实际上它们并不属于类本身。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// input transactions contain ISBN, number of copies sold, and sales price</span><br><span class="hljs-function">istream &amp;<span class="hljs-title">read</span><span class="hljs-params">(istream &amp;is, Sales_data &amp;item)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span> price = <span class="hljs-number">0</span>;<br>    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;<br>    item.revenue = price * item.units_sold;<br>    <span class="hljs-keyword">return</span> is;<br>&#125;<br><br><span class="hljs-function">ostream &amp;<span class="hljs-title">print</span><span class="hljs-params">(ostream &amp;os, <span class="hljs-type">const</span> Sales_data &amp;item)</span></span><br><span class="hljs-function"></span>&#123;<br>    os &lt;&lt; item.<span class="hljs-built_in">isbn</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; item.units_sold &lt;&lt; <span class="hljs-string">&quot; &quot;</span><br>        &lt;&lt; item.revenue &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; item.<span class="hljs-built_in">avg_price</span>();<br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果非成员函数是类接口的组成部分，则这些函数的声明应该与类放在同一个头文件中。</p>
<p>一般来说，执行输出任务的函数应该尽量减少对格式的控制。</p>
<br>

<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><hr>
<ul>
<li><p>类通过一个或几个特殊的成员函数来控制其对象的初始化操作，这些函数被称作构造函数。只要类的对象被创建，就会执行构造函数。</p>
</li>
<li><p>构造函数的名字和类名相同，没有返回类型，且不能被声明为const函数。构造函数在const对象的构造过程中可以向其写值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sales_data</span><br>&#123;<br>    <span class="hljs-comment">// constructors added</span><br>    <span class="hljs-built_in">Sales_data</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Sales_data</span>(<span class="hljs-type">const</span> std::string &amp;s): <span class="hljs-built_in">bookNo</span>(s) &#123; &#125;<br>    <span class="hljs-built_in">Sales_data</span>(<span class="hljs-type">const</span> std::string &amp;s, <span class="hljs-type">unsigned</span> n, <span class="hljs-type">double</span> p):<br>        <span class="hljs-built_in">bookNo</span>(s), <span class="hljs-built_in">units_sold</span>(n), <span class="hljs-built_in">revenue</span>(p*n) &#123; &#125;<br>    <span class="hljs-built_in">Sales_data</span>(std::istream &amp;);<br>    <span class="hljs-comment">// other members as before</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4><p>在C++11中，如果类需要默认的函数行为，可以通过在参数列表后面添加&#x3D;default来要求编译器生成构造函数。其中&#x3D;default既可以和函数声明一起出现在类的内部，也可以作为定义出现在类的外部。和其他函数一样，如果&#x3D;default在类的内部，则默认构造函数是内联的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">Sales_data</span>() = <span class="hljs-keyword">default</span>;<br></code></pre></td></tr></table></figure>

<h4 id="构造函数初始值列表"><a href="#构造函数初始值列表" class="headerlink" title="构造函数初始值列表"></a>构造函数初始值列表</h4><p>构造函数初始值列表（constructor initializer list）负责为新创建对象的一个或几个数据成员赋初始值。形式是每个成员名字后面紧跟括号括起来的（或者在花括号内的）成员初始值，不同成员的初始值通过逗号分隔。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">Sales_data</span>(<span class="hljs-type">const</span> std::string &amp;s): <span class="hljs-built_in">bookNo</span>(s) &#123; &#125;<br><span class="hljs-built_in">Sales_data</span>(<span class="hljs-type">const</span> std::string &amp;s, <span class="hljs-type">unsigned</span> n, <span class="hljs-type">double</span> p):<br>    <span class="hljs-built_in">bookNo</span>(s), <span class="hljs-built_in">units_sold</span>(n), <span class="hljs-built_in">revenue</span>(p*n) &#123; &#125;<br></code></pre></td></tr></table></figure>
<p>当某个数据成员被构造函数初始值列表忽略时，它会以与合成默认构造函数相同的方式隐式初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// has the same behavior as the original constructor defined above</span><br><span class="hljs-built_in">Sales_data</span>(<span class="hljs-type">const</span> std::string &amp;s):<br>    <span class="hljs-built_in">bookNo</span>(s), <span class="hljs-built_in">units_sold</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">revenue</span>(<span class="hljs-number">0</span>) &#123; &#125;<br></code></pre></td></tr></table></figure>
<p>构造函数不应该轻易覆盖掉类内初始值，除非新值与原值不同。如果编译器不支持类内初始值，则所有构造函数都应该显式初始化每个内置类型的成员。</p>
<br>


<h3 id="拷贝、赋值和析构（Copy、Assignment，and-Destruction）"><a href="#拷贝、赋值和析构（Copy、Assignment，and-Destruction）" class="headerlink" title="拷贝、赋值和析构（Copy、Assignment，and Destruction）"></a>拷贝、赋值和析构（Copy、Assignment，and Destruction）</h3><hr>
<p>编译器能合成拷贝、赋值和析构函数，但是对于某些类来说合成的版本无法正常工作。特别是当类需要分配类对象之外的资源时，合成的版本通常会失效。</p>
<br>

<h2 id="访问控制与封装"><a href="#访问控制与封装" class="headerlink" title="访问控制与封装"></a>访问控制与封装</h2><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" class="category-chain-item">编程语言</a>
  
  
    <span>></span>
    
  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/" class="category-chain-item">C++</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/C/" class="print-no-link">#C++</a>
      
        <a href="/tags/C-Primer/" class="print-no-link">#C++ Primer</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>C++ Primer Part1 - C++基础</div>
      <div>https://vendestine.com/2023/04/07/编程语言/C++/c++-primer-p1/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Wenzhe Li</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>April 7, 2023</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/05/04/%E5%BA%95%E5%B1%82%E5%BC%80%E5%8F%91/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/os-learn-memory/" title="操作系统--内存管理">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">操作系统--内存管理</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/03/14/%E5%BA%95%E5%B1%82%E5%BC%80%E5%8F%91/linux%E4%B8%93%E6%A0%8F/web-server/" title="Linux-开发笔记">
                        <span class="hidden-mobile">Linux-开发笔记</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"IjvyDUC4CWIE5z0piBf1Dqia-9Nh9j0Va","appKey":"KQ2019uci92UXL6srhLsiY9K","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        Views: 
        <span id="leancloud-site-pv"></span>
        
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        Visitors: 
        <span id="leancloud-site-uv"></span>
        
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
